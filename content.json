{"meta":{"title":"D-Moon's Blog","subtitle":"","description":"划船要不要用桨呢？这是一个问题","author":"D-Moon","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"babel-polyfill 和 babel-runtime","slug":"babel-polyfill-和-babel-runtime","date":"2022-02-27T10:32:11.000Z","updated":"2022-02-27T10:55:27.726Z","comments":true,"path":"2022/02/27/babel-polyfill-和-babel-runtime/","link":"","permalink":"http://example.com/2022/02/27/babel-polyfill-%E5%92%8C-babel-runtime/","excerpt":"","text":"1.babel基本配置安装 12345678910&quot;devDependencies&quot;: &#123; &quot;@babel/cli&quot; , &quot;@babel/core&quot; , &quot;@babel/plugin-transform-runtime&quot; , &quot;@babel/preset-env&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;@babel/polyfill&quot;, &quot;@babel/runtime&quot; &#125; 预设 和 plugins （按需） 1234567891011121314151617181920212223&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot;, &quot;corejs&quot;: 3 &#125; ] ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;absoluteRuntime&quot;: false, &quot;corejs&quot;: 3, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125; ] ]&#125; 2.babel-polyfill 为了解决浏览器的兼容问题， 在 babel 7.4 以后不用 babel-polyfill，而是采用以下两个polyfill 集合：core-js 和 regenerator(支持 generator 函数) 按需引用 babel-polyfill 1234567891011&quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; // 加入下面这两个之后就行了，不用再在文件中 import &#x27;@babel/polyfill&#x27;. // 编译之后就会自动 require需要的模块 &quot;useBuiltIns&quot;: &quot;usage&quot;, &quot;corejs&quot;: 3 &#125; ] ], 全局污染 比如说 promise，babel-polyfill 的方式是重新再 window 上定义一个 promise 1window.promise = function()&#123;...&#125; 如果说我们在使用的时候（类似开发第三方库这种），自己重写了 window.pormise，那么就会导致冲突 3.babel-runtimebabel-polyfill 的改进，配置 plugins 下 12345678910[ &quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;absoluteRuntime&quot;: false, &quot;corejs&quot;: 3, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125; ] 比如说 promise， babel-runtime 会重新定义为 _promise = xxx，不会污染全局环境","categories":[],"tags":[{"name":"babel babel-polyfill babel-runtime","slug":"babel-babel-polyfill-babel-runtime","permalink":"http://example.com/tags/babel-babel-polyfill-babel-runtime/"}]},{"title":"webpack性能优化","slug":"webpack优化","date":"2022-02-27T06:26:40.000Z","updated":"2022-02-27T14:32:09.755Z","comments":true,"path":"2022/02/27/webpack优化/","link":"","permalink":"http://example.com/2022/02/27/webpack%E4%BC%98%E5%8C%96/","excerpt":"webpack 性能优化","text":"webpack 性能优化 1.优化打包效率开发体验和效率 插件 优化 babel-loader 1234567&#123; test:/\\.js$/, use: [&#x27;babel-loader?cacheDirectory&#x27;], // 开启缓存 include: path.resolve(__dirname, &#x27;src&#x27;) // 明确打包范围 // include 和 exclude 各选一个 exclude: path.resolve(__dirname, &#x27;node_modules&#x27;) // 明确不打包的范围&#125; IgnorePlugin 避免引用无用模块，具体步骤：先忽略 =&gt; 再动态引用 123456789101112// prod.js/plugins下 先忽略new webpack.IgnorePlugin(/*正则匹配要忽略的文件*/, /*对应的插件*/)// 在相应的文件下引入import /*对应插件想要功能的目录*/// eg moment 插件new webpack.IgnorePlugin(/\\./\\locale/, moment) // 忽略所有语言包import moment from &#x27;moment&#x27;import &#x27;moment/locale/zh-cn&#x27; // 手动引入中文语言包 moment.locale(&#x27;zh-cn&#x27;) //把语言包设置成中文 noParse 避免重复打包。webpack noParse作用主要是过滤不需要解析的文件，比如打包的时候依赖了三方库（jquyer、lodash）等，而这些三方库里面没有其他依赖，可以通过配置noParse不去解析文件，提高打包效率 123456module.exports = &#123; module: &#123; // 类似 noParse: [/react\\.min\\.js$/, /jquery/], &#125;&#125; IgnorePlugin 是直接不引人，noParse 是引入但不打包 happyPack 由于 JavaScript 是单线程的，要想发挥多核 CPU 的能力，只能通过多进程去实现，而无法通过多线程实现。happyPack 就可以多进程打包。 步骤：引入=&gt;替换 loader =&gt; 创建插件 123456789101112131415161718192021222324252627const HappyPack = require(&#x27;happypack&#x27;);module.exports = &#123; ... module: &#123; rules: [ test: /\\.js$/, // use: [&#x27;babel-loader?cacheDirectory&#x27;] before use: [&#x27;happypack/loader?id=babel&#x27;], // now exclude: /node_modules/ // 排除 node_modules 目录下的文件 ] &#125;, plugins: [ ..., new HappyPack(&#123; /* * 必须配置 */ // id 标识符，要和 rules 中指定的 id 对应起来 id: &#x27;babel&#x27;, // 需要使用的 loader，用法和 rules 中 Loader 配置一样 // 可以直接是字符串，也可以是对象形式 loaders: [&#x27;babel-loader?cacheDirectory&#x27;] &#125;) ]&#125; ParallelUglifyPlugin 多进程压缩 JS。因为 JS 是单线程的，所以开启多进程压缩才会更快。原理同 happyPack，但是只用放在 prod 环境下。 步骤：引用 =&gt; plugins 配置 12345678910111213141516171819// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 // （还是使用 UglifyJS 压缩，只不过帮助开启了多进程） uglifyJS: &#123; output: &#123; beautify: false, // 最紧凑的输出 comments: false, // 删除所有的注释 &#125;, compress: &#123; // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125; &#125;) 自动刷新 一般来说用不上，开发环境下可能会用。devServer 配置一般会自动带上自动刷新 1234567891011module.export = &#123; watch: true, //默认为 false 开启监听后 webpack-dev-server 会自动开启刷新浏览器 watchOptions: &#123; ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 aggregateTimeout: 300, // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的 poll: 1000 &#125;&#125; 热更新 自动刷新的缺点：整个网页全部刷新，速度较慢；整个网页刷新后状态丢失 热更新：新代码生效，网页不刷新，状态不丢失 步骤：安装 =&gt; 配置 =&gt; 按需引用 1234567891011121314151617181920212223242526272829npm i webpack webpack-cli -Dnpm i webpack-dev-server -Dnpm i html-webpack-plugin -D//配置 config 文件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; ... devServer: &#123; hot: true, // 开启热更新 port: 8080, // 指定服务器端口号 &#125;, plugins: [ new HotModuleReplacementPlugin(), ]&#125;//在对应模块中引入// 增加，开启热更新之后的代码逻辑 if (module.hot) &#123; //xxx 模块需要热更新 module.hot.accept([&#x27;./xxx&#x27;], () =&gt; &#123; /* do something */ &#125;) &#125; DllPlugin https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-2%E4%BD%BF%E7%94%A8DllPlugin.html webpack 内置已经支持 DllPlugin: 打包出 dll 文件 DLLReferencePlugin: 使用 dll 文件 环境区分1.可用于生产环境的 优化 babel-loader（明确缓存，要什么不要什么的范围） IgnorePlugin （最好用，不然打包出来代码比较大） noParse （提高生产环境打包速度） happyPack 和 ParallelUglifyPlugin （多进程打包提高效率） 2.不适用于生产环境 自动刷新（只是为了提高开发体验） 热更新 （万万不能用于生产环境） DLLPlugin (生产环境下打包一次就结束了，不需要使用。只是满足开发环境下的一个速度) 2.优化产出代码（重要）为了线上提高产品性能：让代码体积更小，合理分包不重复加载，速度更快内存使用更小 小图片 64 编码 在 url-loader 的 options 配置。低于多少大小的图片就用 base64 格式产出，不要再进行一次网络请求，很浪费资源 bundle加 hash 在打包出来的 bundle 里面要加上 contentHash。如果说我们的 hash 值没有改变，说明js css 这些文件没有改变，那么上线请求的时候前端代码就会命中缓存，没必要重新加载一遍，可以提高我们的效率 eg： 1234567module.exports = &#123; ... output:&#123; filename: &#x27;[name].[contentHash:8].js&#x27; &#125; ...&#125; 懒加载 异步 import 提取公共代码 IgnorePlugin 使用 CDN 加速 步骤：在 output 中配置 CDN 前缀 =&gt; 把打包结果(JS CSS Img 等)上传到 CDN 中 使用 production 1.dev 模式下没有必要压缩代码，只要设置 mode: “ production”，就会自动压缩（webpack 4 之后） 2.开发环境下，Vue React 会自动删掉调试代码，比如说开发环境下的 warning 3.自动启动 Tree-Shaking ​ 前提：必须使用 ES6 Module 才能让 tree-shaking 生效，不能用 commonjs ​ 作用：把没用上的代码（export 出去的）删去 ​ 为什么只能在ES6 module 条件下：因为 ES6 Module 是静态引入的，编译时就已经引入了，所以有条件分析我们引入 了什么，什么要用什么不用。但是 commonJS 是动态引入的，在编译时我们不知道到底要不要引入这个模块 ​ eg 1234567891011if(dev)&#123; // require 动态引入 可行 apiList = require(&#x27;../config/api/apiList.js&#x27;)&#125;if(dev)&#123; // import 静态引入，编译时报错 import apiList from &quot;../config/api/apiList.js&quot;&#125; Scope Hosting 一个函数有一个作用域，一般来说，webpack 会把一个文件编成一个函数，加上 SH 之后就可以把这些文件编到一个函数中。 配置： 123456789const ModuleConcatenationPlugin = require (&#x27;webpack/lib/optimize/ModuleConcatenationPlugin&#x27;)module.exports = &#123; resolve:&#123; mainFields: [&#x27;jsnext:main&#x27;, &#x27;browser&#x27;, &#x27;main&#x27;] //优先使用jsnext:main指向 ES6模块化文件 &#125; plugins: [ new ModuleConcatenationPlugin(); ]&#125; 3.一些常见问题前端为什么要进行打包和构建？两个方面，代码层面和开发层面。对代码进行打包和构建可以：有更小的代码体积，让代码加载更快，比如说 tree-shaking 代码压缩 代码合并等的使用； 可以支持我们使用高级语言和特性，我们在使用的时候不必考虑其它问题，比如说 TS ES6 模块化 scss 这些；可以提高我们代码的兼容性，比如说 polyfill。 在开发层面：打包和构建可以让我们有一个统一的开发环境和标准（比如说都输出成 ES5 或者 ES6），提高整个部门的效率，还可以集成公司构建规范。 loader 和 plugin 的区别？loader 模块转化器，比如把 less 变成 css plugin 扩展插件，loader 结束之后工作，丰富 webpack 的功能。比如说 loader 只能在最开始的时候工作，但是 plugin 就可以在 webpack 整个编译阶段按需求工作。 常见的 loader 和 pluginbabel 和 webpack 的区别babel 只是个编译工具，只关注语法，不关心模块化，只看语法有没有错误；webpack 是打包构建工具，是多个 loader 和 plugin 的集合。 如何产生一个 libeg 12345678output &#123; //lib 的文件名 filename: &quot;&quot;, // 输出目录 path: , // lib 的全局变量名 library: &quot;&quot;&#125; babel-polyfill 和 babel-runtime 的去呗webpack 实现懒加载import() 语法 + Vue React 异步组件 +Vue-router React-router 异步加载路由 为什么 proxy 不能用 polyfill？webpack有什么常见优化手段？","categories":[],"tags":[{"name":"webpack 性能优化","slug":"webpack-性能优化","permalink":"http://example.com/tags/webpack-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"webpack基本使用与配置","slug":"webpack基本使用与配置","date":"2022-02-26T07:29:39.000Z","updated":"2022-02-27T14:31:49.320Z","comments":true,"path":"2022/02/26/webpack基本使用与配置/","link":"","permalink":"http://example.com/2022/02/26/webpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"webpack 的基本使用与配置","text":"webpack 的基本使用与配置 基本配置1.拆分配置 和 merge一般来说配置文件有： 1234webpack.common.js //公共配置webpack.dev.js // 开发配置webpack.prod.js //线上配置paths // 配置路径 2.启动本地服务(dev.js)插件：webpack-dev-server 设置代理：proxy 123456789101112// 配置前端的代理，比如说当前前端项目的端口是 8080 所以我们在请求接口的时候， // 可以设置成 http://localhost:8080/api/users 这种类型.简写成 /api/users 也可以 // 因为代理设置的标价是 /api 所以前端遇到包含api的请求以后， 就定向到 http://localhost:3000 来 // 也就是最终到 http://localhost:3000/api/users 去请求资源 // 如果后端的地址不是这样的，可能是 http://localhost:3000/users 或者 http://localhost:3000/info/users这种和前端有出入的地址 // 那么可以添加 pathRewrite 属性，pathRwrite:&#123;&quot;^/api&quot;: &quot;替换的值，空或者其它对应字符串&quot;&#125; proxy:&#123; &quot;/api&quot;:&#123; target:&quot;http://localhost:3000&quot; &#125; &#125; &#125;, 3.处理ES6(common.js)插件 babel-loader 123456rules: &#123; test: /\\.js$/, loader: [&#x27;babel-loader&#x27;], include: srcPath, exclude: /node_modules/ &#125;, 预设：.babelrc 1234&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: []&#125; 4.处理样式PS注意处理顺序 12345678910rules:&#123; test: /\\.css$/, // loader 的执行顺序是：从后往前 postcss-loader做浏览器兼容 loader: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;] // 加了 postcss &#125;, &#123; test: /\\.less$/, // 增加 &#x27;less-loader&#x27; ，注意顺序 loader: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;] &#125; 对于 postcss-loader 需要 autoprefixer，处理css 的一些新特性，比如说 transform 之类的 根目录下新建postcss.config.js 123module.exports = &#123; plugins: [require(&#x27;autoprefixer&#x27;)]&#125; 5.处理图片开发 1234567rules: [ // 直接引入图片 url &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &#x27;file-loader&#x27; &#125; ] 上线 1234567891011121314151617181920rules: [ // 图片 - 考虑 base64 编码的情况 &#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; // 小于 5kb 的图片用 base64 格式产出 // 否则，依然延用 file-loader 的形式，产出 url 格式 limit: 5 * 1024, // 打包到 img 目录下 outputPath: &#x27;/img1/&#x27;, // 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源） // publicPath: &#x27;http://cdn.abc.com&#x27; &#125; &#125; &#125;, ] 6.模块化webpack本身就是模块化的，但是像 import 语法等浏览器是不支持识别的，所以我们在使用的时候还需要引入 webpack 本身。 7.一些插件new CleanWebpackPlugin():再次打包时把之前打包的文件自动删除，然后打包新的代码； 高级配置1.多入口步骤：entry =&gt; output =&gt; plugins 123456789101112131415161718192021222324252627 //input 在entry中配置entry: &#123; index: path.join(srcPath, &#x27;index.js&#x27;), other: path.join(srcPath, &#x27;other.js&#x27;) &#125;, //ouputoutput: &#123; // filename: &#x27;bundle.[contentHash:8].js&#x27;, // 打包代码时，加上 hash 戳 filename: &#x27;[name].[contentHash:8].js&#x27;, // name 即多入口时 entry 的 key path: distPath, // publicPath: &#x27;http://cdn.abc.com&#x27; // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到 &#125;, //plugins 每个入口文件都要配置自己的 new HtmlWebpackPlugin 生成 html // 多入口 - 生成 index.html new HtmlWebpackPlugin(&#123; template: path.join(srcPath, &#x27;index.html&#x27;), filename: &#x27;index.html&#x27;, // chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用 chunks: [&#x27;index&#x27;] // 只引用 index.js,记得要写这一项，确保只引用特定的文件 &#125;), // 多入口 - 生成 other.html new HtmlWebpackPlugin(&#123; template: path.join(srcPath, &#x27;other.html&#x27;), filename: &#x27;other.html&#x27;, chunks: [&#x27;other&#x27;] // 只引用 other.js &#125;) 2.抽离CSS文件步骤：区分不同环境配置 =&gt; 替代 style-loader =&gt; 压缩 css dev环境下配置不变，prod 配置环境下，需要用 MiniCssExtractPlugin.loader 替代 style-loader; 1234567891011121314151617&#123; test: /\\.css$/, loader: [ MiniCssExtractPlugin.loader, // 注意，这里不再用 style-loader &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;, &#123; test: /\\.less$/, loader: [ MiniCssExtractPlugin.loader, // 注意，这里不再用 style-loader &#x27;css-loader&#x27;, &#x27;less-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125; 对于插件 MiniCssExtractPlugin的配置 123 new MiniCssExtractPlugin(&#123; filename: &#x27;css/main.[contentHash:8].css&#x27; // 输出的路径，[name].[hash].css&#125;) 压缩 css 123optimization: &#123; minimizer: [new TerserJSPlugin(&#123;&#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;)],&#125; 3.抽离公共代码一些公共引用文件，第三方模块等，希望在更改代码的时候可以让它们命中缓存加载而不是重新再来一遍。 common 和 dev 都没什么改变，还是在 prod 下面更改 12345678910111213141516171819202122232425262728splitChunks: &#123; cunks: &#x27;all&#x27;, /* initial 入口 chunk，对于异步导入的文件不处理 async 异步 chunk，只对异步导入的文件处理 all 全部 chunk */ 缓存分组 cheGroups: &#123; // 第三方模块 vendor: &#123; name: &#x27;vendor&#x27;, // chunk 名称 priority: 1, // 权限更高，优先抽离，重要！！！ test: /node_modules/, minSize: 0, // 大小限制，按照自己需要的写 minChunks: 1 // 最少复用过几次，比如说 lodash 这种第三方模块，只要引用过一次就要拆分出来 &#125;, // 公共的模块 common: &#123; name: &#x27;common&#x27;, // chunk 名称 priority: 0, // 优先级 minSize: 0, // 公共模块的大小限制 minChunks: 2 // 公共模块最少复用过几次 &#125; &#125; &#125; 代码分割以后，我们就可以给不同的文件在 new HtmlWebpackPlugin 时的 chunks 项按需引用分割后的模块。格式： chunks;[ ..., &#39;common&#39;, &#39;vendor&#39; ] 4.实现异步懒加载在 import 的时候异步引入，不需要 webpack 额外配置，内在支持 123456// 加载动态数据setTimeout(()=&gt;&#123; import(&#x27;./dynamic-data.js&#x27;).then(res=&gt;&#123; console.log(res.default.message) // 因为动态数据导出时是 default 所以这里也要加 default &#125;)&#125;) 5.处理 vue 和 jsxjsx 用 babel 就可以，在 .babelrc 中添加支持 react 的预设 123&#123; &quot;preset&quot;:[&quot;@babel/preset-react&quot;]&#125; vue 用 vue-loader 即可 module chunk bundle 的区别（重要）module =&gt; 各个源码文件，webpack 中一切皆模块 chunk =&gt; 多模块合成的，如 entry import() splitChunk bundle =&gt; 最终的输出文件 构建流程概述Babel一些问题 前端代码为什么要进行构建和打包 module chunk bundle 分别有什么意思？有何区别？ loader 和 plugin 的区别 webpack 怎么实现懒加载 webpack常见性能优化 babel-runtime 和 babel-polyfill 的区别","categories":[],"tags":[{"name":"webpack 前端打包","slug":"webpack-前端打包","permalink":"http://example.com/tags/webpack-%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85/"}]},{"title":"Redux-Toolkit概览","slug":"Redux-Toolkit","date":"2022-02-08T13:28:09.000Z","updated":"2022-02-27T17:07:38.770Z","comments":true,"path":"2022/02/08/Redux-Toolkit/","link":"","permalink":"http://example.com/2022/02/08/Redux-Toolkit/","excerpt":"RTK 学习笔记","text":"RTK 学习笔记 1.什么是 RTK一个简化 react-redux 操作的工具。可以让我们简化配置，少装package，少写模板代码。 安装 12345678910# Redux + Plain JS templatenpx create-react-app my-app --template redux# Redux + TypeScript templatenpx create-react-app my-app --template redux-typescript# npmnpm install @reduxjs/toolkit# Yarnyarn add @reduxjs/toolkit 2.分析RTK源码中的 dependencies 包括 12345// 没有安装 react-redux 说明这并不仅仅是给 react 用的，也可以给 vue 用immer //允许用户直接修改 statereduxredux-thunk // 默认开启，用来处理异步逻辑reselect // 3.apicreateReducer一般配置： 1234567891011121314const initialState = &#123; value: 0 &#125;function counterReducer(state = initialState, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123; ...state, value: state.value + 1 &#125; case &#x27;decrement&#x27;: return &#123; ...state, value: state.value - 1 &#125; case &#x27;incrementByAmount&#x27;: return &#123; ...state, value: state.value + action.payload &#125; default: return state &#125;&#125; createReducer配置:有两种办法，Map Object 和 Builder Callback,在这里介绍前一种方法 12345678910111213141516//1.直接写const counterReducer = createReducer(0, &#123; increment: (state, action) =&gt; state + action.payload, decrement: (state, action) =&gt; state - action.payload,&#125;)console.log(counterReducer.getInitialState()) // 0//2. 配合 createAction一起写const increment = createAction(&#x27;increment&#x27;)const decrement = createAction(&#x27;decrement&#x27;)const counterReducer = createReducer(0, &#123; [increment]: (state, action) =&gt; state + action.payload, [decrement.type]: (state, action) =&gt; state - action.payload&#125;) createSlice（核心）一般来说，我们不会特别去单独使用 createReducer 和 createAction一个函数，用 createSlice 比较多。它接受initial state，reducer函数对象，slice name，自动生成对应 reducers 和 state的 action creators 和 action types 1234567891011121314151617181920212223242526import &#123; createSlice, PayloadAction &#125; from &#x27;@reduxjs/toolkit&#x27;interface CounterState &#123; value: number&#125;const initialState = &#123; value: 0 &#125; as CounterStateconst counterSlice = createSlice(&#123; name: &#x27;counter&#x27;, // slice 名称，相当于分割 store 之后的命名空间 initialState, // 数据的初始化 reducers: &#123; // 一个特殊的 reducer 把 action 和 state 结合在一起了 increment(state) &#123; state.value++ // state 直接修改 RTK自动加载 immer，immer在最底层重建 state ，所以帮助我们修改了 &#125;, decrement(state) &#123; state.value-- &#125;, incrementByAmount(state, action: PayloadAction&lt;number&gt;) &#123; state.value += action.payload &#125;, &#125;,&#125;)export const &#123; increment, decrement, incrementByAmount &#125; = counterSlice.actionsexport default counterSlice.reducer example 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import &#123; createSlice, createAction, PayloadAction &#125; from &#x27;@reduxjs/toolkit&#x27;import &#123; createStore, combineReducers &#125; from &#x27;redux&#x27;const incrementBy = createAction&lt;number&gt;(&#x27;incrementBy&#x27;)const decrementBy = createAction&lt;number&gt;(&#x27;decrementBy&#x27;)const counter = createSlice(&#123; name: &#x27;counter&#x27;, initialState: 0 as number, reducers: &#123; increment: (state) =&gt; state + 1, decrement: (state) =&gt; state - 1, multiply: &#123; reducer: (state, action: PayloadAction&lt;number&gt;) =&gt; state * action.payload, prepare: (value?: number) =&gt; (&#123; payload: value || 2 &#125;), // fallback if the payload is a falsy value &#125;, &#125;, // 解决环形引用 extraReducers: (builder) =&gt; &#123; builder.addCase(incrementBy, (state, action) =&gt; &#123; return state + action.payload &#125;) builder.addCase(decrementBy, (state, action) =&gt; &#123; return state - action.payload &#125;) &#125;,&#125;)const user = createSlice(&#123; name: &#x27;user&#x27;, initialState: &#123; name: &#x27;&#x27;, age: 20 &#125;, reducers: &#123; setUserName: (state, action) =&gt; &#123; state.name = action.payload // mutate the state all you want with immer &#125;, &#125;, // &quot;map object API&quot; extraReducers: &#123; // @ts-expect-error in TypeScript, this would need to be [counter.actions.increment.type] [counter.actions.increment]: ( state, action /* action will be inferred as &quot;any&quot;, as the map notation does not contain type information */ ) =&gt; &#123; state.age += 1 &#125;, &#125;,&#125;)// 使用 combineReducers 把两个 slice 里面的 reducer 合并起来const reducer = combineReducers(&#123; counter: counter.reducer, user: user.reducer,&#125;)// 创建 storeconst store = createStore(reducer)// 然后就可以直接用 store 对象来调用，优点在于把 action 和各种 switch 语句消除了，代码简洁up，还解决了 string类型action出错的可能性store.dispatch(counter.actions.increment())// -&gt; &#123; counter: 1, user: &#123;name : &#x27;&#x27;, age: 21&#125; &#125;store.dispatch(counter.actions.increment())// -&gt; &#123; counter: 2, user: &#123;name: &#x27;&#x27;, age: 22&#125; &#125;store.dispatch(counter.actions.multiply(3))// -&gt; &#123; counter: 6, user: &#123;name: &#x27;&#x27;, age: 22&#125; &#125;store.dispatch(counter.actions.multiply())// -&gt; &#123; counter: 12, user: &#123;name: &#x27;&#x27;, age: 22&#125; &#125;console.log(`$&#123;counter.actions.decrement&#125;`)// -&gt; &quot;counter/decrement&quot; RTK自动生成的 命名空间/对应 reducerstore.dispatch(user.actions.setUserName(&#x27;eric&#x27;))// -&gt; &#123; counter: 12, user: &#123; name: &#x27;eric&#x27;, age: 22&#125; &#125; configureStore用 configureStore 来代替 redux 中原生的 createStore 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type ConfigureEnhancersCallback = ( defaultEnhancers: StoreEnhancer[]) =&gt; StoreEnhancer[]interface ConfigureStoreOptions&lt; S = any, A extends Action = AnyAction, M extends Middlewares&lt;S&gt; = Middlewares&lt;S&gt;&gt; &#123; /** * A single reducer function that will be used as the root reducer, or an * object of slice reducers that will be passed to `combineReducers()`. */ reducer: Reducer&lt;S, A&gt; | ReducersMapObject&lt;S, A&gt; /** * An array of Redux middleware to install. If not supplied, defaults to * the set of middleware returned by `getDefaultMiddleware()`. */ middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware&lt;S&gt;) =&gt; M) | M /** * Whether to enable Redux DevTools integration. Defaults to `true`. * * Additional configuration can be done by passing Redux DevTools options */ devTools?: boolean | DevToolsOptions /** * The initial state, same as Redux&#x27;s createStore. * You may optionally specify it to hydrate the state * from the server in universal apps, or to restore a previously serialized * user session. If you use `combineReducers()` to produce the root reducer * function (either directly or indirectly by passing an object as `reducer`), * this must be an object with the same shape as the reducer map keys. */ preloadedState?: DeepPartial&lt;S extends any ? S : S&gt; /** * The store enhancers to apply. See Redux&#x27;s `createStore()`. * All enhancers will be included before the DevTools Extension enhancer. * If you need to customize the order of enhancers, supply a callback * function that will receive the original array (ie, `[applyMiddleware]`), * and should return a new array (such as `[applyMiddleware, offline]`). * If you only need to add middleware, you can use the `middleware` parameter instead. */ enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback&#125;function configureStore&lt;S = any, A extends Action = AnyAction&gt;( options: ConfigureStoreOptions&lt;S, A&gt;): EnhancedStore&lt;S, A&gt; 简单使用 123456import &#123; configureStore &#125; from &#x27;@reduxjs/toolkit&#x27;import rootReducer from &#x27;./reducers&#x27;const store = configureStore(&#123; reducer: rootReducer &#125;)// The store now has redux-thunk added and the Redux DevTools Extension is turned on configureStore 见第四点 createAsyncThunk见第四点 4.RTK 异步处理数据configureStore123456import &#123; configureStore &#125; from &#x27;@reduxjs/toolkit&#x27;import rootReducer from &#x27;./reducers&#x27; // rootReducer是一系列 reducers 的集合，从 slice中导入const store = configureStore(&#123; reducer: rootReducer &#125;)// The store now has redux-thunk added and the Redux DevTools Extension is turned on createAsyncThunk接受 action type，返回一个标准的redux thunk action creator 以及promise和三个 action： For example, a type argument of &#39;users/requestStatus&#39; will generate these action types: pending: &#39;users/requestStatus/pending&#39; fulfilled: &#39;users/requestStatus/fulfilled&#39; rejected: &#39;users/requestStatus/rejected&#39; 使用的时候要确保 store 使用的封装函数是 configureStore 而不是 createStore object map 创建 reducer 的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#123; createSlice, PayloadAction, createAsyncThunk &#125; from &quot;@reduxjs/toolkit&quot;;import axios from &quot;axios&quot;;interface ProductDetailState &#123; loading: boolean; error: string | null; data: any;&#125;const initialState: ProductDetailState = &#123; loading: true, error: null, data: null,&#125;;export const getProductDetail = createAsyncThunk( &quot;productDetail/getProductDetail&quot;, //命名空间/文件名 async (touristRouteId: string, thunkAPI) =&gt; &#123; const &#123; data &#125; = await axios.get( /*请求的 api 地址*/ ); return data; &#125;);export const productDetailSlice = createSlice(&#123; name: &quot;productDetail&quot;, initialState, reducers: &#123; &#125;, extraReducers: &#123; [getProductDetail.pending.type]: (state) =&gt; &#123; // return &#123; ...state, loading: true &#125;; state.loading = true; &#125;, [getProductDetail.fulfilled.type]: (state, action) =&gt; &#123; state.data = action.payload; state.loading = false; state.error = null; &#125;, [getProductDetail.rejected.type]: (state, action: PayloadAction&lt;string | null&gt;) =&gt; &#123; // const ddd = action.payload; state.loading = false; state.error = action.payload; &#125;, &#125;&#125;);","categories":[],"tags":[{"name":"Redux-Toolkit","slug":"Redux-Toolkit","permalink":"http://example.com/tags/Redux-Toolkit/"}]},{"title":"RESTful概览","slug":"RESTful概览","date":"2022-02-07T14:15:41.000Z","updated":"2022-02-27T14:31:01.527Z","comments":true,"path":"2022/02/07/RESTful概览/","link":"","permalink":"http://example.com/2022/02/07/RESTful%E6%A6%82%E8%A7%88/","excerpt":"Representational state transfer 表征性状态转移","text":"Representational state transfer 表征性状态转移 基本特点 无状态 一次调用就返回结果，不需要依赖上次连接 面向 “资源” 链接里只有动词没有名词，api/v1/touristRoutes 可以，api/v1/GetTouristRoutes 有动词不行 使用 HTTP 动词表示操作 动词 含义 例子 GET 查看 HTTP GET api/v1/touristRoutes POST 创建 HTTP POST api/v1/touristRoutes PUT 更新 HTTP PUT api/v1/touristRoutes/{id} PATCH 部分更新 HTTP PATCH api/v1/touristRoutes/{id} DELETE 删除 HTTP DELETE api/v1/touristRoutes/{id} HATOAS 超媒体即应用状态引擎 适用面向对象（资源），增删改查这些比较好用 面向过程就不大好，比如说登录这种操作，路径包含 login 就不行了，也无法确定要用 get post 等哪个操作","categories":[],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"http://example.com/tags/RESTful/"}]},{"title":"tsconfig.js配置文档","slug":"tsconfig-js配置文档","date":"2022-02-04T07:52:36.000Z","updated":"2022-02-27T17:08:56.216Z","comments":true,"path":"2022/02/04/tsconfig-js配置文档/","link":"","permalink":"http://example.com/2022/02/04/tsconfig-js%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/","excerpt":"tsconfig 配置，转载","text":"tsconfig 配置，转载 一般来说，项目的TS编译器配置全部存储在项目根目录下的tsconfig.json文件中。 编译器启动时，首先会读取tsconfig.json，以获取有关如何编译项目的说明（例如，要编译哪些源文件，在哪里存储输出等）。 不过，如果编译器配置文档保存在其他特殊位置，我们也可以通过使用-p选项告诉编译器配置文档的具体位置： 1. “target”: “es5”这个属性定义了你编译后的目标javascript版本，一般来说，我们需要让他编译为es5，这样就可以被主流浏览器解读了。当然，你说我的react代码不是给浏览器看的，比如说，你使用的是react-native做作手机app，那么这里的选项可以选择es6。除了es5和es6，我们还有很多其他常见的选项，ES5, ES6/ES2015, ES2016, ES2017, ES2018, ES2019, ES2020, ESNext，等等等等 2. “lib”: [“dom”, “dom.iterable”, “esnext”]这个属性列出了编译期间需要被包括进来的库文件，通过这些库文件，告诉typescript编译器可以使用哪些功能。比如说，我们这里有一个dom的库文件，这个文件会告诉编译器dom api的接口，所以当我们在ts代码中使用dom的时候，比如说执行“document.getElementById(&quot;root&quot;)”这句话的时候，编译器就会知道该如何进行检查。如果我们不设置这个选项，那么编译器也有自己默认的库文件列表，一般来说是[&quot;dom&quot;, &quot;es6&quot;,&quot;DOM.Iterable&quot;]等等 3. “allowJs”: true允许混合编译JavaScript文件 4. “esModuleInterop”: true这个选项允许我们使用commonjs的方式import默认文件。比如说，在没有开启这个选项时，我们需要这样写才能引用react: 123import * as React from &#x27;react&#x27; 但是当我们开启了这个选项以后，import方式就与普通的JavaScript没有区别了，可以写为: 123import React from &#x27;react&#x27; 这样处理项目引入会更自然。 5. “module”: “esnext”这里配置的是我们代码的模块系统，比较常见的有Node.js的CommonJS系统，ES6标准的esnext系统，以及requirejs的AMD系统。我们这里使用的是ES6标准的esnext系统，不过如果把这里换成CommonJS也是可以的。 6. “moduleResolution”: “node”这个选项决定了我们编译器的工作方式，也决定了我们各个文件之间调用、import的工作流程。这里曾经有两个选项，&quot;node&quot; and &quot;classic&quot;，但是&quot;classic&quot;这个选项在2019年12月就已经废弃了。 7. “isolatedModules”: “node”开启这个选项以后，编译器会将每个文件作为单独的模块来使用。 8。 “noEmit”: true,开启这个选项表示当发生错误的时候，编译器不会生成 JavaScript 代码。 9. “jsx”: “react”,显而易见，这个选项允许编译器支持编译react代码 10. “include”: [“src/**/*”]使用此选项列出我们需要编译的文件， “文件路径”选项需要文件的相对或绝对路径，例如： &quot;**&quot; - 任意子目录 &quot;*&quot; - 任意文件名 &quot;?&quot; - 只要字符跟随“?”，这个字符就会被视为可忽略字符 (e.g., &quot;src/*.tsx?&quot;则同时指代&quot;src/*.tsx&quot;与&quot;src/*.ts&quot;) 11. “files”: [“./file1.ts”, “./file2.d.ts”, …]使用此选项列出编译器应始终包含在编译中的文件。无论是否使用“exclude”选项，都将会编译使用此选项内包括的所有文件。 12. “exclude”: [“node_modules”, “**//.test.ts”]此选项将会列出从编译中排除的文件。它与“include”选项采取相同的模式，我们以使用此选项来过滤使用“include”选项指定的文件。 但是, “exclude”选项不会影响“files”选项。 通常，我们会排除node_modules、测试文件、和编译输出目录。 如果省略此选项，编译器将使用“outDir”选项指定的文件夹。 如果没有同时指定“files”和“include”这两个选项，则编译器将编译根目录和任何子目录中的所有TS文件，但不包括使用“exclude”选项指定的文件。","categories":[],"tags":[{"name":"tsconfig.json编译器配置文档","slug":"tsconfig-json编译器配置文档","permalink":"http://example.com/tags/tsconfig-json%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"}]},{"title":"React-Hooks","slug":"React-Hooks","date":"2022-02-03T06:56:12.000Z","updated":"2022-02-27T14:29:50.181Z","comments":true,"path":"2022/02/03/React-Hooks/","link":"","permalink":"http://example.com/2022/02/03/React-Hooks/","excerpt":"一些常见hook和注意事项","text":"一些常见hook和注意事项 0.Hooks 消息处理的一种方法，用来监视指定程序 函数组件中需要处理副作用，可以用钩子把外部代码“钩”进来 常用钩子： useState useEffect useContext useReducer hooks 一律使用 useXxx 格式 1.State Hook函数组件：引入 react；纯函数；返回 JSX； 让函数组件实现 state 和 setState 默认函数组件没有 state 函数组件是一个纯函数，执行完成即销毁，无法存储 state hook 相当于一个钩子，把 state 钩到纯函数中 useState useState(0) 传入初始值，返回数组 [state, setState] 通过 state 获取值 通过 setState(1) 修改值 代码 12345678910111213// State Hook 点击加一import React ,&#123;useState&#125; from &quot;react&quot;;function ClickCounter()&#123; const [count, setCount] = useState(0) // count: 0, 修改 count 的方法是 setCount // const [name, setName] = useState(&#x27;Dmoon&#x27;) return &lt;div&gt; &lt;p&gt; 共点击&#123;count&#125;次&lt;/p&gt; &#123;/* setCount(count + 1) 表示对 count 的修改操作 */&#125; &lt;button onClick=&#123;()=&gt; setCount(count + 1)&#125;&gt;点击&lt;/button&gt; &lt;/div&gt;&#125;export default ClickCounter 1234567891011121314151617181920212223// class 组件点击加一import React from &quot;react&quot;;class ClickCounterClass extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; count: 0 &#125; &#125; render()&#123; return &lt;div&gt; &lt;p&gt;共点击了&#123;this.state.count&#125; 次&lt;/p&gt; &lt;button onClick=&#123;this.ClickHandler&#125;&gt;点击&lt;/button&gt; &lt;/div&gt; &#125; ClickHandler = () =&gt;&#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;export default ClickCounterClass 注意所有的 Hooks 都用 use 开头，包括自定义 Hooks，其它地方不要使用 useXxxx 的写法 2.Effect Hook前置知识 side effect：纯函数中函数的输入确定那么输出也确定，side effect 和纯函数相反，指一个函数处理了与返回值无关的事情 2.1 生命周期12345678910111213141516171819202122232425262728293031323334353637383940import React ,&#123;useState, useEffect&#125; from &quot;react&quot;;function LifeCycles()&#123; const [count, setCount] = useState(0) const [name, setName] = useState(&#x27;Dmoon&#x27;) //1.模拟 Class 里的 DidMount 和 DidUpdate，很容易不停发送请求，陷入死循环 useEffect(()=&gt;&#123; console.log(&#x27;send ajax request&#x27;); &#125;) // 2.多一个参数 [] 模拟 Class 里的 DidMount useEffect(()=&gt;&#123; console.log(&#x27;send ajax request done&#x27;); &#125;,[]) //3. 数组里加对象模拟 Class 里的 DidUpdate [count,name] 表示 count 和 name 更新了都能触发这个生命周期 useEffect(()=&gt;&#123; console.log(&#x27;updated&#x27;); &#125;,[count,name]) // 4. willUnMount useEffect(()=&gt;&#123; let timerId = setInterval(()=&gt;&#123; console.log(Date.now()); &#125;,2000) // 组件销毁时 模拟 WillUnMount 返回一个函数 return ()=&gt;&#123; clearInterval(timerId) &#125; &#125;) function ClickHandler()&#123; setCount(count + 1) setName(name + &#x27;2022&#x27;) &#125; return &lt;div&gt; &lt;p&gt; LifeCycles 共点击&#123;count&#125;次&lt;/p&gt; &lt;button onClick=&#123;ClickHandler&#125;&gt;点击&lt;/button&gt; &lt;/div&gt;&#125;export default LifeCycles 12345678910111213// willUnMount周期 父组件的补充// ...function App() &#123; const [flag, setFlag] = useState(true) return ( &lt;div &gt; &#123;flag &amp;&amp; &lt;LifeCycles/&gt;&#125; &#123;/* 注意不能写成 onClick=&#123;setFlag(false)&#125;，必须在匿名函数里面写*/&#125; &lt;button onClick=&#123;()=&gt;setFlag(false)&#125;&gt;停止打印时间戳&lt;/button&gt; &lt;button onClick=&#123;()=&gt;setFlag(true)&#125;&gt; 开始打印时间戳&lt;/button&gt; &lt;/div&gt; );&#125; 让函数组件模拟生命周期，也就是用 Effect Hook 把生命周期钩到函数组件中 模拟 componentDidMount - useEffect 依赖 [ ] 模拟 componentDidUpdate - useEffect 依赖 [ ] 或者 [a,b] 模拟 componentWillUnMount - useEffect 返回一个函数 2.2 Effect Hook 模仿componentWillUnMount 的注意点：12345678910111213141516171819202122232425262728// class 组件实现状态监听class FriendStatusClass extends React.Component&#123; constructor(props) &#123; super(props) this.state = &#123; status: false, // 默认当前不在线 count: 0 &#125; &#125; render()&#123; return &lt;div&gt; 好友 &#123;this.props.friendId&#125; 在线状态:&#123;this.state.status.toString()&#125; &lt;/div&gt; &#125; // 每一个生命周期都需要定义 componentDidMount()&#123; console.log(`开始监听 $&#123;this.props.studentId&#125; 的在线状态 `); &#125; // 注意更新时前后状态都要注意 componentDidUpdate(prevProps)&#123; console.log(`结束监听 $&#123;prevProps.studentId&#125; 的在线状态`); console.log(`开始监听 $&#123;this.props.studentId&#125; 的在线状态`); &#125; componentWillUnmount()&#123; console.log(`结束监听 $&#123;this.props.studentId&#125; 的在线状态`); &#125;&#125; 123456789101112131415161718192021// 函数组件 + hooks 实现状态监听，代码大大减少function StudentsStatus(props)&#123; const [status, setStatus] = useState(false) useEffect(()=&gt;&#123; // 没有依赖参数，所以既可以监听 didUpdate 也可以监听 didMount console.log(`开始监听学生 $&#123;props.studentId&#125;的在线状态`); // 【特别注意】 // 此处并不完全等同于 WillUnMount // props 发生变化，即更新，也会执行结束监听 // 准确的说：返回的函数，会在下一次 effect 执行之前，被执行 return (()=&gt;&#123; console.log(`结束监听 $&#123;props.studentId&#125;的在线状态`); &#125;) &#125;) return &lt;div&gt; 学生&#123;props.studentId&#125; 的在线状态: &#123;status.toString()&#125; &lt;button onClick=&#123;()=&gt; setStatus(!status )&#125;&gt;切换在线状态&lt;/button&gt; &lt;/div&gt;&#125; 2.3 useEffect 使用 async/await123456789101112131415// 比如说从某个 api 获取 data, async 不能直接写在 useEffect 中，而是要另起函数，不然会报错useEffect(()=&gt;&#123; /** * 用原生JavaScript 的 fetch 通过 get 请求拿到数据 * fetch 直接返回的不是数据，而是 promise 所以还需要 then， * response 里面有 header status 等 我们拿到 response.json() 也就是主体数据， 返回的是 promise * 还需要 then 一下 拿到 data */ const fetchData = async()=&gt;&#123; const response = await fetch(&quot;https://jsonplaceholder.typicode.com/users&quot;) const data = await response.json() setRobotsGallery(data) &#125; fetchData() &#125;,[]) 2.4 处理异常 try-catch12345678910111213141516useEffect(()=&gt;&#123; const fetchData = async()=&gt;&#123; // 获得数据以前 loading 为 true setLoading(true) try &#123; const response = await fetch(&quot;https://jsonplaceholder.typicode.com/users&quot;) const data = await response.json() setRobotsGallery(data) &#125;catch(e)&#123; setError(e.message) &#125; // 获取数据以后 loading 为 false setLoading(false) &#125; fetchData()&#125;,[]) 3.其它 Hook3.1 useRef获得 DOM 节点 1234567891011import React ,&#123;useEffect, useRef&#125; from &quot;react&quot;function UseRefDemo()&#123; const btnRef = useRef(null) useEffect(()=&gt;&#123; console.log(btnRef.current); // &lt;button&gt;按钮&lt;/button&gt; &#125;) return &lt;div&gt; &lt;button ref=&#123;btnRef&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt;&#125;export default UseRefDemo 3.2 useContext123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useContext &#125; from &#x27;react&#x27;// 主题颜色const themes = &#123; light: &#123; foreground: &#x27;#000&#x27;, background: &#x27;#eee&#x27; &#125;, dark: &#123; foreground: &#x27;#fff&#x27;, background: &#x27;#222&#x27; &#125;&#125;// 创建 Contextconst ThemeContext = React.createContext(themes.light) // 初始值function ThemeButton() &#123; const theme = useContext(ThemeContext) return &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt; hello world &lt;/button&gt;&#125;function Toolbar() &#123; return &lt;div&gt; &lt;ThemeButton&gt;&lt;/ThemeButton&gt; &lt;/div&gt;&#125;function App() &#123; return &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt; &lt;Toolbar&gt;&lt;/Toolbar&gt; &lt;/ThemeContext.Provider&gt;&#125;export default App 3.3 useReducer123456789101112131415161718192021// 两个参数 initialState 和 reducer const initialState = &#123;count: 0&#125;const reducer = (state, action)=&gt;&#123; switch(action.type)&#123; case &#x27;increment&#x27;: return &#123; count: state.count + 1&#125; case &#x27;decrement&#x27;: return &#123; count: state.count - 1&#125; default: return state &#125;&#125;function ReducerDemo()&#123; // useReducer 使用 const [state, dispatch] = useReducer(reducer, initialState) return &lt;div&gt; count: &#123;state.count&#125; &lt;button onClick=&#123;()=&gt;dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;()=&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;/div&gt;&#125; useReducer 和 redux 的区别 useReducer 是 useState 的代替方案，用于 state 复杂变化 useReducer 是单个组件状态管理，组件通讯还需要 props redux 是全局状态管理，多组件共享数据 3.4 useMemohooks 性能优化，当然不一定必须要进行性能优化，只在有需要的时候考虑 React 默认会更新所有子组件 class 组件使用 SCU 和 PureComponent 做优化 Hooks 中使用 useMemo ，但优化的原理是相同的 3.5 useCallback和 useMemo 差不多，只是 useMemo缓存数据，useCallback 缓存函数 1234567891011121314151617181920212223242526272829303132333435import React ,&#123;useMemo,memo,useCallback&#125; from &quot;react&quot;;import &#123; useState &#125; from &quot;react/cjs/react.development&quot;;// 用 memo 对子组件进行封装const Child = memo((&#123;info&#125;)=&gt;&#123; console.log(&#x27;child render...&#x27;); return &lt;div&gt; &lt;p&gt;当前值: &#123;info.name&#125;&lt;/p&gt; &lt;/div&gt;&#125;)function App()&#123; console.log(&#x27;parent render...&#x27;); const [count, setCount] = useState(0) const [name, setName] = useState(&#x27;Dmoo&#x27;) const [value,setValue] = useState(&#x27;当前为空&#x27;) // 用 useMemo 对传给子组件的数据进行封装, 依赖里的 item 改变了子组件再会刷新 const info = useMemo(()=&gt;&#123; return &#123;name, age:18&#125; &#125;,[name]) // 用 useCallback 封装函数, 父组件层的函数变化不会引起子组件再刷新 const onChange = useCallback((e)=&gt;&#123; setValue(e.target.value) &#125;,[]) return &lt;div&gt; &#123;count&#125; &#123;/* count 改变只有父组件会刷新，子组件不会 */&#125; &lt;button onClick=&#123;()=&gt; setCount(count + 1)&#125;&gt;点击&lt;/button&gt; &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125;&gt;&lt;/input&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;Child info = &#123;info&#125;/&gt; &lt;/div&gt;&#125;export default App 4.自定义 Hook 封装通用功能 开发和使用第三方 hooks 自定义 hook 带来了无限的扩展性，解耦代码 123456789101112131415161718192021222324252627import &#123; useState, useEffect &#125; from &#x27;react&#x27;import axios from &#x27;axios&#x27;// 封装 axios 发送网络请求的自定义 Hookfunction useAxios(url) &#123; const [loading, setLoading] = useState(false) const [data, setData] = useState() const [error, setError] = useState() useEffect(() =&gt; &#123; // 利用 axios 发送网络请求 setLoading(true) axios.get(url) // 发送一个 get 请求 .then(res =&gt; setData(res)) .catch(err =&gt; setError(err)) .finally(() =&gt; setLoading(false)) &#125;, [url]) return [loading, data, error]&#125;export default useAxios// 第三方 Hook// https://nikgraf.github.io/react-hooks/// https://github.com/umijs/hooks 123456789101112// 使用import React from &#x27;react&#x27;import useAxions from &#x27;...&#x27;function App()&#123; const url = &#x27;xxx&#x27; const [loading, data, error] = useAxions(url) if(loading) return &lt;div&gt;loading...&lt;/div&gt; return error ?&lt;div&gt;&#123;JSON.stringfy(error)&#125;&lt;/div&gt; :&lt;div&gt;&#123;JSON.stringfy(data)&#125;&lt;/div&gt;&#125; 5.组件逻辑复用 HOC 组件层级嵌套过多，不易渲染，不易调试 Render Prop 学习成本比较高 hooks 实现 完全符合 hooks 原有原则 变量作用域明确 不会产生组件嵌套 代码示例 自定义组件获得鼠标位置 12345678910111213141516171819202122232425262728293031import &#123; useState, useEffect &#125; from &#x27;react&#x27;function useMousePosition() &#123; const [x, setX] = useState(0) const [y, setY] = useState(0) useEffect(() =&gt; &#123; function mouseMoveHandler(event) &#123; setX(event.clientX) setY(event.clientY) &#125; // 绑定事件 document.addEventListener(&#x27;mousemove&#x27;, mouseMoveHandler) // 解绑事件 return () =&gt; document.removeEventListener(&#x27;mousemove&#x27;, mouseMoveHandler) &#125;, []) return [x, y]&#125;export default useMousePosition// 使用function App()&#123; const [x,y] = useMousePosition() return &lt;div&gt; &lt;div&gt;鼠标位置 &#123;x&#125; &#123;y&#125;&lt;/div&gt; &lt;/div&gt;&#125; 6.规范和注意事项 命名用 use 开头 使用规范 只能用于 React 函数组件和自定义 hook 中 只能用于顶层代码，不能在循环、判读中使用 Hooks Hooks 调用顺序 无论是 render 还是 re-render， Hooks 调用顺序都必须一致 如果 Hooks 出现在循环、判断里则无法保证顺序一致 Hooks 严重依赖于调用顺序 注意事项 useState 初始化值，只有第一次有效 12345678910111213141516171819202122232425262728// 子组件function Child(&#123; userInfo &#125;) &#123; // render: 初始化 state // re-render: 只恢复初始化的 state 值，不会再重新设置新的值 // 只能用 setName 修改 // 也就是说只能拿到第一次 userInfo.name 的值，即使父组件 userInfo.name 改变了也不影响子组件 const [ name, setName ] = useState(userInfo.name) return &lt;div&gt; &lt;p&gt;Child, props name: &#123;userInfo.name&#125;&lt;/p&gt; &lt;p&gt;Child, state name: &#123;name&#125;&lt;/p&gt; &lt;/div&gt;&#125;function App() &#123; const [name, setName] = useState(&#x27;双越&#x27;) const userInfo = &#123; name &#125; return &lt;div&gt; &lt;div&gt; Parent &amp;nbsp; &lt;button onClick=&#123;() =&gt; setName(&#x27;慕课网&#x27;)&#125;&gt;setName&lt;/button&gt; &lt;/div&gt; &lt;Child userInfo=&#123;userInfo&#125;/&gt; &lt;/div&gt;&#125; useEffect 内部不能修改 state 有依赖的时候可以拿到外面的值，如果没有依赖的话，相当于一直在闭包里面执行，就一直拿不到外面的值。可以用 useRef 解决 1234567891011121314151617181920212223242526272829import React, &#123; useState, useRef, useEffect &#125; from &#x27;react&#x27;function UseEffectChangeState() &#123; const [count, setCount] = useState(0) // 模拟 DidMount const countRef = useRef(0) useEffect(() =&gt; &#123; console.log(&#x27;useEffect...&#x27;, count) // 定时任务 const timer = setInterval(() =&gt; &#123; console.log(&#x27;setInterval...&#x27;, countRef.current) // setCount(count + 1) setCount(++countRef.current) &#125;, 1000) // 清除定时任务 return () =&gt; clearTimeout(timer) &#125;, []) // 依赖为 [] // 依赖为 [] 时： re-render 不会重新执行 effect 函数 // 没有依赖：re-render 会重新执行 effect 函数 return &lt;div&gt;count: &#123;count&#125;&lt;/div&gt;&#125;export default UseEffectChangeState useEffect 可能出现死循环 React 使用Object.is() 来判断是否相等，所以 如果依赖是值类型内容相等不会更新，但如果依赖是对象数组等引用类型，即使内容一样 Object.is() 判断出来都是 false。那么 useEffect 就会更新，很容易出现死循环。 7.一些题目7.1 为什么会有 react hooks ，它解决了什么问题 完善函数组件的能力，函数更适合 React 组件 组件逻辑复用， Hooks 表现更好 class 组件比较费解，不易拆解测试 class 组件中，相同的逻辑散落在各处 DidMount 和 DidUpdate 中获取数据 DidMount 绑定事件， willUnMount 解绑事件 使用 Hooks，相同逻辑可以分割到一个个 useEffect 中 7.2 React Hooks 如何模拟组件生命周期看 2 7.3 如何自定义 Hook？7.4 React Hooks 性能优化7.6 使用 React Hooks 遇到什么坑？7.7 Hooks 相比 HOC 和 Render Prop 有哪些优点？（important）","categories":[],"tags":[{"name":"React-Hooks","slug":"React-Hooks","permalink":"http://example.com/tags/React-Hooks/"}]},{"title":"React03","slug":"React03","date":"2022-02-01T05:56:55.000Z","updated":"2022-02-27T14:30:26.614Z","comments":true,"path":"2022/02/01/React03/","link":"","permalink":"http://example.com/2022/02/01/React03/","excerpt":"函数式编程 JSX本质 合成事件 组件渲染 setState","text":"函数式编程 JSX本质 合成事件 组件渲染 setState 1.函数式编程1.1 纯函数1.2 不可变值state 只能返回新值，不能修改原来的值 2.vdom 和 diff和 vue 里面差不多, 核心概念和实现思路都一样 3.JSX 本质JSX 不是 JS ，实际上是一个一个 React.createElement() 函数 React.createElement 即 h 函数，返回 vnode， 然后用 patch 渲染 第一个参数，可能是组件，也可能是 html tag 组件名首字母必须大写， html tag 必须小写，用于区分二者 3.1 JSX 基本使用React.createElement(&quot;dom节点&quot;, &quot;属性，没有就写 null&quot;, &quot;子元素1&quot;, &quot;子元素2&quot;) 12345678910111213// JSX 基本使用const imgElem = &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;some text&lt;/p&gt; &lt;img src = &#123;imgUrl&#125;/&gt;&lt;/div&gt; // 编译以后// JSX 基本使用const imgElem = React.createElement(&quot;div&quot;, &#123; id: &quot;div1&quot;&#125;, React.createElement(&quot;p&quot;, null, &quot;some text&quot;), React.createElement(&quot;img&quot;, &#123; src: imgUrl&#125;)); 3.2 JSX style12345678910111213141516const styleData = &#123; fontSize: &#x27;30px&#x27;, color: &#x27;blue&#x27;&#125;const styleElem = &lt;p style = &#123;styleData&#125;&gt; 设置 style&lt;/p&gt;// 编译后const styleData = &#123; fontSize: &#x27;30px&#x27;, color: &#x27;blue&#x27;&#125;;const styleElem = /*#__PURE__*/React.createElement(&quot;p&quot;, &#123; style: styleData&#125;, &quot;\\u8BBE\\u7F6E style&quot;); 3.3 JSX 组件React.createElement(组件名, &#123;属性，没有就写 null&#125;, &quot;子元素1&quot;, &quot;子元素2&quot;) 1234567891011const app = &lt;div&gt; &lt;Input submitTitle = &#123; onSubmitTitle &#125;/&gt; &lt;List list = &#123; list &#125; /&gt;&lt;/div&gt;// 编译后const app = React.createElement(&quot;div&quot;, null, React.createElement(Input, &#123; submitTitle: onSubmitTitle&#125;), React.createElement(List, &#123; list: list&#125;)); 3.4 JSX 事件12345678const eventList = &lt;p onClick = &#123; this.clickHandler &#125;&gt; some text&lt;/p &gt;// 编译后const eventList =React.createElement(&quot;p&quot;, &#123; onClick: (void 0).clickHandler&#125;, &quot;some text&quot;); 3.5 列表渲染1234567891011121314const listElem = &lt;ul &gt; &#123;this.state.list.map((item, index)=&gt;&#123; return &lt;li key = &#123;item.id&#125;&gt; Index: &#123;index&#125; Title: &#123;item.title&#125; &lt;/li&gt; &#125;)&#125;&lt;/ul &gt;const listElem = React.createElement(&quot;ul&quot;, null, (void 0).state.list.map((item, index) =&gt; &#123; return React.createElement(&quot;li&quot;, &#123; key: item.id &#125;, &quot;Index: &quot;, index, &quot;Title: &quot;, item.title);&#125;)); 4.合成事件4.1 现象 所有事件都挂载到 document 上 event 不是原生的，是 SyntheticEvent 合成事件对象 和 Vue 事件不同，和 DOM 事件也不同 eg: 1234567891011121314151617clickHandler2 = (event)=&gt;&#123; event.preventDefault() // 阻止默认行为 event.stopPropagation() // 阻止冒泡 console.log(&#x27;event target&#x27;,event.target); // 指向当前元素 console.log(&#x27;event currentTarget&#x27;,event.currentTarget); // 看似是一样的，但实际上不一样 console.log(&#x27;event&#x27;,event); // 这个 event 不是原生的 event ，是 react 封装的 SyntheticBaseEvent console.log(&#x27;event.__proto__.constructor&#x27;,event.__proto__.constructor); // 原生 event 如下 console.log(&#x27;nativeEvent&#x27;,event.nativeEvent); // 可以获得原生事件 PointerEvent console.log(&#x27;nativeEvent target&#x27;,event.nativeEvent.target); // 拿到触发的实例 a 标签 console.log(&#x27;nativeEvent currentTarget&#x27;,event.nativeEvent.currentTarget); // 绑定到了 root 上 // 1. event 是 SyntheticEvent ，模拟出来 DOM 事件所有能力 // 2. event.nativeEvent 是原生事件对象 // 3. 所有的事件，都被挂载到 root 上 // 4. 和 DOM 事件不一样，和 Vue 事件也不一样 &#125; 图示： 4.2 为什么要合成事件机制 更好的兼容性和跨平台 挂载到 root, 减少内存消耗，避免频繁解绑 方便事件的 统一管理（如事务机制） 5.setState batchUpdate机制（important）setState有时异步，有时同步（比如在 setTimeout, DOM 事件中）；有时合并执行（对象形式），有时不合并执行（函数形式） 5.1 setState 主流程 5.2 isBatchingUpdatessetState 本身无所谓异步还是同步，它是同步还是同步取决于有没有命中 batchUpdate 机制，如果 isBatchingUpdates 是 false 说明已经更新完了，可以拿到最新值。 eg: 简略说明，实际上比这个复杂得多 12345678910111213141516// setState 在 setTimeout 中是同步的，可以拿到最新值increase = () =&gt; &#123; // 开始执行：batchUpdate // 1.isBatchingUpdates = true setTimeout(() =&gt; &#123; // 3. isBatchingUpdates = false // 更新完毕，可以拿到最新值 this.setState(&#123; count: this.state.count + 1 &#125;) console.log(&#x27;setTimeout 打印的值&#x27;,this.state.count); // 打印的值是最新值 &#125;, 0); &#125;// 结束：batchUpdate// 2.isBatchingUpdates = false 12345678910increase = () =&gt; &#123; // 开始执行 batchUpdate // 1.isBatchingUpdates = true this.setState(&#123; count: this.state.count + 1 &#125;) console.log(this.state.count); // 只能拿到修改前的值 // 结束：batchUpdate // 2.isBatchingUpdates = false &#125; 5.3 是否命中 batchUpdate 机制可以命中 生命周期（和它调用的函数） React 中注册的事件（和它调用的函数） React 可以“管理”的入口 不可以命中 setTimeout setInterval 等（和它调用的函数） 自定义的 DOM 事件（和它调用的函数） React 不可以“管理”的入口 5.4 transaction 事物机制 最底层： initalize → anyMethod→close 6.组件渲染过程JSX 渲染为页面，setState 之后更新页面 6.1组件渲染 props state (数据) render() 生成 vnode patch(elem, vnode) patch(oldVnode, newVnode) 6.2 更新的两个阶段和 fiberpatch 分为两个阶段： reconciliation 阶段 - 执行 diff算法 （纯 JS 计算） commit 阶段 - 将 diff 结果渲染 DOM 如果不拆分阶段的话，可能会有一些性能问题： JS 是单线程，且和 DOM 渲染共用一个线程 当组件足够复杂，组件更新时计算和渲染压力都大 如果再有 DOM 操作需求（动画，鼠标拖拽等），可能会造成卡顿 fiber 将 reconciliation 阶段进行任务拆分（commit 无法拆分） DOM 需要渲染时暂停，空闲时恢复 API: window.requestIdleCallback","categories":[],"tags":[{"name":"函数式编程 JSX本质 合成事件 组件渲染 setState","slug":"函数式编程-JSX本质-合成事件-组件渲染-setState","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-JSX%E6%9C%AC%E8%B4%A8-%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6-%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93-setState/"}]},{"title":"React-Redux","slug":"React-Redux","date":"2022-01-30T14:36:35.000Z","updated":"2022-01-31T08:48:00.419Z","comments":true,"path":"2022/01/30/React-Redux/","link":"","permalink":"http://example.com/2022/01/30/React-Redux/","excerpt":"React 小书笔记","text":"React 小书笔记 1. ReduxRedux 是一种设计模式，不是 React 专属，旨在管理共享数据 1.1 dispatchstate 里面的某些数据需要共享，但不能随意修改，所以就需要一个专门的函数来管理修改数据的操作，限制我们修改数据的自由度。 1.2 store state 和 dispacth 的集合 订阅者模式监听数据变化 在 createStore 中，我们的代码只能修改数据，之后还需要我们手动渲染页面，很不方便。所以我们需要在 createStore 函数中添加订阅者模式，自动渲染页面。 具体来讲，我们只需要添加一个 listeners 数组，和 subscribe 函数就行。我们执行一次 createStore 里的 subscribe 函数 ，让 listeners 数组添加一个 listener函数，然后dispatch时遍历 listeners 数组，依次执行 listener 就能自动渲染页面。 12345678910111213function createStore (state, stateChanger) &#123; // listeners 数组，存储 listener 渲染页面的函数 const listeners = [] // subscribe 接收 listener 参数，push 进 listeners 数组中 const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; stateChanger(state, action) // dispatch 时遍历执行 listener listeners.forEach((listener) =&gt; listener()) &#125; return &#123; getState, dispatch, subscribe &#125;&#125; ​ 1234567const store = createStore(appState, stateChanger)// 执行 subscribe 函数，添加需要的渲染函数store.subscribe( () =&gt; renderApp(store.getState()) )renderApp(store.getState()) // 首次渲染页面store.dispatch(&#123; type: &#x27;UPDATE_TITLE_TEXT&#x27;, text: &#x27;《React.js 小书》&#x27; &#125;) // 修改标题文本store.dispatch(&#123; type: &#x27;UPDATE_TITLE_COLOR&#x27;, color: &#x27;blue&#x27; &#125;) // 修改标题颜色// ...后面不管如何 store.dispatch，都不需要重新调用 renderApp 1.3 纯函数相同的输入，总是会的到相同的输出，并且在执行过程中没有任何副作用。 副作用指的是函数在执行过程中产生了外部可观察变化： 发起HTTP请求 操作DOM 修改外部数据 console.log()打印数据 调用Date.now()或者Math.random() 1.4 性能优化首先，先了解 ES6 的对象浅复制语法 123456789101112131415161718192021const obj1 = &#123; address:&#123; city: &#x27;beijing&#x27;, detail: &#x27;chaoyang&#x27; &#125;, code: &#x27;00000&#x27; &#125;// 已修改数据：把需要修改的数据都浅复制一遍再修改，这样对象的内容不一样，指向也不一样，不再相等// 未修改数据：内容一样，指向一样，仍然相等const obj2 = &#123; ...obj1, address:&#123; ...obj1.address, city: &#x27;shanghai&#x27; &#125;&#125;console.log(obj1.address.detail === obj2.address.detail); // trueconsole.log(obj1.address.city === obj2.address.city); // falseconsole.log(obj1); //&#123; address: &#123; city: &#x27;beijing&#x27;, detail: &#x27;chaoyang&#x27; &#125;, code: &#x27;00000&#x27; &#125;console.log(obj2); // &#123; address: &#123; city: &#x27;shanghai&#x27;, detail: &#x27;chaoyang&#x27; &#125;, code: &#x27;00000&#x27; &#125; 我们之前的函数，其实很多数据都是没有修改的，完全不需要重新渲染，所以实际上，我们还需要定义 oldAppState 和 newAppState , 用于比较到底哪些数据进行了修改，哪些没有修改。重新渲染被修改了的数据，未被修改的数据就不用重新渲染。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function createStore (state, stateChanger) &#123; const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = stateChanger(state, action) // 覆盖原对象 listeners.forEach((listener) =&gt; listener()) &#125; return &#123; getState, dispatch, subscribe &#125;&#125;function renderApp (newAppState, oldAppState = &#123;&#125;) &#123; // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = &#123;&#125; if (newAppState === oldAppState) return // 数据没有变化就不渲染了 console.log(&#x27;render app...&#x27;) renderTitle(newAppState.title, oldAppState.title) renderContent(newAppState.content, oldAppState.content)&#125;function renderTitle (newTitle, oldTitle = &#123;&#125;) &#123; if (newTitle === oldTitle) return // 数据没有变化就不渲染了 console.log(&#x27;render title...&#x27;) const titleDOM = document.getElementById(&#x27;title&#x27;) titleDOM.innerHTML = newTitle.text titleDOM.style.color = newTitle.color&#125;function renderContent (newContent, oldContent = &#123;&#125;) &#123; if (newContent === oldContent) return // 数据没有变化就不渲染了 console.log(&#x27;render content...&#x27;) const contentDOM = document.getElementById(&#x27;content&#x27;) contentDOM.innerHTML = newContent.text contentDOM.style.color = newContent.color&#125;let appState = &#123; title: &#123; text: &#x27;React.js 小书&#x27;, color: &#x27;red&#x27;, &#125;, content: &#123; text: &#x27;React.js 小书内容&#x27;, color: &#x27;blue&#x27; &#125;&#125;function stateChanger (state, action) &#123; switch (action.type) &#123; case &#x27;UPDATE_TITLE_TEXT&#x27;: return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, text: action.text &#125; &#125; case &#x27;UPDATE_TITLE_COLOR&#x27;: return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, color: action.color &#125; &#125; default: return state // 没有修改，返回原来的对象 &#125;&#125;const store = createStore(appState, stateChanger)let oldState = store.getState() // 缓存旧的 statestore.subscribe(() =&gt; &#123; const newState = store.getState() // 数据可能变化，获取新的 state renderApp(newState, oldState) // 把新旧的 state 传进去渲染 oldState = newState // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染&#125;)renderApp(store.getState()) // 首次渲染页面store.dispatch(&#123; type: &#x27;UPDATE_TITLE_TEXT&#x27;, text: &#x27;《React.js 小书》&#x27; &#125;) // 修改标题文本store.dispatch(&#123; type: &#x27;UPDATE_TITLE_COLOR&#x27;, color: &#x27;blue&#x27; &#125;) // 修改标题颜色 1.5 reducer由 stateChanger 修改而来，是一个纯函数 先把 appState 和 stateChanger 合并，让 stateChanger 有初始化 appState 的作用，并修改stateChanger 函数名为 reducer 1234567891011121314151617181920212223242526272829303132333435function reducer (state, action) &#123; // 初始化数据 if (!state) &#123; return &#123; title: &#123; text: &#x27;React.js 小书&#x27;, color: &#x27;red&#x27;, &#125;, content: &#123; text: &#x27;React.js 小书内容&#x27;, color: &#x27;blue&#x27; &#125; &#125; &#125; switch (action.type) &#123; case &#x27;UPDATE_TITLE_TEXT&#x27;: return &#123; ...state, title: &#123; ...state.title, text: action.text &#125; &#125; case &#x27;UPDATE_TITLE_COLOR&#x27;: return &#123; ...state, title: &#123; ...state.title, color: action.color &#125; &#125; default: return state &#125;&#125; createStore 里只需要传入 stateChanger 函数， 123456789101112function createStore (reducer) &#123; let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) &#125; dispatch(&#123;&#125;) // 初始化 state return &#123; getState, dispatch, subscribe &#125;&#125; 1.6 createStore 模板12345678910111213141516// 定一个 reducerfunction reducer (state, action) &#123; /* 初始化 state 和 switch case */&#125;// 生成 storeconst store = createStore(reducer)// 监听数据变化重新渲染页面store.subscribe(() =&gt; renderApp(store.getState()))// 首次渲染页面renderApp(store.getState()) // 后面可以随意 dispatch 了，页面自动更新store.dispatch(...) 2.React-Redux2.0 前置知识如果一个组件的渲染只依赖于外界传进去的 props 和自己的 state，而并不依赖于其他的外界的任何数据，也就是说像纯函数一样，给它什么，它就吐出（渲染）什么出来。这种组件的复用性是最强的，别人使用的时候根本不用担心任何事情，只要看看 PropTypes 它能接受什么参数，然后把参数传进去控制它就行了。 我们把这种组件叫做 Pure Compoent，因为它就像纯函数一样，可预测性非常强，对参数（props）以外的数据零依赖，也不产生副作用。这种组件也叫 Dumb Component，因为它们呆呆的，让它干啥就干啥。写组件的时候尽量写 Dumb Component 会提高我们的组件的可复用性。 2.1 Connect用高阶组件帮助我们从 context 中取数据，通过 props 传给 Dumb 组件。这个高阶组件起名叫 connect 123456789101112131415export connect = (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; // TODO: 从 store 取数据 render () &#123; return &lt;WrappedComponent /&gt; &#125; &#125; return Connect&#125; connect 函数接受一个 WrappedComponent 组件，再把这个组件包在一个新组件 Connect 中返回。新组件 Connect 获取 store 中的数据，通过 props 传给 WrappedComponent 。 2.2 mapStateToprops不同的 WrappedComponent 需要不同的数据，这要求我们告知高阶组件 connect 特定的 WrappedComponent 需要什么数据，所以我们可以另外传给 connect 一个函数 mapStateToprops。 12345678const mapStateToProps = (state) =&gt; &#123; return &#123; themeColor: state.themeColor, themeName: state.themeName, fullName: `$&#123;state.firstName&#125; $&#123;state.lastName&#125;` ... &#125;&#125; 现在 connect 可以写为 12345678910111213141516export const connect = (mapStateToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; render () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps(store.getState()) // &#123;...stateProps&#125; 意思是把这个对象里面的属性全部通过 `props` 方式传递进去 return &lt;WrappedComponent &#123;...stateProps&#125; /&gt; &#125; &#125; return Connect&#125; connect用法： 123456const mapStateToProps = (state) =&gt; &#123; return &#123; themeColor: state.themeColor &#125;&#125;Header = connect(mapStateToProps)(Header) 2.3 mapDispatchToPropsconnect 还需要知道组件需要如何触发 dispatch， mapDispatchToProps 就是为了满足这个需求的。和 mapStateToProps 一样，它返回一个对象，这个对象内容会同样被 connect 当作是 props 参数传给被包装的组件。不一样的是，这个函数不是接受 state 作为参数，而是 dispatch，你可以在返回的对象内部定义一些函数，这些函数会用到 dispatch 来触发特定的 action。 1234567const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onSwitchColor: (color) =&gt; &#123; dispatch(&#123; type: &#x27;CHANGE_COLOR&#x27;, themeColor: color &#125;) &#125; &#125;&#125; 2.4 Providerconnect 组件需要拿到 store 才能传给子组件，所以我们增加一个组件叫做 Provider, 专门用于存放 store。 123456789101112131415export class Provider extends React.Component&#123; static propTypes = &#123; store: PropTypes.object, children: PropTypes.any &#125; static childContextTypes = &#123; store: PropTypes.object &#125; getChildContext()&#123; return &#123; store &#125; &#125; render()&#123; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &#125;&#125; Provider 是一个容器组件，会把嵌套的内容原封不动作为自己的子组件渲染出来。它还会把外界传给它的 props.store 放到 context，这样子组件 connect 的时候都可以获取到。","categories":[],"tags":[{"name":"redux react-redux","slug":"redux-react-redux","permalink":"http://example.com/tags/redux-react-redux/"}]},{"title":"React02","slug":"React02","date":"2022-01-27T15:02:29.000Z","updated":"2022-02-07T17:58:23.145Z","comments":true,"path":"2022/01/27/React02/","link":"","permalink":"http://example.com/2022/01/27/React02/","excerpt":"函数组件、非受控组件、异步组件","text":"函数组件、非受控组件、异步组件 1.函数组件 相当于 class 组件的简化版本，没有什么逻辑，只是简单渲染 props； 纯函数，输入 props，输出 JSX 没有实例，没有生命周期，没有 state 不能扩展其它方法 12345678910111213141516// class 版class ListDemo extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; const &#123; list &#125; = this.props return( &lt;ul&gt; &#123; this.state.list.map((item, index)=&gt;&#123; return( &lt;li key=&#123;item.id&#125;&gt; index: &#123;index&#125;； id: &#123;item.id&#125;； title: &#123;item.title&#125;&lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt;)&#125;&#125; 12345678910111213// 函数组件版function List(props)&#123; const &#123; list &#125; = this.props return ( &lt;ul&gt; &#123;list.map(()=&gt;&#123; return &lt;li key=&#123;item.id&#125;&gt; index: &#123;index&#125;；id: &#123;item.id&#125;；title: &#123;item.title&#125; &lt;/li&gt; &#125;)&#125; &lt;/ul&gt; )&#125; 2.非受控组件 必须手动操作 DOM 元素，setState 实现不了； 文件上传 &lt;input type=&#39;file&#39;&gt;； 某些富文本编辑器 2.1 ref、defaultChecked，defaultValue在 vue 里面，dom 节点可以直接赋值成一个 ref 属性的字符串，然后直接获取。在 react 流程也差不多，但是 ref 需要是 React.createRef() 创建的一个对象。 12345678910constructor(props)&#123; super(props) this.state = &#123; name: &#x27;Dmoon&#x27;, flag: true, &#125; // ref 的创建规则 this.ref1 = React.createRef() this.ref2 = React.createRef() &#125; 使用 ref 1234567891011121314151617// 1. input 中使用 ref ：不需要绑定 onChange 事件，value 改成 defaultValue，赋值 ref 属性// 因为没有 onChange 事件，所以 input 里的数据改变不会影响 span 的数据&lt;div&gt; &#123;/* 使用 defaultValue 而不是 value ，使用 ref */&#125; &lt;input defaultValue=&#123;this.state.name&#125; ref=&#123;this.nameInputRef&#125;/&gt; &#123;/* state 并不会随着改变 */&#125; &lt;span&gt;state.name: &#123;this.state.name&#125;&lt;/span&gt; &lt;br/&gt; &lt;button onClick=&#123;this.alertName&#125;&gt;alert name&lt;/button&gt;&lt;/div&gt;// 获取 DOM 节点 alertName = () =&gt; &#123; // state 中的值不会改变，要拿到新的值，要从 ref 获取 const elem = this.nameInputRef.current // 通过 ref 获取当前 DOM 节点 alert(elem.value) // 不是 this.state.name&#125; 1234567// 2. CheckBox 作为非受控组件 checkbox defaultChecked，我们点击修改是否选中 checkbox 时不会影响 state 中flag的值&lt;div&gt; &lt;input type=&quot;checkbox&quot; defaultChecked=&#123;this.state.flag&#125; /&gt; &lt;/div&gt; 2.2 手动操作 DOM 元素比如说读取文件，必须要手动获取 DOM 操作，此时就要用上 ref 1234567891011alertFile = () =&gt; &#123; const elem = this.fileInputRef.current // 通过 ref 获取 DOM 节点 alert(elem.files[0].name) &#125;render()&#123; return &lt;div&gt; &lt;input type=&quot;file&quot; ref=&#123;this.fileInputRef&#125;/&gt; &lt;button onClick=&#123;this.alertFile&#125;&gt;alert file&lt;/button&gt; &lt;/div&gt;&#125; 3.Portals中文翻译为传送门，组件默认会按照层级渲染，但是有时我们会需要渲染到父组件以外。 父组件使用了 overflow: hidden , 限制了子组件的展示，那么就可以使用 Portals 让子组件逃离父组件； 父组件 z-index 值太小， fixed 需要放在 body 第一层 123456789// 假设 model 的 css 为 position: fixed;import ReactDOM from &#x27;react-dom&#x27;render()&#123; // 两个参数，一个是要渲染的节点，一个是需要挂载的地方 return ReactDOM.createPortal( &lt;div className=&quot;model&quot;&gt;&#123;this.props.children&#125;&lt;/div&gt;, document.body // DOM 节点 )&#125; 4.context 管理一些比较简单的公共数据的地方，比如说语言，主题等 函数组件 和 class 组件使用起来略有不同，但是思路一致 xxxContext.Provider 包裹需要使用 Context 的组件 .Consumer + value 消费 Context eg1 12345678910111213141516171819202122232425262728293031323334353637383940// 1. 创建 context 并传参// 需要一个默认值，可以额外定义也可以直接传const defaultContextValue = &#123; userName: &#x27;Dmoon&#x27;&#125;// 通过 React.createContext 新建一个 contextexport const appContext = React.createContext(defaultContextValue)// contextName.Provider 包裹组件，把 Context 传过去&lt;appContext.Provider value=&#123;defaultContextValue&#125;&gt; &lt;App/&gt;&lt;/appContext.Provider&gt;// 2. 组件使用 contextimport React, &#123;useContext&#125; from &quot;react&quot;;import &#123; appContext &#125; from &quot;../index&quot;; // context 定义的路径// 假设 App 组件有一个子组件 Child// 2.1 如果使用一般的模式const Child = ()=&gt;&#123; return ( &lt;appContext.Consumer&gt; &#123;(value)=&gt;&#123; return &lt;div&gt; &#123;value.userName&#125; &lt;/div&gt; &#125;&#125; &lt;/appContext.Consumer&gt; ) &#125;// 2.2 使用钩子的形式const Child = ()=&gt;&#123; const value = useContext(appContext); return &lt;div&gt; &#123;value.userName&#125; &lt;/div&gt;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React from &#x27;react&#x27;// 1. 创建 context 括号中的参数是默认值const ThemeContext = React.createContext(&#x27;light&#x27;)// 2. 管理 context 的最外层组件class ContextDemo extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; theme: &#x27;light&#x27; &#125; &#125; changeTheme = ()=&gt;&#123; this.setState(&#123; theme: this.state.theme === &#x27;light&#x27;?&#x27;dark&#x27;:&#x27;light&#x27; &#125;) &#125; render()&#123; // 包括父组件总共有三层 ContextDemo → ToolBar → ThemeLink 和 ThemedButton return ( &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt; &lt;Toolbar /&gt; &lt;hr/&gt; &lt;button onClick=&#123;this.changeTheme&#125;&gt;change theme&lt;/button&gt; &lt;/ThemeContext.Provider&gt; ) &#125;&#125;// 3.ToolBar 层function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;ThemeLink /&gt; &lt;/div&gt; )&#125;// 4.1 底层组件 - 函数式组件function ThemeLink (props) &#123; // const theme = this.context // 会报错。函数式组件没有实例，即没有 this // 函数式组件可以使用 Consumer return &lt;ThemeContext.Consumer&gt; &#123; value =&gt; &lt;p&gt;link&#x27;s theme is &#123;value&#125;&lt;/p&gt; &#125; &lt;/ThemeContext.Consumer&gt;&#125;// 4.2 底层组件 - class 组件class ThemedButton extends React.Component &#123; // 指定 contextType 读取当前的 theme context。 // static contextType = ThemeContext // 也可以用 ThemedButton.contextType = ThemeContext render() &#123; const theme = this.context // React 会往上找到最近的 theme Provider，然后使用它的值。 return &lt;div&gt; &lt;p&gt;button&#x27;s theme is &#123;theme&#125;&lt;/p&gt; &lt;/div&gt; &#125;&#125;// 需要指明 class 组件的 context 是谁ThemedButton.contextType = ThemeContext export default ContextDemo 5.异步组件主要是为了性能优化，可以在 performance 里面把网速设置成 3G，然后再 network 里选 JS 再刷新看效果 123456789101112131415161718192021222324252627import React from &#x27;react&#x27;// React.lazy 封装一下，然后 import 我们要的组件const ContextDemo = React.lazy(() =&gt; import(&#x27;./ContextDemo&#x27;))class App extends React.Component &#123; constructor(props) &#123; super(props) &#125; render() &#123; return &lt;div&gt; &lt;p&gt;引入一个动态组件&lt;/p&gt; &lt;hr /&gt; &#123;/* React.Suspense 标签加载异步组件 fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125; 是我们在加载异步组件但还没完成时页面上显示的内容 */&#125; &lt;React.Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;ContextDemo/&gt; &lt;/React.Suspense&gt; &lt;/div&gt; // 1. 强制刷新，可看到 loading （看不到就限制一下 chrome 网速） // 2. 看 network 的 js 加载 &#125;&#125;export default App 6.性能优化 (important)相对于 vue 来说，性能优化对 react 更加重要，setState 的不可变值在这个部分一定要谨记 6.1 SCU (shouldComponentUpdate)1234567shouldComponentUpdate(nextProps, nextState)&#123; if(nextState.count !== this.state.count)&#123; return true // 可以渲染 &#125; return false // 不可以渲染 &#125; 核心问题是：为什么要有 shouldComponentUpdate 这个生命周期，默认返回 true 不就可以了吗？ 因为react 默认如果父组件更新，子组件也会更新，即使子组件实际数据没有改变。 性能优化对 React 更重要 SCU 不一定每次都要用，需要性能优化的时候再用 必须配合不可变值使用 123456789101112131415161718// 对于第 4 点的说明，情景：给从 input 给列表添加数据// 错误的写法：push 会改变原数组,所以修改的数据前后是一样的onSubmit = ()=&gt; &#123; this.state.list.push(&#x27;input-value&#x27;) this.setState(&#123; list: this.state.list &#125;)&#125;// 此时的 SCU 比较，不管怎么比较都是 false，因为 nextState 和 this.state 里面的 list 值是一样的，页面也不会重新渲染// 正确的写法：使用 concat 等不会改变原数组的apionSubmit = ()=&gt;&#123; this.setState(&#123; list: this.state.list.concat(&#x27;input-value&#x27;) &#125;)&#125; PS 自定义的 SCU 中最好不要使用深度比较，因为深度比较一次递归到底，比较耗费性能 6.2 PureComponent 和 React.memo PureComponent 在 SCU 中实现浅比较， 属于 class 组件 React.memo, 函数组件中的 PureComponent 大部分情况都是用浅比较 使用 123456789101112131415161718192021222324// class 组件中class Demo extends React.PureComponent &#123; ... // 默认带了一个 SCU 进行浅比较 shouldComponentUpdate(nextProps, nextState)&#123; // 默认始终返回true return true； &#125;&#125;// 函数组件中// 1. 写一个函数组件function Demo(props)&#123; /* 使用 props 渲染 */&#125;// 2. 写一个浅层比较函数function isEqual(prevProps, nextProps)&#123; /* 如果相同返回 true 不同返回 false */&#125;// 3. 把两者都传到 React.memo 中export default React.memo(Demo, isEqual); 6.3 不可变值 immutable.js可以实现深拷贝的功能，但不是深拷贝，性能比较好 7.高阶组件 HOC 基本用法 12345678910const HOCFactory = (Component) =&gt;&#123; class HOC extends React.Component&#123; // 在此定义多个组件的公共逻辑 render()&#123; return &lt;Component &#123;...this.props&#125;/&gt; &#125; &#125; return HOC&#125;const EnchancedComponent = HOCFactory(WrappedComponent) 举例：我们定义一个获得 mousePosition 的高阶组件 12345678910111213141516171819202122232425262728// 高阶组件 抽离公共逻辑 传进来一个组件 返回一个新组件const mousePosition = (Component)=&gt;&#123; class mousePositionComponent extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; x: 0, y: 0 &#125; &#125; mouseMoveHandler = (e)=&gt;&#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;) &#125; render()&#123; return( &lt;div style=&#123;&#123;height: &#x27;500px&#x27;&#125;&#125; onMouseMove=&#123;this.mouseMoveHandler&#125;&gt; &#123;/* &#123;...this.props&#125; 表示解析传进来组件的所有 props */&#125; &#123;/* 传递 mouse 属性给组件 */&#125; &lt;Component &#123;...this.props&#125; mouse = &#123;this.state&#125;/&gt; &lt;/div&gt; ) &#125; &#125; return mousePositionComponent&#125; 123456789101112131415161718192021222324252627282930313233// 需要渲染的组件class HOCDemo extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; // this.props 代表外部传给该组件的数据 // a 在我们使用 HOCDemo 时传递进来 const a = this.props.a const &#123;x,y&#125; = this.props.mouse return( &lt;div style=&#123;&#123; height: &#x27;500px&#x27; &#125;&#125;&gt; &lt;h1&gt;&#123;x&#125; &#123;y&#125;&lt;/h1&gt; &lt;p&gt;&#123;a&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default mousePosition(HOCDemo)// 因为只需要渲染，所以可以写成函数组件const HOCDemo = (props) =&gt; &#123; const a = props.a const &#123; x, y &#125; = props.mouse // 接收 mouse 属性 return ( &lt;div style=&#123;&#123; height: &#x27;500px&#x27; &#125;&#125;&gt; &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;)&lt;/h1&gt; &lt;p&gt;&#123;a&#125;&lt;/p&gt; &lt;/div&gt; )&#125; 使用 HOCDemo 1&lt;HOCDemo a= &#123;100&#125;/&gt; Vue 如何实现高阶组件？ 8.Render PropsVue 里面没有类似的 基本使用 12345678910111213141516171819// 核心思想：通过一个函数将 class 组件的 state 作为 props 传递给纯函数组件class Factory extends React.Component&#123; constructor()&#123; this.state = &#123; // 存储多个组件公共逻辑的数据 &#125; &#125; render()&#123; // 修改 state return &lt;div&gt;&#123;this.props.render(this.state)&#125;&lt;/div&gt; &#125;&#125;const App = ()=&gt;&#123; &lt;Factory render=&#123; // render 是一个函数组件 (props) =&gt; &lt;p&gt;&#123;...props&#125;&lt;/p&gt; &#125;/&gt;&#125; 举例：获取鼠标坐标 12345678910111213141516171819202122232425262728// 公共逻辑组件class Mouse extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; x: 0, y: 0 &#125; &#125; mouseMoveHandler = (e)=&gt;&#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;) &#125; render()&#123; return &lt;div&gt; &lt;div onMouseMove=&#123;this.mouseMoveHandler&#125;&gt; &#123;/* 接受外部 props 传进来的 render函数，然后把自己的 state 传给这个 render 函数*/&#125; &#123;this.props.render(this.state)&#125; &lt;/div&gt; &lt;/div&gt; &#125;&#125;// 必须接收一个 render 属性，而且是函数Mouse.propTypes = &#123; render: PropTypes.func.isRequired &#125; 12345678910111213// 封装组件的函数const RenderProp = (props)=&gt;&#123; const a = props.a return &lt;div style=&#123;&#123;height: &#x27;500px&#x27;&#125;&#125;&gt; &lt;p&gt;&#123;a&#125;&lt;/p&gt; &lt;Mouse render=&#123; (&#123;x,y&#125;)=&gt; &lt;h1&gt;mousePosition is &#123;x&#125;, &#123;y&#125;&lt;/h1&gt; &#125;/&gt; &lt;/div&gt;&#125;export default RenderProp&lt; RenderProp a=&#123;100&#125;/&gt; 逻辑是这样的： 外部组件传 a 给 renderProp，然后 renderProp 传一个 render 函数给 Mouse（通过 props 获得外界传给自己的数据）， Mouse 被使用的时候，会提供自己的数据给 render 函数。 9.reduxhttps://hyf.js.org/react-naive-book/lesson30 redux 剥离组件数据（state），将数据统一存放在 store中，组件订阅 store 获得数据，store同步推送数据更新 9.1 基本概念两个重点：不可变值 和 纯函数 store action reducer 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; createStore &#125; from &#x27;redux&#x27;;/** * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。 * 描述了 action 如何把 state 转变成下一个 state。 * * state 的形式取决于你，可以是基本类型、数组、对象、 * 甚至是 Immutable.js 生成的数据结构。惟一的要点是 * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。 * * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper) * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。 */function counter(state = 0, action) &#123; switch (action.type) &#123; case &#x27;INCREMENT&#x27;: return state + 1; case &#x27;DECREMENT&#x27;: return state - 1; default: return state; &#125;&#125;// 创建 Redux store 来存放应用的状态。// API 是 &#123; subscribe, dispatch, getState &#125;。let store = createStore(counter);// 可以手动订阅更新，也可以事件绑定到视图层。store.subscribe(() =&gt; console.log(store.getState()));// 改变内部 state 惟一方法是 dispatch 一个 action。// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行store.dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;);// 1store.dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;);// 2store.dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;);// 1 9.2 单项数据流整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 state 不可变值：只能返回一个新的 state, 不能修改原来的 state dispatch(action) reducer -&gt; newState subscribe 订阅者模式触发通知 9.3 react-redux &lt;Provider store = &#123; store &#125;&gt; connect mapStateToProps mapDispacthToProps 9.4 异步 action（容易考）123456789101112131415161718192021// 同步 actionexport const addTodo = text =&gt; &#123; // 返回 action 对象 return &#123; type: &#x27;ADD_TODO&#x27;, id: nextTodoId++, text &#125;&#125;// 异步 action 在异步的时候 dispatch，主要就是 dispatch 里面通过 action.type 和 payload（或者说 return的值）来拿到数据export const addTodoAsync = text =&gt;&#123; // 返回参数，其中有 dispatch 参数 return (dispatch) =&gt;&#123; // ajax 异步获取数据 fetch(url).then(res =&gt;&#123; // 异步执行 action dispatch(addTodo(res.text)) &#125;) &#125;&#125; redux-thunk 可以返回一个函数，而不一定是 js 对象 在一个 thunk action 中可以完成一系列连续的 action 操作 可以处理异步逻辑 可以把业务逻辑从 UI 层挪到这里，代码分层会更清晰 redux-promise redux-saga 9.5 中间件 redux-thunk ``redux-promise` redux-saga 在 dispatch 和 reducer 中间截获 action，redux中间件就提供给了我们分类处理 action 的机会 公式 1const middleware = ( store ) =&gt; ( next ) =&gt; ( action ) =&gt; &#123; &#125; 一共嵌套了三层函数，分别传递了 store next action 这三个参数（柯里化） 9.6图 10.react-router6 相对于 5 有很多区别 可以参考这篇博客 https://blog.csdn.net/u010821983/article/details/121283039 前置知识：SPA(单页网站应用) JS、CSS、HTML 打包为一个超级大的文件，一次性丢给浏览器 JS 劫持浏览器路由，生成虚拟路由来动态渲染页面 dom 元素 符合前后端分离的趋势，服务器不负责 UI 输出，而专注于数据支持 react-router react-router-dom 用于浏览器，处理 Web App 的路由 react-router-native 用于 React Native，处理手机 app 的路由 react-router-redux 提供了路由的中间件，处理 redux 的集成 react-router-config 用来配置静态路由 路由切换可以用 useNavigate() 也可以用 Link （6 里面基本不用 withRouter 了），用 Link 比较好一点 路由模式 路由配置（动态路由、懒加载）","categories":[],"tags":[{"name":"React 高级特性","slug":"React-高级特性","permalink":"http://example.com/tags/React-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}]},{"title":"React01","slug":"React01","date":"2022-01-27T06:36:30.000Z","updated":"2022-02-05T09:11:26.938Z","comments":true,"path":"2022/01/27/React01/","link":"","permalink":"http://example.com/2022/01/27/React01/","excerpt":"JSX 基本使用、父子组件通信、生命周期、setState","text":"JSX 基本使用、父子组件通信、生命周期、setState 0.React设计理念 单向数据流 数据与界面绑定 单向渲染 类似函数，同样的输入，同样的输出 虚拟 DOM 在 JS 和真实的 DOM 间添加了虚拟 DOM 层，如果真实的 UI 需要更新，对比两个 UI 最小的差距进行重新渲染 组件化 保持交互一致性和视觉风格统一 便于复用和相互协作 1.JSX 基本使用 变量、表达式 class style 子元素和组件 2.条件判断3.事件4.表单5.父子组件通信5.1 父组件向子组件传递数据12345// 父组件在使用子组件时添加数据，子组件用 this.props 获取// 父组件：&lt;List list = &#123;this.state.list&#125;/&gt;// 子组件 Listconst &#123;list&#125; = this.props 5.2 父组件向子组件传递函数和传递属性差不多 12345678// 父组件定义函数 onSubmitTitle，在标签中传递给子组件 Input &lt;Input submitTitle = &#123;this.onSubmitTitle&#125;/&gt;// 子组件通过 this.props 获取这个函数，同时传递自己的参数&lt;button onClick=&#123;this.onSubmit.bind(this)&#125;&gt; 提交&lt;/button&gt;onSubmit()&#123; const &#123; submitTitle &#125; = this.props submitTitle() // 里面是否传参，传递什么参数，看父组件怎么定义的&#125; 为了确保父组件中使用子组件时传递的参数正确，还可以添加类型检查。(当然传递属性时也可以限制类型) 12345import PropTypes from &#x27;prop-types&#x27;// 类型检查Input.propTypes = &#123; submitTitle: PropTypes.func.isRequired&#125; 5.3状态提升比如说两个子组件 List 组件和 Input 组件都需要一个 list 列表数据，前者只负责渲染，后者只负责修改，那么 list 列表数据就可以放在父组件中，由父组件来统一调配，这称做状态提升 6.setState (important)异步更新，同步执行 6.1 不可变值要在 setState 里面修改数据，在修改状态时千万不能改变原来的状态state。shouldMountUpdate生命周期中会将要改变的值与之前的值做个比较来确定是否改变视图，以这种方式来优化性能 12345678910111213141516171819202122// 1. state 在 constructor 里面定义constructor(props) &#123; super(props) // 第一，state 要在构造函数中定义 this.state = &#123; count: 0, list: [1,2,3,4,5], obj1: &#123;a: 100&#125;, obj2: &#123;x: 100&#125; &#125;&#125;// 2. 第二，不要直接修改 state ，使用不可变值// this.state.count++ 是错误的this.setState(&#123; count: this.state.count + 1, // SCU list: this.state.list.concat(6), // 不能用 push pop splice 等会改变原数组的 api obj: Object.assign(&#123;&#125;, this.state.obj1, &#123;b: 200&#125;), obj1: &#123;...this.state.obj1, y: 200&#125; &#125;) 6.2 可能是异步更新① setState 异步的情况 12345678910111213141516171819constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; render() &#123; return &lt;div&gt; &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt; &lt;button onClick=&#123;this.increase&#125;&gt;累加&lt;/button&gt; &lt;/div&gt; &#125; increase = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) console.log(this.state.count); // 只能拿到修改前的值 &#125; 如果一定要拿到新值，可以在 setState 中加回调函数，相当于 vue 中的 $nextTick 12345this.setState(&#123; count: this.state.count + 1 &#125;,()=&gt;&#123; console.log(&#x27;回调函数打印的值&#x27;,this.state.count);&#125;) ② setState 是同步的情况 1234567891011121314// 1. 在 setTimeout 中是同步的increase = () =&gt; &#123; setTimeout(() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) console.log(&#x27;setTimeout 打印的值&#x27;,this.state.count); // 打印的值是最新值 &#125;, 0); &#125;componentWillUnmount() &#123; // 及时销毁定时器 clearTimeout&#125; 123456789101112131415// 2. 在自定义的 DOM 事件中是同步的componentDidMount()&#123; document.body.addEventListener(&#x27;click&#x27;, this.clickHandler)&#125;clickHandler = ()=&gt;&#123; this.setState(&#123; count: this.state.count + 1 &#125;) console.log(&#x27;body 打印的值&#x27;,this.state.count);&#125;// 注意及时销毁componentWillUnmount() &#123; // 及时销毁自定义 DOM 事件 document.body.removeEventListener(&#x27;click&#x27;, this.bodyClickHandler)&#125; 6.3 可能会被合并① 传入对象时会被合并 12345678910// 传入对象，会被合并（类似 Object.assign ）。执行结果只一次 +1 this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;) ② 传入函数时不会被合并 12345678910111213141516// 传入函数，不会被合并。执行结果是 +3 this.setState((prevState, props) =&gt; &#123; return &#123; count: prevState.count + 1 &#125; &#125;) this.setState((prevState, props) =&gt; &#123; return &#123; count: prevState.count + 1 &#125; &#125;) this.setState((prevState, props) =&gt; &#123; return &#123; count: prevState.count + 1 &#125; &#125;) 7.React 生命周期 Mounting: 创建虚拟 DOM ， 渲染 UI Updating：更新虚拟 DOM， 重新渲染 UI Unmounting：删除虚拟 DOM，移除 UI 单组件生命周期（父子组件生命周期和 Vue 一样）","categories":[],"tags":[{"name":"React 基本使用","slug":"React-基本使用","permalink":"http://example.com/tags/React-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"}]},{"title":"React00","slug":"React00","date":"2022-01-01T06:17:39.000Z","updated":"2022-02-07T17:42:45.104Z","comments":true,"path":"2022/01/01/React00/","link":"","permalink":"http://example.com/2022/01/01/React00/","excerpt":"React概览","text":"React概览 1.路线 基本使用 高级特性 Redux 和 React-router 使用 2.一些面试题2.1React 组件如何通讯 父子组件 props 自定义事件 Redux 和 Context 2.2JSX 本质是什么 createElement 执行返回 Vnode 2.3 Context 是什么，如何应用 父组件，向其下所有子孙组件传递信息 如一些简单的公共信息：主题色、语言等 复杂的公共信息：Redux 2.4 SCU 的用途 性能优化（看实际情况） 配合不可变值一起使用，否则会出错 2.5redux 单项数据流比较常考，React02 的 9.6 图 setState 是同步还是异步 12345678910111213141516171819202122232425class Root extends Component&#123; constructor(props)&#123; super(props) this.state = &#123;count: 0&#125; &#125; componentDidMount()&#123; // 两个异步的合并了 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count); // 0 this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count); // 0 // setTimeout 里面的是同步 setTimeout(() =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count); // 2 &#125;, 0); setTimeout(() =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125;) console.log(this.state.count); //3 &#125;, 0); &#125; render()&#123; return &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt; &#125;&#125; 2.6 什么是纯函数 返回一个新值，没有副作用 重点：不可变值 比如说： arr1 = arr.slice() 2.7 React 组件生命周期 单组件生命周期 父子组件生命周期 注意 SCU 的位置 2.7 React 发起 ajax 应该在哪个生命周期 同 Vue，在 DOM 渲染完成以后 componentDidMount 2.8 渲染列表为何使用 key 同 Vue。 必须使用 key, 并且 key 不能是 Index 和 Random diff算法 中通过 tag 和 key 来判断是否是 sameNode 减少渲染次数，提升渲染性能 2.7 函数组件和 class 组件的区别 纯函数，输入 props, 输出 JSX 没有实例，没有生命周期，没有 state 不能扩展其它方法 2.8 什么是受控组件 表单的值，受 state 控制 需要自行监听 onChange 更新 state 对比非受控组件 2.9 何时使用异步组件 同 Vue 加载大组件 路由懒加载 2.10 多个组件有公共逻辑，如何抽离 高阶组件 HOC Render Props 2.11 redux 如何进行异步请求 使用异步 action redux-thunk 12// redux-thunk 可以返回函数，处理异步请求 2.12 react-router 如何配置懒加载 lazy 2.13 PureComponent 有何区别 实现了浅比的 SCU 优化性能 结合不可变值使用 2.14 React 事件和 DOM 事件的区别 所有事件挂载在 root 上(16挂载在 document 上) event 不是原生的，是 SyntheticEvent 合成事件对象 dispatchEvent 2.15 React 性能优化 渲染列表用 key 自定义事件、DOM 事件及时销毁 合理使用异步组件 减少函数 bind this 的次数 合理使用 SCU PureComponent memo 合理使用 Immutable.js webpack 层面的优化 前端通用的性能优化，如图片懒加载 使用 SSR 2.16 React 和 Vue 的区别相同： 都支持组件化 都是数据驱动视图 都是用 vdom 来操作 DOM 不同： React 使用 JSX 拥抱 JS，Vue 使用模板拥抱 html React 函数式编程，Vue 声明式编程 React 更多需要自己写，Vue 有很多内置指令等","categories":[],"tags":[]},{"title":"Vue3基础03","slug":"Vue3基础03","date":"2021-12-29T11:52:43.000Z","updated":"2022-01-30T14:34:14.663Z","comments":true,"path":"2021/12/29/Vue3基础03/","link":"","permalink":"http://example.com/2021/12/29/Vue3%E5%9F%BA%E7%A1%8003/","excerpt":"JSX 在 Vue3中的使用、JSX 和 template 的区别","text":"JSX 在 Vue3中的使用、JSX 和 template 的区别 1.JSX 在 Vue3 中的基本使用 使用 .jsx 格式文件和 defineComponent 引用自定组件，传递属性 1234567891011121314151617// 使用 jsx 文件import &#123; defineComponent, ref &#125; from &quot;vue&quot;;// 可以引入子组件，子组件标签和子组件名字要一致，都得大写import Child from &#x27;./Child&#x27;export default defineComponent(()=&gt;&#123; const countRef = ref(200) const render = ()=&gt;&#123; return &lt;&gt; &lt;p&gt;demo &#123;countRef.value&#125;&lt;/p&gt; &lt;Child a=&#123;countRef.value + 100&#125;&gt;&lt;/Child&gt; &lt;/&gt; &#125; return render&#125;) 123456789101112131415// 引入的子组件// 子组件import &#123; defineComponent &#125; from &quot;vue&quot;;// jsx 里面 defineComponent 可以传入一个 setup 也可以传入组建配置export default defineComponent(&#123; // 传递属性 a props: [&#x27;a&#x27;], setup(props)&#123; const render = ()=&gt;&#123; return &lt;p&gt;&#123;props.a&#125;&lt;/p&gt; &#125; return render &#125; &#125;) 事件 条件事件（子组件还是一样的） 12345678910111213141516171819202122import &#123; defineComponent, ref &#125; from &quot;vue&quot;;// 可以引入子组件import Child from &#x27;./Child&#x27;export default defineComponent(()=&gt;&#123; const flagRef = ref(true) // 定义一个 changeFlag 函数改变 flag 的值 function changeFlag()&#123; flagRef.value = !flagRef.value &#125; const render = ()=&gt;&#123; return &lt;&gt; &#123;/* onClick 是原生事件 事件名用单括号包起来 */&#125; &#123;/* 判断事件 */&#125; &lt;p onClick=&#123;changeFlag&#125;&gt;demo &#123;flagRef.value.toString()&#125;&lt;/p&gt; &#123;flagRef.value &amp;&amp; &lt;Child a=&#123;flagRef.value.toString()&#125;&gt;&lt;/Child&gt;&#125; &lt;/&gt; &#125; return render&#125;) 2.循环事件 1234567891011121314import &#123; defineComponent, reactive, ref &#125; from &quot;vue&quot;;export default defineComponent(()=&gt;&#123; const state = reactive(&#123; list: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] &#125;) const render = ()=&gt;&#123; return &lt;&gt; &lt;ul&gt; &#123;state.list.map(item =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/&gt; &#125; return render&#125;) 2.JSX 和 template 的区别虽然语法上有区别，但本质上是一样的 语法上的区别 ​ 1.JSX 本质上是 js 代码，可以使用 js 的任何能力，而 template 只能嵌入简单的 js 表达式，其它的功能需要质量， 比如 v-if 之类的 本质上相同 ​ 都被编译成 js 代码 3.JSX 和 slot（插槽）待补充 4.Vue3 script setupvue 要用 3.2 以上的 基本使用 12345678910111213// 如果看起来别扭 可以把 template 和 script 换个位置&lt;template&gt; &lt;p @click=&quot;addCount&quot;&gt;&#123;&#123;countRef&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;ref&#125; from &#x27;vue&#x27;const countRef = ref(100)// 顶级变量可以直接用于 template 不用返回function addCount()&#123; countRef.value++&#125;&lt;/script&gt; 子组件直接引用就可以，不需要 components 注册 12345678&lt;script setup&gt;import Child from &#x27;./Child&#x27;&lt;/script&gt;&lt;template&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt; 属性和事件 ​ defineProps 和 defineEmits defineExpose 暴露给父组件","categories":[],"tags":[]},{"title":"Vue3基础02","slug":"Vue3基础02","date":"2021-12-28T09:08:19.000Z","updated":"2022-01-30T14:33:48.617Z","comments":true,"path":"2021/12/28/Vue3基础02/","link":"","permalink":"http://example.com/2021/12/28/Vue3%E5%9F%BA%E7%A1%8002/","excerpt":"JSX 和 template 的区别","text":"JSX 和 template 的区别 1.Vue3 相当于 Vue2 升级了哪些功能 creatApp 1234567891011121314// Vue2const app = new Vue(&#123; /**/&#125;)Vue.use( /**/)Vue.mixin( /**/)Vue.component( /**/)Vue.directive( /**/)// Vue3const app = Vue.createApp(&#123; /**/&#125;)app.use( /**/)app.mixin( /**/)app.component( /**/)app.directive( /**/) emits 属性 12&lt;!--父组件--&gt;&lt;HelloWorld :msg=&quot;msg&quot; @onSayHello=&quot;sayHello&quot;/&gt; 1234567// 父组件methods: &#123; sayHello(info) &#123; console.log(&#x27;hello&#x27;,info) &#125;&#125; 1234567891011// 子组件export default&#123; name: &quot;HelloWorld&quot;, props: &#123; msg：String &#125;, emits: [&#x27;onSayHello&#x27;], // 在 emits 里注册一下 setup(props, &#123; emit &#125;)&#123; // setup 里面有 props 和 &#123;emit&#125; 两个参数 emit(&#x27;sayHello&#x27;,&#x27;vue3&#x27;) // 用 emit 调用方法 &#125;&#125; 生命周期 多事件 1234&lt;!-- 在 methods 里面定义 one two 两个函数--&gt;&lt;button @click=&quot;one($event), two($event)&quot;&gt; Submit&lt;/button&gt; Fragment Vue2 里面 template 要用一个单一的父节点包起来，Vue3 里面没有这个限制 移除 .sync 改为 v-model 这个作用简单来说就是 父组件 把一些参数传给 子组件，子组件修改父组件也跟着修改，实现双向绑定 123456// vue2//.sync: https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6&lt;MyComponent v-bind:title.sync=&quot;title&quot;/&gt;//vue3&lt;MyComponent v-model:title=&quot;title&quot;/&gt; 演示： 123456789101112131415161718192021222324252627282930//父组件&lt;template&gt; &lt;p&gt;&#123;&#123;name&#125;&#125; &#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;!-- 传给子组件 让子组件修改 --&gt; &lt;user-info v-model:name=&quot;name&quot; v-model:age=&quot;age&quot; &gt; &lt;/user-info&gt; &lt;/template&gt;&lt;script&gt;import &#123; reactive, toRefs &#125; from &#x27;@vue/reactivity&#x27;import UserInfo from &#x27;./UserInfo.vue&#x27;export default &#123; name: &#x27;VModel&#x27;, components:&#123; UserInfo &#125;, setup() &#123; const state = reactive(&#123; age: 18, name: &#x27;Dmoon&#x27; &#125;) return toRefs(state) &#125;,&#125;&lt;/script&gt; 1234567891011121314151617// 子组件&lt;template&gt; &lt;input :value=&quot;name&quot; @input=&quot;$emit(&#x27;update:name&#x27;, $event.target.value)&quot; &gt; &lt;input :value=&quot;age&quot; @input=&quot;$emit(&#x27;update:age&#x27;, $event.target.value)&quot;&gt; &lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;UserInfo&#x27;, props:&#123; name: String, // 把 age 改成 String 就不会报类型 warn 了 age: Number &#125;&#125;&lt;/script&gt; 异步组件的写法 1234567891011121314151617181920//vue2new Vue(&#123; //... components: &#123; &#x27;my-component&#x27;: ()=&gt;import(&#x27;./my-async-component.vue&#x27;) &#125;&#125;)// vue3import&#123;createApp. defineAsyncComponent&#125; from &#x27;vue&#x27;createApp(&#123; //... componentes: &#123; AsyncComponent: defineAsyncComponent(()=&gt;&#123; import(&#x27;./components/AsyncComponent.vue&#x27;) &#125;) &#125;&#125;) 移除 filter teleport https://v3.cn.vuejs.org/guide/teleport.html#%E4%B8%8E-vue-components-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8 12345678910111213141516171819202122232425262728const app = Vue.createApp(&#123;&#125;);app.component(&#x27;modal-button&#x27;, &#123; template: ` &lt;button @click=&quot;modalOpen = true&quot;&gt; Open full screen modal! (With teleport!) &lt;/button&gt; &lt;teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt; &lt;div&gt; I&#x27;m a teleported modal! (My parent is &quot;body&quot;) &lt;button @click=&quot;modalOpen = false&quot;&gt; Close &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt; `, data() &#123; return &#123; modalOpen: false &#125; &#125;&#125;)app.mount(&#x27;#app&#x27;) suspense &lt;suspense&gt; 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中 其实就是用了插槽封装了一个组件 1234567891011121314151617181920&lt;template&gt; &lt;suspense&gt; &lt;template #default&gt; &lt;todo-list /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt; Loading... &lt;/div&gt; &lt;/template&gt; &lt;/suspense&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123; TodoList: defineAsyncComponent(() =&gt; import(&#x27;./TodoList.vue&#x27;)) &#125;&#125;&lt;/script&gt; Composition API 在 Vue3基础01 里有仔细讲 reactive ref readonly watch 和 watchEffect setup 生命周期钩子函数 2.Vue3如何实现响应式（很重要） Vue2 的 Object.defineProperty 深度监听要一次性递归，如果层级太深性能不够好；对数组要另外监听；删除新增属性监听不到 proxy 基本使用 123456789101112131415161718192021222324252627282930313233343536// const data = &#123;// name: &#x27;zhangsan&#x27;,// age: 20,// &#125;const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型）的属性 const ownKeys = Reflect.ownKeys(target) if(ownKeys.includes(key))&#123; console.log(&#x27;get&#x27;, key); &#125; const result = Reflect.get(target, key, receiver) console.log(&#x27;get-result&#x27;, result); // 返回结果 return result &#125;, set(target, key, val, receiver)&#123; // 重复的数据不处理 if(val === target[key])&#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val); console.log(&#x27;set-result&#x27;, result); // set是否成功 true false return result &#125;, deleteProperty(target, key)&#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key); console.log(&#x27;delete-result&#x27;, result); // delete 是否成功 true false return result &#125;&#125;) PS： reflect 的作用: 和 proxy 一一对应（参数和 API ）；具有函数式、规范化、标准化的特点；替代 Object 上的工具函数 eg： 123456789// 用 Reflect 判断是否存在某个属性 const obj = &#123;a: 100, b: 200&#125;Reflect.has(obj, &#x27;a&#x27;)// 用 Reflect 删除某个属性Reflect.deleteProperty(obj, &#x27;b&#x27;)// 用 Reflect 获得 ownKeysReflect.ownKeys(obj) Vue3 如何使用 proxy 实现响应式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 创建响应式function reactive(target = &#123;&#125;)&#123; if(typeof target !== &#x27;object&#x27; || target == null)&#123; // 不是对象或数组直接返回 return target &#125; // 配置代理(单独写) const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型）的属性 const ownKeys = Reflect.ownKeys(target) if(ownKeys.includes(key))&#123; console.log(&#x27;get&#x27;, key); &#125; const result = Reflect.get(target, key, receiver) // 为了深度监听，结果还要再包一层 reactive 因为如果不包的话，我们直接返回的是第一层 proxy 监听后的对象// 包了之后监听到一个层级还要继续往下直到到达目标// 这和之前的深度监听有一个性能优化上的区别：满足条件的时候 在 get 里面递归 而不是在最外层直接递归到最深处// 也就是获取到哪一层才会触发响应式 // 返回结果 return reactive(result) &#125;, set(target, key, val, receiver)&#123; // 重复的数据不处理 if(val === target[key])&#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if(ownKeys.includes(key))&#123; console.log(&#x27;已有的key&#x27;, key); &#125;else&#123; console.log(&#x27;新增的key&#x27;, key); &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val); // set是否成功 true false return result &#125;, deleteProperty(target, key)&#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key); // delete 是否成功 true false return result &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed &#125;const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;Beijing&#x27; &#125; &#125;const proxyData = reactive(data) proxy 可以规避 Object.defineProperty 的问题，但是无法兼容所有的浏览器，无法 polyfill 3.watch 和 watchEffect 的区别watchEffect 是 Vue3 的新特性 两者都可以监听 data 属性变化 watch 需要明确监听哪个属性 watchEffect 会根据其中的属性，自动监听其变化 watch 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;p&gt;&#123;&#123;numberRef&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; age&#125;&#125; &#123;&#123; name&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive, ref, toRefs, watch&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Watch&#x27;, setup() &#123; const numberRef = ref(100) const state = reactive(&#123; age: 18, name: &#x27;Dmoon&#x27; &#125;) watch(numberRef,(newValue, oldValue)=&gt;&#123; console.log(&#x27;watch&#x27;, newValue, oldValue); &#125;) // 监听对象 第一个参数是函数，确定监听哪个属性 watch(()=&gt;state.age, // 第二个参数 回调函数 (newage, oldage)=&gt;&#123; console.log(&#x27;ageChanged&#x27;,newage, oldage); &#125; // 第三个参数 一些配置项 immediate 和 deep ) setTimeout(() =&gt; &#123; state.age = 200 // 可以改 ，但是 watch 因为没有监听这个值，所以监听不到 state.name = &#x27;Dnoon&#x27; &#125;, 1500); return &#123; numberRef, ...toRefs( state) &#125; &#125;,&#125;&lt;/script&gt; watchEffect 为了根据响应式状态自动应用和重新应用副作用，我们可以使用 watchEffect 函数。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。 12345678910// 把上面的代码里 watch 部分替换成这样就行了 // watchEffect 总会自动初始化执行一次 相当于 immediate: true watchEffect(()=&gt;&#123; console.log(&#x27;watchEffect initiates&#x27;); &#125;)// 里面写什么参数就自动跟踪什么参数 watchEffect(()=&gt;&#123; console.log(&#x27;state.age&#x27;, state.age); console.log(&#x27;state.name&#x27;, state.name); &#125;) 4.setup 如何获得组件实例 在 setup 和其它 composition API 里面没有 this 可以通过 getCurrentInstance 获取当前实例 若使用 options API 照常可以使用 this 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;p&gt;&#123;&#123;x&#125;&#125; &#123;&#123;y&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123; getCurrentInstance, onMounted &#125; from &#x27;@vue/runtime-core&#x27;;export default &#123; data()&#123; return &#123; x: 20, y: 200 &#125; &#125;, setup() &#123; console.log(&#x27;this&#x27;, this); // undefined // setup 用 instance const instance = getCurrentInstance() console.log(&#x27;instance&#x27;,instance); // 可以获得组件实例 onMounted(()=&gt;&#123; console.log(&#x27;this1&#x27;, this); // undefined console.log(instance.data.x); // 可以获得数据 &#125;) &#125;, // options API 用 this mounted()&#123; console.log(&#x27;this&#x27;, this); // 一个 proxy 实例 console.log(&#x27;y&#x27;, this.y); // 可以直接拿到 &#125; &#125;&lt;/script&gt; 5.Vue3 为什么比 Vue2 快？ proxy 响应式 ​ 比 define.objectProperty 快 PatchFlag ​ Vue 在编译模板时，利用 PatchFlag 把动态节点标记起来。标记还分为不同的类型，有 text、props 等。这样做的好处 是 在 diff 算法时， 可以区分静态节点以及不同类型的动态节点。并不是优化 diff 算法，其实 diff 算法没什么好优化的 了。而是优化了 diff 算法的输入。（优化的时候，可以考虑 上游 和 下游，优化整个流程） hoistStatic ​ 基本策略是 拿空间换时间。 将静态节点的定义提升到父作用域缓存起来，多个相邻的静态节点会被何并起来。 CacheHandler ​ 缓存事件，把事件缓存起来 SSR 优化 ​ 静态节点直接输出，不同过 vdom， 动态节点还是照常 tree-shaking ​ 根据不同的情况引用不同的 api 6.Vite 为什么启动快？Vite 是一个前端打包工具 开发环境使用 ES6 Module， 无需打包，所以非常快 生产环境下使用 rollup 并不会快很多","categories":[],"tags":[]},{"title":"Vue3基础01","slug":"Vue3基础01","date":"2021-12-28T02:16:09.000Z","updated":"2022-02-04T19:14:43.019Z","comments":true,"path":"2021/12/28/Vue3基础01/","link":"","permalink":"http://example.com/2021/12/28/Vue3%E5%9F%BA%E7%A1%8001/","excerpt":"主要内容： ref toRef toRefs","text":"主要内容： ref toRef toRefs 1.Vue3 比 Vue2 有什么优势 性能更好 体积更小 更好的 ts 支持 更好的代码组织 更好的逻辑抽离 2.Vue3的生命周期Vue3 有两种生命周期，一种是 options API（原来 Vue2 的）或者 setup 里面的 composition API 生命周期，按照需求选择其中一个 2.1 Options API 生命周期beforeDestroy 改为 beforeUnmount destroyed 改为 unmounted 其它沿用 Vue2 的生命周期 2.2 Composition API 生命周期因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。 1234567891011121314151617181920212223setup()&#123; // beforeCreate Not needed*// created Not needed* onBeforeMount(()=&gt;&#123; console.log(&#x27;onBeforeMount&#x27;); &#125;) onMounted(()=&gt;&#123; console.log(&#x27;onMounted&#x27;); &#125;) onBeforeUpdate(()=&gt;&#123; console.log(&#x27;onBeforeUpdate&#x27;); &#125;) onUpdated(()=&gt;&#123; console.log(&#x27;onUpdated&#x27;); &#125;) onBeforeUnmount(()=&gt;&#123; console.log(&#x27;onBeforeUnmount&#x27;); &#125;) onUnmounted(()=&gt;&#123; console.log(&#x27;onUnmounted&#x27;); &#125;) &#125; 3.Options API 和 Composition API 的异同3.1Composition API 带来了什么在大型的项目中更有优势 更好的代码组织 更好的逻辑复用 更好的类型推导 3.2如何选择 最好不要共用，会引起混乱 小型项目、业务逻辑简单，用 Options API 中大型项目、逻辑复杂，用 Composition API 4.ref toRef 和 toRefs（很重要）4.1 ref 生成值类型的响应式数据 可用于模板和 reactive 通过 .value 修改值 123&lt;template&gt; &lt;p&gt;ref demo &#123;&#123;nameRef&#125;&#125; &#123;&#123;ageRef&#125;&#125;&lt;/p&gt;&lt;/template&gt; 定义 ref 的值的时候，变量名格式 xxxRef （增加易读性） 1234567891011121314151617181920212223242526272829import &#123;ref, reactive&#125; from &#x27;vue&#x27; export default&#123; name: &#x27;Ref&#x27;, setup()&#123; const ageRef = ref(18) // 值类型 响应式 const nameRef = ref(&#x27;Dmoon&#x27;) const state = reactive(&#123; name: nameRef // reactive &#125;) setTimeout(() =&gt; &#123; console.log(&#x27;age&#x27;,ageRef.value); console.log(&#x27;name&#x27;,nameRef.value); console.log(&#x27;changed&#x27;); ageRef.value = 20 // 修改和获得都用 .value nameRef.value = &#x27;Dnoon&#x27; console.log(&#x27;age&#x27;,ageRef.value); console.log(&#x27;name&#x27;,nameRef.value); &#125;, 1500); return&#123; ageRef, state, nameRef &#125; &#125; &#125; PS：ref 在生命周期 onMounted 里可以获取 DOM 元素 1&lt;p ref=&quot;elemRef&quot;&gt;ref demo &#123;&#123;nameRef&#125;&#125; &#123;&#123;ageRef&#125;&#125;&lt;/p&gt; 1234const elemRef = ref(null) // 随便定义一个 null 的 elemRef onUnmounted(()=&gt;&#123; console.log(&#x27;ref template&#x27;, elemRef.value.innerHTML); &#125;) 4.2 toRef 针对一个响应式对象（reactive 封装）的 prop 创建一个 ref ， 具有响应式 两者保持引用关系 123&lt;template&gt; &lt;p&gt;toRef demo &#123;&#123;nameRef&#125;&#125; &#123;&#123;state.age&#125;&#125; &lt;/p&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627import &#123; reactive, toRef &#125; from &#x27;vue&#x27;export default&#123; name: &#x27;toRef&#x27;, setup()&#123; // 普通对象实现响应式 用 reactive // 一个响应式对象的单独一个属性要做响应式，用 toRef const state = reactive(&#123; age: 18, name: &#x27;Dmoon&#x27; &#125;) const nameRef = toRef(state, &#x27;name&#x27;) setTimeout(() =&gt; &#123; state.name = &#x27;Dnoon&#x27; console.log(&#x27;name changed 1&#x27;); &#125;, 2000); setTimeout(() =&gt; &#123; nameRef.value = &#x27;DMOON&#x27; console.log(&#x27;name changed 2&#x27;); &#125;, 3000); return&#123; state, nameRef &#125; &#125;&#125; 4.3 toRefs 将响应式对象（reactive封装） 转换为普通对象 对象的每个 prop 都是对应的 ref 两者保持引用关系 1234567891011121314151617181920212223242526272829303132&lt;template&gt;&lt;div&gt; &lt;p&gt;toRefs demo &lt;/p&gt; &lt;p&gt; &#123;&#123;name&#125;&#125; &#123;&#123;age&#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;import &#123; reactive, toRefs &#125; from &#x27;vue&#x27;export default &#123; name: &#x27;toRefs&#x27;, setup() &#123; const state = reactive(&#123; age: 18, name: &#x27;Dmoon&#x27; &#125;) const stateToRefs = toRefs(state) setTimeout(() =&gt; &#123; state.age = 30 &#125;, 1500); return stateToRefs &#125;,&#125;&lt;/script&gt; 合成函数返回响应式对象 4.4 toRefs 和 toRef 的最佳使用方式 用 reactive 做对象的响应式，用 ref 做值类型的响应式 setup 中返回 toRefs(state) , 或者 toRef(state, ‘xxx’) ref 的变量名用 xxxRef 合成函数返回响应式对象时，用 toRefs 123&lt;template&gt; &lt;p&gt; &#123;&#123;x&#125;&#125; &#123;&#123;y&#125;&#125;&lt;/p&gt;&lt;/template&gt; 123456789101112131415161718192021//合成函数返回响应式对象import &#123; reactive, toRefs &#125; from &#x27;@vue/reactivity&#x27;function useFeatureX()&#123; const state = reactive(&#123; x: 1, y: 2 &#125;) // 返回 toRefs 对象 return toRefs(state)&#125;export default &#123; setup() &#123; const &#123;x,y&#125; = useFeatureX() return &#123; // x y 可以抽离出来直接使用 x,y &#125; &#125; &#125; 5.ref toRef toRefs 的进阶理解5.1为什么要 ref我们返回的值类型，并不一定是单纯的返回 const a = 20 这种，像 computed，合成函数还有 watch 这些里面都可能返回值类型，一返回就丢失响应式了（因为值类型不是引用传递，return 以后就不会知道以后有什么改变了）。而 Vue 里面用 proxy 实现的响应式又只针对对象，所以我们需要一个 ref 。 简单说如下两点： 返回值类型，会丢失响应式，在setup、computed、合成函数都有可能返回值类型 如果不定义 ref， 用户自己创造，反而会混乱 5.2 为什么要 .value首先要明确一点：响应式针对的是一个对象，所以值类型用了 ref 后返回的肯定是一个对象 ref 是一个对象（不丢失响应式），value 存储值 通过 .value 属性的 get 和 set 实现响应式 用于 模板、 reactive 时不需要 .value， 其它情况都需要 以 computed 函数为例，主要是我们要把值类型给变成一个对象有引用关系，所以 .value 是自然而然需要的 12345678910111213// 错误的写法function computed(getter)&#123; let value = 0 setTimeout(()=&gt;&#123; console.log(&#x27;value1&#x27;, value) value = getter() console.log(&#x27;value2&#x27;, value) &#125;,1500) return value&#125;// 异步里面的修改不起作用 a 一直是 0let a = computed(()=&gt; 100) 123456789101112function computed(getter)&#123; let ref = &#123; value: null &#125; setTimeout(()=&gt;&#123; ref.value = getter() &#125;,1500) return ref&#125;let a = &#123;&#125;a = computed(()=&gt; 100) // &#123;value: 100&#125; 5.3为什么要 toRef 和 toRefs 不丢失响应式对象的情况下，把对象数据 分解/扩散 针对的是响应式对象（reactive封装的）非普通对象 它们不创造响应式，而是延续响应式 6.Composition API 实现逻辑复用 抽离逻辑代码到一个函数 函数命名约定为 useXxxx 格式（React Hooks 也是） 在 setup 中引用 useXxxx 12345678910111213141516171819&lt;template&gt; &lt;p&gt;MousePosition &#123;&#123;x&#125;&#125; &#123;&#123;y&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import useMousePosition from &#x27;./useMousePosition.js&#x27;export default (&#123; setup() &#123; const &#123;x,y&#125; = useMousePosition() return&#123; x, y &#125; &#125;,&#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930import &#123;ref, onMounted, onUnmounted&#125; from &#x27;vue&#x27;function useMousePosition()&#123; // 如果用 reactive 的话，就不能用解构的语法 // const state = reactive(&#123;x,y&#125;) 返回的时候 return &#123;state&#125; 使用的时候 state.x state.y // 也可以用 toRefs(state) 返回 然后就可以解构赋值了 const x = ref(0) const y = ref(0) function update(e)&#123; x.value = e.pageX y.value = e.pageY &#125; onMounted(()=&gt;&#123; console.log(&#x27;useMousePosition onmounted&#x27;); window.addEventListener(&#x27;mousemove&#x27;, update) &#125;) onUnmounted(()=&gt;&#123; console.log(&#x27;useMousePosition onUnmounted&#x27;); window.removeEventListener(&#x27;mousemove&#x27;, update) &#125;) return &#123; x, y &#125;&#125;export default useMousePosition","categories":[],"tags":[{"name":"Vue3 生命周期  ref toRef toRefs","slug":"Vue3-生命周期-ref-toRef-toRefs","permalink":"http://example.com/tags/Vue3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-ref-toRef-toRefs/"}]},{"title":"Vue原理03","slug":"Vue原理03","date":"2021-12-26T05:43:13.000Z","updated":"2022-02-04T19:13:55.337Z","comments":true,"path":"2021/12/26/Vue原理03/","link":"","permalink":"http://example.com/2021/12/26/Vue%E5%8E%9F%E7%90%8603/","excerpt":"Vue 的渲染更新过程 、前端路由原理","text":"Vue 的渲染更新过程 、前端路由原理 1.Vue 的渲染更新过程1.1初次渲染过程 解析模板为 render 函数（或在开发环境中已完成，vue-loader） 触发响应式，监听 data 属性 getter 和 setter 这一步要看数据和 dom 是怎么绑定的 1&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; 因为只有 message 绑定上来了，所以在初次渲染的时候，只会触发 message 的get ，像 name age 这些不管怎么变都不会影响到初次渲染的流程 12345678910export default&#123; data()&#123; return&#123; info: &#123; message: &#x27;人物信息&#x27;, name: &#x27;zhangsan&#x27;, age: &#x27;18&#x27;&#125;&#125;&#125;&#125; 执行 render 函数，生成 vnode, patch(elem,vnode) 1.2更新函数 修改 data 触发 setter（此前在 getter 中已被监听） 重新执行 vnode 函数，生成 newVnode patch(vnode, newVnode) 1.3示意图 1.4异步渲染（也很重要） nextTick 123456789101112131415161718192021222324export default&#123; data()&#123; return &#123; list: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125; &#125;, methods: &#123; addItem()&#123;// 由于 vue 是异步渲染的，所以这里的 data 不管改变多少次，vue 都只会在 data 全部修改完之后进行一次渲染 this.list.push(`$&#123;Date.now()&#125;`) this.list.push(`$&#123;Date.now()&#125;`) this.list.push(`$&#123;Date.now()&#125;`) const ulElem = this.$refs.ul1 // 没有nextTick时 我们只能获得修改前的数据 console.log(&#x27;没有nextTick时 &#x27;+ ulElem.childNodes.length); this.$nextTick(()=&gt;&#123; const ulElem = this.$refs.ul1 console.log(&#x27;有nextTick时 &#x27;+ ulElem.childNodes.length); &#125;) &#125; &#125; &#125; 汇总 data 的修改，一次性更新视图 减少 DOM 操作次数，提高性能 2.前端路由原理","categories":[],"tags":[{"name":"渲染更新过程 前端路由","slug":"渲染更新过程-前端路由","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"}]},{"title":"Vue原理02","slug":"Vue原理02","date":"2021-12-25T07:34:33.000Z","updated":"2022-02-04T18:29:57.354Z","comments":true,"path":"2021/12/25/Vue原理02/","link":"","permalink":"http://example.com/2021/12/25/Vue%E5%8E%9F%E7%90%8602/","excerpt":"Vue 原理的第三点：模板编译","text":"Vue 原理的第三点：模板编译 1. 前置知识JS 的 with 语法 123456789101112const obj = &#123;a: 100, b: 200&#125;console.log(obj.a)console.log(obj.b)console.log(obj.c) // undefined// with 语法 改变 &#123;&#125; 内变量的查找方式，将 &#123;&#125; 内的自由变量，当做 obj 的属性来查找// 要慎用 with ，因为它打破了 作用域 语法，易读性变差with(obj)&#123; console.log(a) // 默认找 obj.a console.log(b) // 默认找 obj.b console.log(c) // 报错&#125; 2. 模板编译我们都知道，html 是标签语言，不像 JS 一样，可以实现判断、循环。而我们的模板里面，既有标签，也有指令和插值，还有 JS 表达式，所以 模板 肯定是转换为某种 JS 代码，即编译模板。 这个转换的过程主要可以分为三步 模板编译为 render 函数，执行 render 函数返回 vnode 基于 vnode 再执行 patch 和 diff 使用 webpack vue-loader 在开发环境下编译模板 比如说 2.1.简单的表达式123456 const template = `&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;` const res = compiler.compile(template) console.log(res.render);// with(this)&#123;return createElement(&#x27;p&#x27;,[createTextVNode(toString(message))])&#125;// with 里面的 this 就是 const vm = new Vue(&#123;...&#125;) 2.2事件12345// 事件 const template = `&lt;button @click=&quot;submitHandler&quot;&gt;submit&lt;/button&gt;`// with(this)&#123;return _c(&#x27;button&#x27;,&#123;on:&#123;&quot;click&quot;:submitHandler&#125;&#125;,[_v(&quot;submit&quot;)])&#125; 3.3v-model1234// v-model const template = `&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;`// with(this)&#123;return _c(&#x27;input&#x27;,&#123;directives:[&#123;name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(name),expression:&quot;name&quot;&#125;],attrs:&#123;&quot;type&quot;:&quot;text&quot;&#125;,domProps:&#123;&quot;value&quot;:(name)&#125;,on:&#123;&quot;input&quot;:function($event)&#123;if($event.target.composing)return;name=$event.target.value&#125;&#125;&#125;)&#125; 看 on 后面的语句，主要是 input 已经绑定了 on 事件，触发的时候返回 name=$event.target.value，因为已经使用了 with 语法，所以 name 查找的是 this.name，只要变量更新就会触发新的渲染 3.Vue 组件中使用 render 代替 template不写 template 了 用 render来代替 12345678910111213141516171819// 假设 this.level = 1 // 意思就是 h1 标签 下面有一个子元素 a 标签——name 是 headerId， 链接是 &#x27;#&#x27; + &#x27;headerId&#x27;， text 是 &#x27;this is a tag&#x27;Vue.component(&#x27;heading&#x27;,&#123; // template: `xxxx ` render: function(createElement)&#123; return createElement( &#x27;h&#x27; + this.level, [ createElement(&#x27;a&#x27;, &#123; attrs: &#123; name: &#x27;headerId&#x27;, href: &#x27;#&#x27; + &#x27;headerId&#x27; &#125; &#125;, &#x27;this is a tag&#x27;) ] ) &#125;&#125;)","categories":[],"tags":[{"name":"模板编译","slug":"模板编译","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"}]},{"title":"Vue原理01","slug":"Vue原理01","date":"2021-12-23T07:14:03.000Z","updated":"2022-02-04T18:25:30.925Z","comments":true,"path":"2021/12/23/Vue原理01/","link":"","permalink":"http://example.com/2021/12/23/Vue%E5%8E%9F%E7%90%8601/","excerpt":"Vue原理从大方向上有三点：响应式、模板编译、Vdom，这一节主要内容为 响应式 和 Vdom","text":"Vue原理从大方向上有三点：响应式、模板编译、Vdom，这一节主要内容为 响应式 和 Vdom 1.组件化基础（MVVM模型） 数据驱动视图（MVVM 和 setState） 组件化在很久以前就已经有了，比如说 web 1.0 php 之类的，但是当时需要频繁操作 DOM，所以 jquery 比较流行（因为操作 DOM 很多）。传统组件只是静态渲染，更新还要依赖于操作 DOM。但是在 Vue 或者 React 中，只要修改数据就可以了，也就是更多的关注业务逻辑，可以实现很复杂的页面功能 Vue MVVM 模型图（画出来）Model-View-ViewModel DOM →vue （监听/指令） → 纯 javascript 对象 示例 123&lt;div&gt; &lt;p @click=&quot;changeName&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;/div&gt; 123456789data()&#123; return &#123; name: &quot;zhangsan&quot; &#125;, methods: &#123; changeName()&#123; this.name = &quot;lisi&quot; &#125; &#125; view: html 里的 DOM Model: data ViewModel: @click 和 methods （ViewModel 不好单独说是什么，但是总体上它就是 View 和 Model 之间的桥梁，model 修改了之后就可以修改 view ） 2.Vue 响应式（很重要）响应性是一种允许我们以声明式的方式去适应变化的编程范例。在 vue中，就是 data 的数据一旦变化，视图立马更新，这也是实现数据驱动视图的第一步 2.1 核心 API - Object.defineProperty深度监听 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 触发更新视图function updateView()&#123; console.log(&quot;视图更新&quot;);&#125;function defineReactive(target, key, value)&#123; // 深度监听 observer(value) // 核心 API Object.defineProperty(target, key ,&#123; get()&#123; return value &#125;, set(newValue)&#123; if(newValue !== value)&#123; observer(value) // 设置新值的时候，也需要监听，比如说我们 不写 data.age.num = 18 而是 data.age = &#123;num: 21&#125;,如果不设置那么就不能把 num 作为 key 传进来 // 设置新值 // value 一直在闭包中 value = newValue updateView() &#125; &#125; &#125;)&#125;// 监听对象属性function observer(target)&#123; // 只监听 对象或数组 if(typeof target !== &#x27;object&#x27; || target == null)&#123; return target &#125; // 重新定义各个属性 for(let key in target)&#123; defineReactive(target, key, target[key]) &#125;&#125;// 准备数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info:&#123; address:&#123; city: &#x27;beijing&#x27; // 需要深度监听 &#125; &#125;&#125;// 监听数据observer(data)// 测试data.name = &#x27;lisi&#x27;data.age = 18data.info.address.city = &#x27;shanghai&#x27;console.log(&#x27;age&#x27;,data.age);console.log(data.info.address.city); 2.2 Object.defineProperty 的一些缺点（3.0 启用 Proxy） 不管原数组/对象有多深，都需要一次性递归到底，计算量很大 无法监听新增属性/删除属性（Vue.set Vue.deletex） 不能原生监听数组，需要特殊处理 如果要监听数组，全局定义 1234567891011121314// 监听数组时，我们需要在外面单独声明一个原型，以免污染全局的原型链const oldArrayProperty = Array.prototype// Object.create 创建新对象，原型指向 oldArrayProperty，再扩展新的方法，不会影响原型// 比如说我们定义 function push()&#123;console.log(&#x27;push&#x27;)&#125; 和 arrProto.__proto__.push(4) // 前者调用自定义函数，后者是原型链上的属性，二者不矛盾const arrProto = Object.create(oldArrayProperty);[&#x27;push&#x27;, &#x27;splice&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;].forEach(methodeName =&gt;&#123; arrProto[methodeName] = function()&#123; updateView() oldArrayProperty[methodeName].call(this,...arguments) // 相当于 Array.prototype.push.call(this, ...arguments) &#125;&#125;) 同时要在修改 observer 函数 12345678910111213141516171819function observer(target) &#123; if (typeof target !== &#x27;object&#x27; || target === null) &#123; return target &#125; // 不可以把原型定义在函数里面，不然会污染全局的 Array 原型 // Array.prototype.push = function () &#123; // updateView() // ... // &#125; // 判断是不是数组 如果是 添加 __proto__ if (Array.isArray(target)) &#123; target.__proto__ = arrProto &#125; for (let key in target) &#123; defineReactive(target, key, target[key]) &#125;&#125; 3.虚拟DOM（virtual dom）和 diff（很重要）vdom 是实现 vue 和 react 的重要基石，diff 算法是 vdom 中最核心最关键的部分。我们都知道 DOM 操作很耗时，之前我们用 jquery 手动调整 DOM 操作，而 Vue 和 React 是数据驱动视图，技术复杂度下来了但是业务复杂度上去了，所以如何有效控制 DOM 操作仍然是一个重要课题。 3.1 解决方案-vdom复杂度上来了，想减少计算次数是不大可能的，但是我们可以把计算转移给 JS 来算，因为 JS 执行速度很快。进一步的，我们可以用 JS 来模拟 DOM 结构，计算出最小的变更来操作 DOM，这就叫 VDom。其中 diff 算法是最核心最关键的部分。 示例：用 VNode 来模拟下面这个片段 123456&lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt; &lt;p&gt;vdom&lt;/p&gt; &lt;ul style=&quot;font-size: 20px;&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 虚拟dom（示例，不一定都是这样写的，但是要写得出来这个结构） 有 tag props children 12345678910111213141516171819202122232425&#123; tag: &#x27;div&#x27;, props: &#123; className: &#x27;container&#x27;, id: &#x27;div1&#x27; &#125;, children: [ &#123; tag: &#x27;p&#x27;, children: &#x27;vdom&#x27; &#125;, &#123; tag: &#x27;ul&#x27;, props: &#123;style: &#x27;font-size: 20px&#x27;&#125;, children: [ &#123; tag: &#x27;li&#x27;, children: &#x27;a&#x27; &#125; // ... ] &#125; ] &#125; 通过 snabbdom 来学习 vdom 重点：h 函数（产生 vnode）、vnode 数据结构、patch 函数（两个参数都是node 或者 渲染和 node） patch函数的重点： patch(elem, vnode) and patch(vnode, newVnode) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; init, classModule, propsModule, styleModule, eventListenersModule, h,&#125; from &quot;snabbdom&quot;;const patch = init([ // Init patch function with chosen modules classModule, // makes it easy to toggle classes propsModule, // for setting properties on DOM elements styleModule, // handles styling on elements with support for animations eventListenersModule, // attaches event listeners]);const container = document.getElementById(&quot;container&quot;);// vnode const vnode = h(&quot;div#container.two.classes&quot;, &#123; on: &#123; click: someFn &#125; &#125;, [ h(&quot;span&quot;, &#123; style: &#123; fontWeight: &quot;bold&quot; &#125; &#125;, &quot;This is bold&quot;), &quot; and this is just normal text&quot;, h(&quot;a&quot;, &#123; props: &#123; href: &quot;/foo&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),]);// Patch into empty DOM element – this modifies the DOM as a side effectpatch(container, vnode);const newVnode = h( &quot;div#container.two.classes&quot;, &#123; on: &#123; click: anotherEventHandler &#125; &#125;, [ h( &quot;span&quot;, &#123; style: &#123; fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot; &#125; &#125;, &quot;This is now italic type&quot; ), &quot; and this is still just normal text&quot;, h(&quot;a&quot;, &#123; props: &#123; href: &quot;/bar&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;), ]);// 把 vnode 渲染到 container 上patch(container, vnode);// 更新数据const newVnode = h( &quot;div#container.two.classes&quot;, &#123; on: &#123; click: anotherEventHandler &#125; &#125;, [ h( &quot;span&quot;, &#123; style: &#123; fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot; &#125; &#125;, &quot;This is now italic type&quot; ), &quot; and this is still just normal text&quot;, h(&quot;a&quot;, &#123; props: &#123; href: &quot;/bar&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;), ]);// 更新已有的内容patch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state 3.2 diff算法**diff算法 ** 帮助vnode 计算出 DOM 最小的改变 diff 算法之前复杂度有 O(n^3) 这么多，后来经过优化达到了 O(n) 次方，主要是三点： 只比较同一层级，不跨级比较； 二：tag 不相同之间删掉重建，不再深度比较； 三：tag 和 key 二者相同时，则认为是相同节点，不再比较 3.3 snabbdom 源码解读其实不难，但是要花点心思 https://juejin.cn/post/6984049109267120136 patchVnode addVnodes removeVnos updateChildren函数( key 的重要性)","categories":[],"tags":[{"name":"组件化 响应式 vdom diff 模板编译 渲染过程 前端路由","slug":"组件化-响应式-vdom-diff-模板编译-渲染过程-前端路由","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%93%8D%E5%BA%94%E5%BC%8F-vdom-diff-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"}]},{"title":"Vue基础03","slug":"Vue基础03","date":"2021-12-22T06:17:56.000Z","updated":"2022-02-04T17:48:11.182Z","comments":true,"path":"2021/12/22/Vue基础03/","link":"","permalink":"http://example.com/2021/12/22/Vue%E5%9F%BA%E7%A1%8003/","excerpt":"Vue 的一些高级特性 自定义 v-model 、插槽、异步组件等","text":"Vue 的一些高级特性 自定义 v-model 、插槽、异步组件等 1.自定义 v-modelv-model 数据双向绑定，输入 input 的数据变化时，v-model 绑定的数据也会变化 定义一个 CustomVModel 组件 ，双向绑定的数据是 name 12345&lt;div&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;CustomVModel v-model=&quot;name&quot;/&gt; &lt;button @click=&quot;getName()&quot;&gt;名字&lt;/button&gt; &lt;/div&gt; 12345678910111213141516import CustomVModel from &#x27;./CustomVModel&#x27;export default&#123; components: &#123; CustomVModel &#125;, data()&#123; return&#123; name: &#x27;zhangsan&#x27; &#125; &#125;, methods:&#123; getName()&#123; console.log(this.name) &#125; &#125;&#125; 自定义的组件 CustomVModel : 实际上是一个 input， 拆分成了 value属性 和 input 事件 123456789&lt;input type=&quot;text&quot; :value=&quot;text&quot; @input=&quot;$emit(&#x27;change&#x27;, $event.target.value)&quot;&gt;&lt;!-- 1.上面的 input 使用了 :value 而不是 v-model 2. change 要和 model.event 里面的 change 对应 3. text 对应 model.prop 里面的 text --&gt; 1234567891011121314151617export default&#123; model: &#123; prop: &#x27;text&#x27; ,// 和 input 中的 :value 以及 props 中的 text 对应 event: &#x27;change&#x27; // 和 input 的 change 对应 &#125;, props: &#123; text: String, default()&#123; return &#x27;&#x27; &#125; &#125;, data()&#123; return &#123; &#125; &#125;&#125; 2.$nextTickVue 是异步而不是同步渲染，所以当 data 改变后，DOM 不会立即渲染 $nextTick 会在 DOM 渲染之后触发，以获取最新 DOM 节点 以下这段代码就是说：向 list 里 push 元素后，我们立马拿到元素长度，只能拿到渲染以前的不能拿到最新的；而 $nextTick 会在 DOM 渲染后才开始执行，所以在 $nextTick 里面执行才能获得最新的长度 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;!-- ref 属性是为了可以获得 DOM 节点 --&gt; &lt;ul ref=&quot;ul1&quot;&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;addItem&quot;&gt;添加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return &#123; list: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125; &#125;, methods: &#123; addItem()&#123;// 由于 vue 是异步渲染的，所以这里的 data 不管改变多少次，vue 都只会在 data 全部修改完之后进行一次渲染 this.list.push(`$&#123;Date.now()&#125;`) this.list.push(`$&#123;Date.now()&#125;`) this.list.push(`$&#123;Date.now()&#125;`) const ulElem = this.$refs.ul1 console.log(&#x27;没有nextTick时 &#x27;+ ulElem.childNodes.length); this.$nextTick(()=&gt;&#123; const ulElem = this.$refs.ul1 console.log(&#x27;有nextTick时 &#x27;+ ulElem.childNodes.length); &#125;) &#125; &#125; &#125;&lt;/script&gt; 3.slot (很常用)3.1基本使用 父组件往子组件中插入一段内容 index 12345&lt;div&gt; &lt;SlotDemo :url=&quot;website.url&quot;&gt; &#123;&#123;website.title&#125;&#125; &lt;/SlotDemo&gt;&lt;/div&gt; 1234567891011121314151617import SlotDemo from &#x27;./SlotDemo&#x27;export default&#123; components: &#123; SlotDemo &#125;, data()&#123; return&#123; name:&#x27;zhangsan&#x27;, website:&#123; title:&#x27;百度&#x27;, url:&#x27;https://www.baidu.com/&#x27;, subTitle: &#x27;全球中文第一搜索引擎&#x27; &#125; &#125; &#125;&#125; SlotDemo 1234567&lt;div&gt; &lt;a :href=&quot;url&quot;&gt; &lt;slot&gt; 接收父组件的内容，如果父组件没有传的话，就默认显示这一行 &lt;/slot&gt; &lt;/a&gt;&lt;/div&gt; 123456export default&#123; props: [&#x27;url&#x27;], data()&#123; return &#123;&#125; &#125;&#125; 3.2作用域插槽父组件可以通过插槽拿到子组件的数据 12345678910111213141516171819202122232425262728293031323334// index&lt;template&gt; &lt;div&gt; &lt;ScopedSlot :url = &quot;website.url&quot;&gt; &lt;!-- 注意里面要写 template 标签 v-slot 绑定的名字也随意 --&gt; &lt;template v-slot=&quot;slotProps&quot;&gt; &lt;!-- 这样父组件可以拿到子组件的 title --&gt; &#123;&#123;slotProps.slotData.title&#125;&#125; &lt;/template&gt; &lt;/ScopedSlot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ScopedSlot from &#x27;./ScopedSlot&#x27;export default&#123; components: &#123; ScopedSlot &#125;, data()&#123; return&#123; name:&#x27;zhangsan&#x27;, website:&#123; title:&#x27;百度&#x27;, url:&#x27;https://www.baidu.com/&#x27;, subTitle: &#x27;全球中文第一搜索引擎&#x27; &#125; &#125; &#125;&#125; &lt;/script&gt; ScopedSlot 12345678910111213141516171819202122232425&lt;template&gt; &lt;a :href=&quot;url&quot;&gt; &lt;!-- 定义一个动态属性（属性名随意） 绑定组件的数据 --&gt; &lt;slot :slotData=&quot;website&quot;&gt; &#123;&#123;website.subTitle&#125;&#125; &lt;!-- 默认值显示 subTitle ，即父组件不传内容时 --&gt; &lt;/slot&gt; &lt;/a&gt;&lt;/template&gt;&lt;script&gt; export default&#123; props: [&#x27;url&#x27;], data()&#123; return&#123; website:&#123; title:&#x27;谷歌&#x27;, url:&#x27;https://www.google.com/&#x27;, subTitle: &#x27;全球英文第一搜索引擎&#x27; &#125; &#125; &#125; &#125;&lt;/script&gt; 效果 3.3具名插槽组件 4.动态异步组件4.1动态组件不是很常用，但是也有可能考到。 格式：:is= &quot;component-name&quot; 应用场景：比如说渲染新闻页面，有文字，图片，视频等，但不确定究竟是什么类型时，就需要用到动态组件去渲染 代码演示： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;div v-for=&quot;(val,key) in newsData&quot; :key=&quot;key&quot;&gt; &lt;!-- 根据类型是什么来渲染 --&gt; &lt;!-- 动态组件 component 作为组件名 :is(必须是动态属性) 后面是我们想要动态渲染的组件名 --&gt; &lt;component :is=&quot;val.type&quot;/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; data()&#123; return&#123; newsData: &#123; // 有不同的 type 所以要渲染这些数据、节点的方法也不尽相同 1:&#123; type: &quot;text&quot; &#125;, 2:&#123; type: &quot;vedio&quot; &#125;, 3:&#123; type: &quot;image&quot; &#125; &#125; &#125; &#125;&#125; &lt;/script&gt; 4.2异步组件 (很常用)按需加载: 使用import() 函数，异步加载大组件 假设有一个比较大的表单组件，名为 FormDemo，我们不需要它在一开始就加载出来，而是用户点击时才加载，那么就需要使用异步组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;!-- 异步组件 --&gt; &lt;FormDemo v-if=&quot;showFormDemo&quot;/&gt; &lt;button @click=&quot;showFormDemo = true&quot;&gt;show FormDemo&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; components: &#123; // 当用户点击时 showFormDemo 才变为 true，此时我们才 import 该组件 FormDemo: () =&gt; import(&#x27;../BaseUse/FormDemo&#x27;) &#125;, data()&#123; return&#123; showFormDemo: false &#125; &#125;&#125;&lt;/script&gt; 5.keep-alive 缓存组件 需要频繁切换但是渲染不变的情况 Vue 常见性能优化 假设有三个需要频繁切换的组件，如果不用 keep-alive，切换一次就会渲染一次新组件 并且 destory 上一个组件 KeepAlive组件 1234567891011121314151617181920212223242526272829303132333435// 功能：点击不同按钮显示对应组件&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;ChangeState(&#x27;A&#x27;)&quot;&gt;A&lt;/button&gt; &lt;button @click=&quot;ChangeState(&#x27;B&#x27;)&quot;&gt;B&lt;/button&gt; &lt;button @click=&quot;ChangeState(&#x27;C&#x27;)&quot;&gt;C&lt;/button&gt; &lt;KeepAliveA v-if=&quot;state === &#x27;A&#x27; &quot;/&gt; &lt;KeepAliveB v-if=&quot;state === &#x27;B&#x27; &quot;/&gt; &lt;KeepAliveC v-if=&quot;state === &#x27;C&#x27; &quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import KeepAliveA from &#x27;./KeepAliveA&#x27;import KeepAliveB from &#x27;./KeepAliveB&#x27;import KeepAliveC from &#x27;./KeepAliveC&#x27; export default&#123; components: &#123; KeepAliveA, KeepAliveB, KeepAliveC &#125;, data()&#123; return&#123; state: &#x27;A&#x27; &#125; &#125;, methods: &#123; ChangeState(state)&#123; this.state = state &#125; &#125; &#125;&lt;/script&gt; KeepAliveA （其它两个差不多） 123456789101112131415&lt;template&gt; &lt;p&gt;A&lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default&#123; mounted()&#123; console.log(&#x27;A is mounted&#x27;); &#125;, destroyed()&#123; console.log(&#x27;A is desoryed&#x27;); &#125; &#125;&lt;/script&gt; 如果我们单纯引入 KeepAliveA、B、C 组件 123&lt;KeepAliveA v-if=&quot;state === &#x27;A&#x27; &quot;/&gt;&lt;KeepAliveB v-if=&quot;state === &#x27;B&#x27; &quot;/&gt;&lt;KeepAliveC v-if=&quot;state === &#x27;C&#x27; &quot;/&gt; 那么我们切换的时候，组件就会连续销毁旧的渲染新的，影响性能 如果包裹在 &lt;keep-alive&gt; 标签中，就能一直保持 mounted 的状态 12345&lt;keep-alive&gt; &lt;KeepAliveA v-if=&quot;state === &#x27;A&#x27; &quot;/&gt; &lt;KeepAliveB v-if=&quot;state === &#x27;B&#x27; &quot;/&gt; &lt;KeepAliveC v-if=&quot;state === &#x27;C&#x27; &quot;/&gt; &lt;/keep-alive&gt; 6.mixin6.1优势 多个组件有相同逻辑的时候，抽离出来 比如说这个例子，city 属性并没有在当前组件定义，而是引用了抽离出来的 JS 的，而且不仅属性可以抽离，方法也可以 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;name&#125;&#125; &#123;&#123;grade&#125;&#125; &#123;&#123;city&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import mixin from &#x27;./mixin&#x27; export default&#123; // 共同逻辑 JS 文件的注册方法 mixins:[mixin], data()&#123; return &#123; name: &#x27;zhangsan&#x27;, grade: &#x27;second&#x27; &#125; &#125;, mounted()&#123; console.log(&#x27;MixinDemo mounted&#x27;); &#125; &#125;&lt;/script&gt; mixin.js 文件 12345678910export default&#123; data()&#123; return &#123; city: &#x27;beijing&#x27; &#125; &#125;, mounted()&#123; console.log(&#x27;mixinJs mounted&#x27;); &#125;&#125; 效果 属性和方法逻辑都被读取到了 6.2问题 来源不明确 多 mixin 肯会造成命名冲突 mixin 和 组件可能造成多对多关系，复杂度变高 7.Vuexvuex 是 vue 配套的公共数据管理工具，可以将要共享的数据保存到 vuex 中，方便整个程序中的任何组件都能够获得和修改公共数据 修改共享数据：在 mutations 中定义 https://vuex.vuejs.org/zh/ 8.vue-routerhttps://router.vuejs.org/zh/ 8.1路由模式 hash 模式，如 http://abc.com/#/user/10 H5 history 模式 http://abc.com/user/20 后端需要 server 支持 8.2 动态路由8.3懒加载异步加载","categories":[],"tags":[{"name":"vue2 高级特性","slug":"vue2-高级特性","permalink":"http://example.com/tags/vue2-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}]},{"title":"Vue基础02","slug":"Vue基础02","date":"2021-12-21T11:32:35.000Z","updated":"2022-02-04T17:28:25.683Z","comments":true,"path":"2021/12/21/Vue基础02/","link":"","permalink":"http://example.com/2021/12/21/Vue%E5%9F%BA%E7%A1%8002/","excerpt":"Vue 的组件使用以及生命周期","text":"Vue 的组件使用以及生命周期 1.组件使用1.1 props 和 $emit1.2 组件间通讯-自定义事件 父子之间：父到子，传递数据；子到父，触发事件 兄弟之间用自定义事件通讯 Vuex 1.3 组件生命周期（要自己画出来） 挂载阶段 到 mounted 问：created 和 mounted 有什么区别？ 更新阶段 到 updated 销毁阶段 最后两个 1.4 带有父子组件的生命周期1.加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted 2.子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 3.父组件更新过程父beforeUpdate-&gt;父updated 4.销毁过程父beforeUnmount-&gt;子beforeUnmount-&gt;子unmounted-&gt;父unmounted PS：之前的 beforeDestory 和destoryed 对应beforeUnmount 和 unmounted","categories":[],"tags":[{"name":"Vue组件 生命周期","slug":"Vue组件-生命周期","permalink":"http://example.com/tags/Vue%E7%BB%84%E4%BB%B6-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"Vue基础01","slug":"Vue基础01","date":"2021-12-20T01:20:05.000Z","updated":"2022-02-04T17:16:23.905Z","comments":true,"path":"2021/12/20/Vue基础01/","link":"","permalink":"http://example.com/2021/12/20/Vue%E5%9F%BA%E7%A1%8001/","excerpt":"Vue 的指令、插值等基础的知识汇总","text":"Vue 的指令、插值等基础的知识汇总 1.指令，插值（1）插值、表达式 （2）指令、动态属性 123456v-bind:title = &#x27;message&#x27; //绑定元素 attribute 简写 ：v-if = &#x27;condition&#x27; // 条件语句v-for = &quot;(index, item) in list&quot; // 循环 注意要有 :key = &quot;&quot; 绑定 keyv-on:click=&quot;reverseMessage&quot; // 绑定事件 简写 @v-model // 实现表单输入和应用状态之间的双向绑定 123456// eg v-model&lt;div id=&quot;two-way-binding&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot; /&gt;&lt;/div&gt; 12345678const TwoWayBinding = &#123; data() &#123; return &#123; message: &#x27;Hello Vue!&#x27; &#125; &#125;&#125;Vue.createApp(TwoWayBinding).mount(&#x27;#two-way-binding&#x27;) （3）v-html：绑定的数据可以是富文本，但是有XSS风险，会覆盖子组件 v-html更新的是元素的 innerHTML 。内容按普通 HTML 插入， 不会作为 Vue 模板进行编译 。 XSS风险：https://blog.csdn.net/lj1530562965/article/details/108790220 2.computed 和 watch（1）computed 有缓存，data 不变则不会重新计算 12345678910111213141516171819202122var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // =&gt; 2vm.aPlus = 3 // 注意这里是 set 也就是 v = 3vm.a // =&gt; 2vm.aDouble // =&gt; 4 （2）watch 如何进行深度监听？ watch 里面有 handler 函数、 immediate 属性、deep 属性（默认值是 false，代表是否深度监听） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const app = createApp(&#123; data() &#123; return &#123; a: 1, b: 2, c: &#123; d: 4 &#125;, e: 5, f: 6 &#125; &#125;, watch: &#123; // 侦听顶级 property a(val, oldVal) &#123; console.log(`new: $&#123;val&#125;, old: $&#123;oldVal&#125;`) &#125;, // 字符串方法名 b: &#x27;someMethod&#x27;, // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler(val, oldVal) &#123; console.log(&#x27;c changed&#x27;) &#125;, deep: true &#125;, // 侦听单个嵌套 property &#x27;c.d&#x27;: function (val, oldVal) &#123; // do something &#125;, // 该回调将会在侦听开始之后被立即调用 e: &#123; handler(val, oldVal) &#123; console.log(&#x27;e changed&#x27;) &#125;, immediate: true &#125;, // 你可以传入回调数组，它们会被逐一调用 f: [ &#x27;handler1&#x27;, function handle2(val, oldVal) &#123; console.log(&#x27;handler2 triggered&#x27;) &#125;, &#123; handler: function handle3(val, oldVal) &#123; console.log(&#x27;handler3 triggered&#x27;) &#125; /* ... */ &#125; ] &#125;, methods: &#123; someMethod() &#123; console.log(&#x27;b changed&#x27;) &#125;, handler1() &#123; console.log(&#x27;handle 1 triggered&#x27;) &#125; &#125;&#125;)const vm = app.mount(&#x27;#app&#x27;)vm.a = 3 // =&gt; new: 3, old: 1 123456789watch: &#123; obj: &#123; handler(newVal, oldVal) &#123; console.log(&#x27;obj.a changed&#x27;); &#125;, immediate: true, deep: true &#125;&#125; 这样只要 obj 改变就都会深度监听，开销大 优化，只对 obj.a 进行深度监听 123456789watch: &#123; &#x27;obj.a&#x27;: &#123; handler(newVal, oldVal) &#123; console.log(&#x27;obj.a changed&#x27;); &#125;, immediate: true, deep: true &#125;&#125; （3）watch 监听引用类型，因为指针是一样的所以拿不到oldVal， 1234&lt;div&gt; &lt;input v-model=&quot;name&quot;&gt; &lt;input v-model=&quot;info.city&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122export default&#123; data()&#123; return &#123; name: &#x27;zhangsan&#x27;, // 值类型监听可以直接拿到值 info: &#123; city: &#x27;Guangzhou&#x27; // 引用类型不可以 &#125; &#125; &#125;, watch: &#123; name(oldVal, val)&#123; console.log(&#x27;watch name&#x27;,oldVal, val); &#125;, info: &#123; handler(oldVal, val) &#123; console.log(&#x27;watch info&#x27;, oldVal, val) // 引用类型，拿不到 oldVal 。因为指针相同，此时已经指向了新的 val,info 改了可以监听到，但是 info里面的就不行了 &#125;, deep: true // 深度监听 &#125; &#125;&#125; 3.class 和 style（1）使用动态属性 v-bind 来绑定 class 和 style，表达式结果的类型除了字符串之外，还可以是对象或数组。 123456// 比较常见的用法 &lt;div&gt; &lt;p :class=&quot;&#123;black: isBlack,yellow: isYellow&#125;&quot;&gt;使用class&lt;/p&gt; &lt;p :class=&quot;[black,yellow]&quot;&gt;使用 class （数组）&lt;/p&gt; &lt;p :style=&quot;styleData&quot;&gt;使用 style&lt;/p&gt; &lt;/div&gt; 12345678910111213141516171819export default &#123; data() &#123; return &#123; isBlack: true, isYellow: true, black: &#x27;black&#x27;, yellow: &#x27;yellow&#x27;, styleData: &#123; fontSize: &#x27;40px&#x27;, color: &#x27;red&#x27;, backgroundColor: &#x27;#ccc&#x27; &#125; &#125; &#125;&#125; 12345678&lt;style scoped&gt; .black &#123; background-color: #999; &#125; .yellow&#123; color: yellow; &#125;&lt;/style&gt; （2）注意多个单词用使用驼峰命名法 4.条件渲染（1）v-if v-else 的用法 可以使用变量，也可以使用 === 表达式 （2）v-if 和 v-show 的区别 v-if不渲染DOM； v-show DOM树上还是有，只是 display: none （3）v-if和 v-show 的使用场景 更新频率不高，就用 v-if； 切换得比较频繁就用 v-show 123456&lt;div&gt; &lt;p v-show=&quot;type === &#x27;a&#x27;&quot;&gt;v-show a&lt;/p&gt; &lt;p v-show=&quot;type === &#x27;b&#x27;&quot;&gt;v-show b&lt;/p&gt; &lt;p v-if=&quot;type === &#x27;a&#x27;&quot;&gt;v-if a&lt;/p&gt; &lt;p v-if=&quot;type === &#x27;b&#x27;&quot;&gt;v-if b&lt;/p&gt; &lt;/div&gt; 1234567export default &#123; data()&#123; return &#123; type: &#x27;a&#x27; &#125; &#125;&#125; DOM 节点情况 5.循环（列表）渲染（1）可以用 v-for 来遍历对象 （2）key 的重要性: 用 v-for 需要用 key ，而且不能乱写 key （3）注意 v-if 和 v-for 不建议一起写 因为 v-for 相当于一个循环体，如果结构里面添加了 v-if 那么每一次循环都要判断一次，很浪费资源 12345678910111213141516&lt;div&gt; &lt;p&gt;遍历数组&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in listArr&quot; :key=&quot;item.id&quot; &gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item.id&#125;&#125;-&#123;&#123;item.tittle&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;遍历对象&lt;/p&gt; // v-if 不要和 v-for 写在一起 &lt;ul v-if=&quot;flag&quot;&gt; &lt;li v-for=&quot;(val,index,key) in listObj&quot; :key=&quot;key&quot;&gt; &#123;&#123;index&#125;&#125; - &#123;&#123;key&#125;&#125; - &#123;&#123;val.title&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718192021export default&#123; data()&#123; return&#123; flag: false, listArr: [ // id 作为 key 比较合适 &#123;id : &#x27;a&#x27;, title: &#x27;标题1&#x27;&#125;, &#123;id : &#x27;b&#x27;, title: &#x27;标题2&#x27;&#125;, &#123;id : &#x27;c&#x27;, title: &#x27;标题3&#x27;&#125; ], listObj: &#123; // 本身的 key 就可以作为遍历的 key a:&#123;title: &#x27;标题1&#x27;&#125;, b:&#123;title: &#x27;标题2&#x27;&#125;, c:&#123;title: &#x27;标题3&#x27;&#125; &#125; &#125; &#125;&#125; 6.事件（1） event 是原生的 有时我们需要访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： 123&lt;button v-on:click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt; Submit&lt;/button&gt; 12345678910// ...methods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) &#123; event.preventDefault() &#125; alert(message) &#125;&#125; （2）事件被挂载到当前元素上 12345&lt;div&gt; &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;increment1&quot;&gt; + 1&lt;/button&gt; &lt;button @click=&quot;increment2(2,$event)&quot;&gt; + 2&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617 methods: &#123; // 如果只需要 event 参数，绑定的时候可以只写个函数名 increment1()&#123; console.log(&#x27;event&#x27;,event,event.__proto__.constructor); // constructor 是原生的 event 对象 console.log(&#x27;event&#x27;,event,event.target); console.log(&#x27;event&#x27;,event,event.currentTarget); // 事件挂载在当前元素上 和 react 是不同的 this.num++ &#125;, // 如果需要别的参数，那么绑定的时候函数里要把参数写全了 increment2(val,event)&#123; console.log(event.targrt); this.num += val &#125; &#125;&#125; 7.事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。 .stop .prevent .capture .self .once .passive 1234567891011121314&lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop=&quot;doSomething&quot;&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=&quot;doSomething&quot;&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件监听器使用事件捕获模式 --&gt; &lt;!-- 即内部元素触发的事件先在此处理，然后再交由内部元素进行处理 --&gt; &lt;div v-on:click.capture=&quot;doSomething&quot;&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self=&quot;doSomething&quot;&gt;...&lt;/div&gt; 8.按键修饰符1234568&lt;!-- 即使 Alt 和 Shift 被一同按下时也会被触发 --&gt; &lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt; &lt;!-- 有且只有当 Ctrl 被按下时才会被触发 --&gt; &lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt; &lt;!-- 没有任何系统修饰符被按下时才会被触发 --&gt; &lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; 9.表格（用 v-model 绑定数据）9.1 输入元素v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 9.2 对于复选框单个复选框，绑定到布尔值 多个复选框，绑定到同一个数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div&gt; &lt;p&gt;输入框: &#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;name&quot;/&gt; // 截取 &lt;input type=&quot;text&quot; v-model.lazy=&quot;name&quot;/&gt; // 防抖 &lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;/&gt; // 转换为数字 &lt;p&gt;多行文本: &#123;&#123;desc&#125;&#125;&lt;/p&gt; &lt;textarea v-model=&quot;desc&quot;&gt;&lt;/textarea&gt; // 用 v-model 来实现输入框 &lt;!-- 注意，&lt;textarea&gt;&#123;&#123;desc&#125;&#125;&lt;/textarea&gt; 是不允许的！！！ --&gt; &lt;p&gt;复选框 &#123;&#123;checked&#125;&#125;&lt;/p&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;/&gt; &lt;p&gt;多个复选框 &#123;&#123;checkedNames&#125;&#125;&lt;/p&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;p&gt;单选 &#123;&#123;gender&#125;&#125;&lt;/p&gt; &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;male&quot; v-model=&quot;gender&quot;/&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;female&quot; v-model=&quot;gender&quot;/&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;p&gt;下拉列表选择 &#123;&#123;selected&#125;&#125;&lt;/p&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;p&gt;下拉列表选择（多选） &#123;&#123;selectedList&#125;&#125;&lt;/p&gt; &lt;select v-model=&quot;selectedList&quot; multiple&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; name: &#x27;zhangsan&#x27;, age: 18, desc: &#x27;自我介绍&#x27;, checked: true, checkedNames: [], gender: &#x27;male&#x27;, selected: &#x27;&#x27;, selectedList: [] &#125; &#125;&#125;&lt;/script&gt;","categories":[],"tags":[{"name":"Vue2 基础知识","slug":"Vue2-基础知识","permalink":"http://example.com/tags/Vue2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"JS的一些简单手写题","slug":"JS的一些简单手写题","date":"2021-12-17T12:39:56.000Z","updated":"2022-01-30T14:30:04.124Z","comments":true,"path":"2021/12/17/JS的一些简单手写题/","link":"","permalink":"http://example.com/2021/12/17/JS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%89%8B%E5%86%99%E9%A2%98/","excerpt":"为了方便查找，我把 JS 的一些简单手写题做了一个汇总。 这些题目比较小，但是细节多，需要时时复习","text":"为了方便查找，我把 JS 的一些简单手写题做了一个汇总。 这些题目比较小，但是细节多，需要时时复习 1.手写深拷贝在JavaScript中，数组和对象都是引用类型，直接复制的是地址，所以需要深度拷贝以便修改不影响原来的数组或对象。主要运用到递归 1234567891011121314151617181920212223242526272829303132333435function deepClone(obj)&#123; // 先判断结果应该是 数组 还是 对象 let res = obj instanceof Array? []:&#123;&#125; // 递归终止条件 if(typeof(obj)!==&#x27;object&#x27; || obj == null)&#123; return obj &#125; for(let key in obj)&#123; // hasOwnProperty 返回一个布尔值，表示自身属性中是否具有指定的键，用在这里是为了多层的情况考虑 if(obj.hasOwnProperty(key))&#123; res[key] = deepClone(obj[key]) &#125; &#125; return res&#125;let obj1 = &#123; address:&#123; city: &#123; name:&quot;beijing&quot; &#125; &#125;&#125;// hasOwnProperty 介绍console.log(obj1.hasOwnProperty(&#x27;address&#x27;));// expected output: trueconsole.log(obj1.address.city.hasOwnProperty(&#x27;name&#x27;));// expected output: trueconsole.log(obj1.address.city.hasOwnProperty(&#x27;code&#x27;));// expected output: false// testlet obj2 = deepClone(obj1);obj2.address.city.name = &quot;Shanghai&quot;;console.log(obj1.address.city.name);console.log(obj2.address.city.name); 2.手写深度比较 （简单版）网上深度比较有很多的代码，简单的也有，复杂的也有，但是复杂的考虑得太全面了，考虑到我当前水平，还是简洁一点的比较适合我 我对这段代码主要是两个问题： 一是网上很多在判断的地方有一段代码： 判断是否传入同一个对象 123if(obj1 === obj2)&#123; return true &#125; 一开始我本地跑了好几次也没有用上过这段，所以就删掉了。 后来我想了想才发现，因为我们在写代码的时候，要从用户的角度出发，也就是我们不知道用户到底会传什么进来，有可能两个参数传递是一个对象，所以这段代码就是为了应对这种情况，不需要再浪费时间遍历递归去比较，还是很有必要的 还有一段是：判断任意一个不为引用类型的时候是否相等，大家都用的 || 123if(!isObject(obj1)&amp;&amp;!isObject(obj2))&#123; return obj1 === obj2 &#125; 这我也觉得很奇怪，如果一个是对象一个不是，那不是全部都是 false 吗？ 后来我换成 &amp;&amp; 试了一下，发现也是正确的，只是走的路径不一样。所以这里 || 或者 &amp;&amp; 应该都是正确的 1234567891011121314151617181920212223242526272829// 另写一个函数 判断是否为 不为空的对象或数组function isObject(obj)&#123; return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null&#125;function isEqual(obj1,obj2)&#123; // 递归终止条件 if(!isObject(obj1)||!isObject(obj2))&#123; return obj1 === obj2 &#125; if(obj1 === obj2)&#123; return true &#125; // 获取所有属性 const obj1Keys = Object.keys(obj1) const obj2Keys = Object.keys(obj2) if(obj1Keys.length !== obj2Keys.length)&#123; return false &#125; // 递归比较 for(let key in obj1)&#123; const res = isEqual(obj1[key],obj2[key]) if(!res)&#123; return false &#125; &#125; return true&#125; 3.手写 Promise 异步加载图片1234567891011121314151617181920212223const loadImage= (url)=&gt;&#123; const img = document.createElement(&#x27;img&#x27;) return new Promise((resolve,reject)=&gt;&#123; img.onload = ()=&gt;&#123; console.log(&#x27;test&#x27;) resolve(img) &#125; img.onerror = ()=&gt;&#123; const err = new Error(&#x27;could not load image at&#x27; + url) reject(err) &#125; img.src = url &#125;)&#125;// test loadImg(url).then(img=&gt;&#123; console.log(img.width); return img&#125;).then(img=&gt;&#123; console.log(img.height);&#125;).catch(ex =&gt;&#123; console.error(ex)&#125;) 4.promise 实现 Ajax （手写 Ajax）前置知识：需要知道 XMLHttpRequest 的一些基础知识，readyState、status 状态码 以及 post send 等方法 123456789101112131415161718192021222324252627282930// 手写 ajax// return 一个 promise 参数 xhr.open xhr.send xhr.onreadystatechangefunction ajax(url)&#123; const p = new Promise((resolve,reject)=&gt;&#123; const xhr = new XMLHttpRequest() xhr.open(&#x27;GET&#x27;,url) xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; resolve( JSON.parse(xhr.responseText) ) &#125; else if(xhr.status === 404)&#123; reject(new Error(&#x27;404 not found&#x27;)) &#125; &#125; &#125; xhr.send(null) &#125;) return p&#125;const url = &#x27;/data/test.json&#x27; ajax(url).then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.error(err)&#125;) 5. 手写防抖防抖的功能是用户不停就不执行，等用户停了再操作。用户怎么才算停呢？delay 这么长的时间内都没有触发事件发生就算停了。比如说用户连续输入，需要等用户输入停止一段时间后再打印或者传输数据 12345678910111213141516function debounce(fn,delay)&#123; let timer = null return function()&#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(()=&gt;&#123; // 把 fn 的 this 改成触发元素触发 fn.apply(this,arguments) timer = null &#125;,delay) &#125;&#125;inp1.addEventListener(&#x27;keyup&#x27;,debounce(function()&#123; console.log(inp1.value);&#125;,500)) 6.手写节流1234567891011121314151617const div1 = document.getElementById(&#x27;div1&#x27;)function throttle(fn,delay)&#123; let timer = null; return function()&#123; if(timer)&#123; return &#125; timer = setTimeout(()=&gt;&#123; fn.apply(this,arguments) timer = null &#125;,delay) &#125;&#125;div1.addEventListener(&#x27;drag&#x27;,throttle(function(e)&#123; console.log(e); console.log(e.offsetX);&#125;,1000))","categories":[],"tags":[{"name":"深拷贝 简单深比较","slug":"深拷贝-简单深比较","permalink":"http://example.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E7%AE%80%E5%8D%95%E6%B7%B1%E6%AF%94%E8%BE%83/"}]},{"title":"前端面试真题-part5","slug":"前端面试真题-part5","date":"2021-12-15T14:05:42.000Z","updated":"2021-12-17T12:03:19.267Z","comments":true,"path":"2021/12/15/前端面试真题-part5/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part5/","excerpt":"主要内容：Map Set 有序和无序 数组reduce求和","text":"主要内容：Map Set 有序和无序 数组reduce求和 1-part11） Map 和 Set 有序和无序 有序慢，无序快。但是无序本身就是一个缺点。比如说 v-dom里面，object什么的可以无序排列，但是数组必须是有序的。不然渲染过程会出现问题 可以结合二者优点：二叉树及其变种 2）Map 和 Object 区别 API 不同（略过，比较简单），Map可以以任意类型为 key 1234567function fn()const obj = &#123;&#125;let m = new Map()m.set(fn,&#x27;fn key&#x27;) m.set(obj,&#x27;obj key&#x27;)// 如果说是 Objectobj.fn() =&#x27;XXX&#x27; h// 报错 object 只能以 字符串为 key Map 是有序结构（重要） 12345678910111213let map = new Map([ [&#x27;key1&#x27;,&#x27;1&#x27;], [&#x27;key2&#x27;,&#x27;2&#x27;], [&#x27;key3&#x27;,&#x27;3&#x27;] ]) map.forEach((value,key)=&gt;&#123; console.log(key,value)&#125;) // key1 1// key2 2// key3 3// 如果把 map 的顺序改了 输出的顺序也会改 Map 操作同样很快 对比无序结构object 的 查找和删除操作 map 甚至会更快一点。 123456789101112131415161718192021const obj = &#123;&#125;for(let i = 0;i&lt;1000*1000;i++)&#123; obj[i+&#x27;&#x27;] = i&#125;console.time(&#x27;obj find&#x27;);obj[&#x27;500000&#x27;]console.timeEnd(&#x27;obj find&#x27;);console.time(&#x27;obj delete&#x27;);delete obj[&#x27;500000&#x27;]console.timeEnd(&#x27;obj delete&#x27;);const map = new Map()for(let i = 0;i&lt;1000*1000;i++)&#123; map.set(i+&#x27;&#x27;,i)&#125;console.time(&#x27;map find&#x27;);map.has(&#x27;500000&#x27;)console.timeEnd(&#x27;map find&#x27;);console.time(&#x27;map delete&#x27;);map.delete(&#x27;500000&#x27;)console.timeEnd(&#x27;map delete&#x27;); 3）Set 和 数组的区别 API 不同 123456const set = new Set([10,20,30])set.add(50)set.delete(20)set.has(30)set.sizeser.forEach(val=&gt; console.log(val)) // 无序结构 没有index Set 元素不能重复 Set 是无序结构，操作很快，和上面的代码差不多 1234567891011121314 // 数组比较慢 尤其是查找let arr = [10,20,30]for(let i = 0;i&lt;1000*1000;i++)&#123; arr[i] = i&#125;console.time(&#x27;arr push&#x27;);arr.push(&#x27;a&#x27;)console.timeEnd(&#x27;arr push&#x27;);console.time(&#x27;arr unshift&#x27;);arr.unshift(&#x27;b&#x27;)console.timeEnd(&#x27;arr unshift&#x27;);console.time(&#x27;arr includes&#x27;);arr.includes(100000)console.timeEnd(&#x27;arr includes&#x27;); 123456789101112// set 就快很多let set = new Set([10,20,30])for(let i = 0;i&lt;1000*1000;i++)&#123; set.add(i)&#125;console.time(&#x27;set add&#x27;);set.add(&#x27;a&#x27;)console.timeEnd(&#x27;set add&#x27;); console.time(&#x27;set has&#x27;);set.has(100000)console.timeEnd(&#x27;set has&#x27;); 4）WeakMap 和 WeakSet 弱引用，防止内存泄漏 ​ 可以随意添加信息，但是执行完了之后，对象就被销毁了，不用考虑是否还需要引用这些对象 WeakMap 只能用对象作为 key ，WeakSet 只能用 对象作为 value 没有 forEach 和 size ，只能用 add has delete 5）数组求和- Array reduce12345678910let arr = [1,2,3,4]// 比较简单易读，但是会多一个变量function sum(arr)&#123; let res = 0 for(let i = 0;i&lt;arr.length;i++)&#123; res += arr[i] &#125; return res&#125;console.log(sum(arr)); Array reduce 数组的拼接 计数什么的都很好用 123456789101112let arr = [1,2,3,4]const sum = arr.reduce((sum,curVal,index,arr)=&gt;&#123; console.log(&#x27;reduce function&#x27;); console.log(&#x27;sum&#x27;,sum); console.log(&#x27;curVal&#x27;,curVal); console.log(&#x27;index&#x27;,index); console.log(&#x27;arr&#x27;,arr); return sum + curVal&#125;,0) console.log(&#x27;final sum&#x27;,sum);","categories":[],"tags":[]},{"title":"前端面试真题-part4","slug":"前端面试真题-part4","date":"2021-12-15T12:37:06.000Z","updated":"2021-12-17T12:04:15.005Z","comments":true,"path":"2021/12/15/前端面试真题-part4/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part4/","excerpt":"主要内容：捕获异常，JSON ，获取 URL 参数，手写深拷贝","text":"主要内容：捕获异常，JSON ，获取 URL 参数，手写深拷贝 1-part11）如何捕获 JS 程序中的异常solution1 手动捕获(比较长的一串，所以用在高风险区域) 1234567try&#123; // todo&#125;catch(ex)&#123; console.error(ex)&#125;finally&#123; // todo&#125; solution 2 自动捕获 1234window.onerror = function(message,source,linNum,colNum,error)&#123; // 第一 对于跨域的 js ，比如 CDN 的，不会有详细的报错信息 // 第二，对于压缩的 js ，还要配合 sourceMap 反差到未压缩代码的行、列&#125; 2）什么是 JSON JSON 是一种数据格式，本质是一段字符串 JSON 格式和 js 对象结构一致，对 JS 语言更友好 window.JSON 是一个全局对象：JSON.stringify JSON.parse 123456789&#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;info&quot;: &#123; &quot;single&quot;: true, &quot;age&quot;: 30 &quot;city&quot;: &quot;Beijing&quot; &#125;, &quot;like&quot;: [&quot;music&quot;,&#x27;basketball&#x27;]&#125; 3）获取当前页面 url 参数 传统方式: location.search 假设 HTML 文件的参数列表为 ?a=10&amp;b=20&amp;c=30 （自己定义就是在 地址栏html 后面加上这一串） 1234567891011121314function query(name)&#123; const search = location.search.substring(1) // 去掉 search 前面的问号 // search = &#x27;a=10&amp;b=20&amp;c=30&#x27; const reg = new RegExp(`(^|&amp;)$&#123;name&#125;=([^&amp;]*)(&amp;|$)`,&#x27;i&#x27;) const res = search.match(reg) if(res === null)&#123; return null &#125; return res[2]&#125;const res = query(&#x27;a&#x27;)console.log(res); //10const res1 = query(&#x27;d&#x27;)console.log(res1); // null 新 API: URLSearchParams (兼容问题) 1234567function query(name)&#123; const search = location.search const p = new URLSearchParams(search) return p.get(name)&#125;res = query(&#x27;a&#x27;)console.log(res); 2-part21）将 url 解析为 JS 对象其实和获取当前页面 url 参数是一个意思，只不过不用正则表达式，用一个对象来接收 1234567891011121314function queryToObj()&#123; const res = &#123;&#125; const search = location.search.substring(1) // &#x27;a=10&amp;b=20&amp;c=30&#x27; search.split(&#x27;&amp;&#x27;).forEach(ele=&gt;&#123; const arr = ele.split(&#x27;=&#x27;) const key = arr[0] const val = arr[1] res[key] = val &#125;) return res&#125;console.log(queryToObj()); solution 2 12345678function queryToObj()&#123; const res = &#123;&#125; const pList = new URLSearchParams(location.search) pList.forEach((key,val)=&gt;&#123; res[key] = val &#125;) return res&#125; 2）手写 flatern 考虑多层级123456789function flat(arr)&#123; let isDeep = arr.some(item=&gt; item instanceof Array) if(!isDeep)&#123; return arr &#125; // Array.prototype.concat.apply([],arr) 只能拍平两层 所以要递归 let res = Array.prototype.concat.apply([],arr) return flat(res)&#125; 3）数组去重solution 1 // 用 indexOf 判断 res 里面有没有这个值 123456789function unique(arr)&#123; const res = [] arr.forEach(item =&gt; &#123; if(res.indexOf(item)&lt;0)&#123; res.push(item) &#125; &#125;); return res&#125; solution 2 使用 set（无序结构，不允许由于重复元素） 12345function unique(arr)&#123; const set = new Set(arr) return [...set]&#125; 3-part31）手写深拷贝 必会！！！注意 Object.assign 不是深拷贝，只是拷贝了第一层 1234567891011121314function deepClone(obj)&#123; if(typeof(obj)!==&#x27;object&#x27; || typeof(obj) == null)&#123; return obj; &#125; let res = obj instanceof Array?[]:&#123;&#125;; for(let key in obj)&#123; // 确保key不是原型链上的 if(obj.hasOwnProperty(key))&#123; // 递归（重点） key要一层一层遍历，比如说 obj&#123; address:&#123;city: &#x27;Beijing&#x27;&#125;&#125; res[key] = deepClone(obj[key]) &#125; &#125; return res;&#125; 2）介绍 RAF requestAnimationFrame 动画流畅，更新频率要达到 60帧/s ，即 16.67ms 更新一次视图 setTimeout 需要手动控制频率，而 RAF 浏览器会自动控制 后台标签隐藏在 iframe 中，RAF 会暂停，而 setTimeout 依然执行 1234567891011121314// html 里有一个 div 标签const $div1 = $(&#x27;#div1&#x27;)const max = 640let curWidth = 100function animate()&#123; curWidth = curWidth + 3 $div1.css(&#x27;width&#x27;,curWidth) if(curWidth&lt;max)&#123; // 如果是 setTimeout 的写法 setTimeOut(animate,16.7) 16.7这个数字要自己计算 window.requestAnimationFrame(animate) &#125;&#125;animate() 3）性能优化从哪几个方面考虑 原则：多使用内存，缓存，减少计算，减少网络请求 方向：加载页面，页面渲染，页面操作流畅度","categories":[],"tags":[]},{"title":"前端面试真题-part3","slug":"前端面试真题-part3","date":"2021-12-15T11:13:57.000Z","updated":"2021-12-17T12:04:52.536Z","comments":true,"path":"2021/12/15/前端面试真题-part3/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part3/","excerpt":"主要内容：函数声明和函数表达式、new Obeject() 和 Object.create()、 this","text":"主要内容：函数声明和函数表达式、new Obeject() 和 Object.create()、 this 1.part11）函数声明和函数表达式的区别 函数声明 function fn(){…} 函数表达式 const fn = function() {…} 函数声明会在代码执行前预加载，但是函数表达式不会 123456789101112131415// 函数声明 代码执行前函数已经初始化好了，所以不会报错const res = sum(10,20) console.log(res)function sum(x, y)&#123; return x +y&#125; // 函数表达式，用 let const 声明，不会提升所以函数就不会提前初始化，会报错// 用 var 定义，则 sum 已经变量提升，执行的时候 sum 是 undefined，代码会报错 sum is not a functionconst res = min(10,20)console.log(res)const min =&gt; (a,b)&#123; return a - b&#125; 2）new Obeject() 和 Object.create() 的区别 new Object() 和 {} 是等同的，所以它们的原型都是 Object.prototype Object.create(null) 没有原型（）里的是要传给其的参数 Object.create({…}) 可以指定原型 1234567891011121314const obj1 = &#123; a: 10, b: 20, sum()&#123; return this.a + this.b &#125;&#125;const obj2 = new Object(obj1) // obj1 === obj2const obj3 = Object.create(null) // 没有属性 没有原型const obj4 = new Object(null) // 没有属性 但是有原型const obj5 = Object.create(obj1) // 此时 obj5 的隐式原型是 obj1 也就是 Object，所以 obj5 的属性是空的，但是可以读取原型上的属性和方法const flag = (obj1 === obj5) // falseconst flag1 = (obj5.__proto__ === obj1) // true 3）关于 this 的场景题原则：函数里面 this 的值在执行的时候才知道， 1234567891011121314151617const User = &#123; count: 1, getCount: function()&#123; return this.count &#125;&#125;const a = &#123; count: 2&#125;console.log(User.getCount()); // 1 ，this 就是 User， this.count 就是 User.countconst func = User.getCount// 如果把 User的 getCount 作为单独的函数执行，那么this 就相当于 window了console.log(func()); // undefined console.log(func.call(a)); // 执行的时候 this 指向 a 就有 count 了 2.part21）关于作用域和自由变量的场景题-1一是全局变量，二是 setTimeout 是异步函数 对于全局变量，由于setTimeout 是异步函数，循环是同步，所以要等同步函数执行完，但是这样全局变量已经加到 4 了 123456789101112131415161718192021let ifor(i = 1; i&lt;=3; i++)&#123; setTimeout(()=&gt;&#123; console.log(i) &#125;,0)&#125;// 4 4 4for(let i = 1;i&lt;=3;i++)&#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 0);&#125;// 1 2 3let j for(j = 1;j&lt;=3;j++)&#123; console.log(j)&#125;console.log(j)// 1 2 3 4 对于同步函数 一次循环从上往下执行 所以即使是全局变量 也是一个挨一个打印 2）关于作用域和自由变量的场景题-2123456789let a = 100function test()&#123; alert(a) a = 10 alert(a)&#125;test()alert(a)// 100 10 10 3）判断字符串以字母开头，后面字母数字下划线，长度 6-30原则：利用正则表达式（一般来说面试的题比较简单，日常工作还是需要查的） 解释：/ $/ 正则表达式的开头结尾（可选，看是要全部满足还是满足开头或者结尾）；^ 表示字符串开始；[ ] 里的内容表示选择规则，也就是 a-zA-Z的字母保留 \\w 表示 匹配字母数字下划线，{5,29} 表示长度 是 &gt;= 5 &lt;=29 (因为前面 \\w 已经占了一个长度) 1const reg = /^[a-zA-Z]\\w&#123;5,29&#125;$/ 123456789101112//基础的正则表达式// 邮政编码/\\d&#123;6&#125;/// 英文小写字母/^[a-z]+$/// 英文字母/^[a-zA-Z]+$/// 日期格式/^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/// 简单的IP地址/\\d+\\.\\d+\\.\\d+/ 常见正则表达式 https://deerchao.cn/tutorials/regex/regex.htm https://www.runoob.com/regexp/regexp-tutorial.html 3.part31）手写字符串 trim（把开头和结尾的空格删掉） 方法，保证浏览器兼容性原则：用 正则表达式 来解决，同时也有原型和this 12345678if(!String.prototype.trim)&#123; String.prototype.trim = function()&#123; return this.replace(/^\\s+/,&#x27;&#x27;).replace(/\\s+$/,&#x27;&#x27;)&#125;&#125;// replace(/^\\s+/,&#x27;&#x27;)选中开头是多个（+号的作用）空格的字符串，把多个空格用 &#x27;&#x27; 代替// replace(/\\s+$/,&#x27;&#x27;)选中结尾是多个（+号的作用）空格的字符串，把多个空格用 &#x27;&#x27; 代替// 因为 trim 是 ES5 的，可能有的不支持，所以先判断 String 的原型上有没有 trim 方法，没有就添加// this 通过 字符串.prototype 执行，this 就是这个字符串 2）如何获取多个数组中的最大值solution 1 12Math.max()Math.min() solution 2 1234567891011function findMax ()&#123; const nums = Array.prototype.slice.call(arguments) // 不知道为什么用箭头函数的话 nums 就会执行不出来 很奇怪 let max = nums[0] console.log(nums); nums.forEach(i =&gt; &#123; if(max &lt;= i ) max = i &#125;); return max&#125; 3）如何用 JS 实现继承 class 继承（更加推荐） prototype 继承（不推荐） ​","categories":[],"tags":[]},{"title":"前端面试真题-part2","slug":"前端面试真题-part2","date":"2021-12-15T08:18:44.000Z","updated":"2021-12-17T12:05:28.858Z","comments":true,"path":"2021/12/15/前端面试真题-part2/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part2/","excerpt":"主要内容：事件代理、闭包、事件冒泡","text":"主要内容：事件代理、闭包、事件冒泡 1-part11）call 和 apply 的区别123// call 和 applyfn.call(this,p1,p2,p3)fn.apply(this,arguments) 2）事件代理（委托）是什么3）闭包是什么？有何特性？有何影响？ 作用域和自由变量 闭包应用场景 自由变量的查找，要在函数定义的地方（而不是执行的地方） 影响：有可能变量会常驻内存，得不到释放。闭包不要乱用。不一定是内存泄漏 内存泄漏：自由变量，也就是返回的值是自由变量，用完就释放，但是如果返回/传入的是带参数的函数，那么这个参数因为之后还有可能会被使用，所以就不会释放 2-part21）如何阻止事件冒泡和默认行为12event.stopPropagation()event.preventDefault() 2）查找、添加、删除、移动 DOM 节点的方法？1 3）如何减少 DOM 操作？ 缓存 DOM 查询结果 多次 DOM 操作，合并到一次插入 3-part31）解释 jsonp 原理，为何不是真正的 ajax 浏览器的同源策略（服务端没有同源策略，其实是没有 跨域 这一说，叫转发）和跨域 jsonp 利用的 script 标签 的跨域功能，ajax 利用 XMLRequest API 来执行的 哪些 HTML 标签可以绕过跨域 jsonp 原理：其实就是 2）== 和 === 的区别 == 强制类型转换 === 严格相等 只有 == null 才用 两等 3）document load 和 ready 的区别 load 网络所有资源全部加载完成才执行 ready DOM渲染完即可执行","categories":[],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"}]},{"title":"前端面试真题-part1","slug":"前端面试真题-part1","date":"2021-12-15T05:57:04.000Z","updated":"2021-12-17T13:07:17.599Z","comments":true,"path":"2021/12/15/前端面试真题-part1/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part1/","excerpt":"主要内容：var let const 、深度比较、数组的方法","text":"主要内容：var let const 、深度比较、数组的方法 1. part-11）var let const 的区别 var 是 ES5 语法，let const 是 ES6 语法；var 有变量提升 123456789// ES5 变量提升// ES5在执行的时候，会先把 var 定义的值先提出来定义为 undefinedconsole.log(a); // undefiendvar a = 200// 相当于 var aconsole.log(a); // undefienda = 200 var 和 let 是变量，可以修改，const 是常量， 不可以修改 let 和 const 都有块级作用域，var 没有 12345678910111213// var 定义的变量是全局变量for(var i = 0;i&lt;10;++i)&#123; var j = i + 1&#125;console.log(i,j); // 10// let 定义的变量只在自己的块级作用域里// 块级作用域for(let i = 0;i&lt;10;++i)&#123; let j = i + 1&#125;console.log(i,j); // 报错 undefined 2）typeof 返回 undefined string number boolean symbol （值类型） object （注意 typeof null === ‘object’）（引用类型都判断为 object） function （函数是单独的） 3）列举 强制类型转换 和 隐式类型 转换 强制：parseInt parseFloat toString 隐式：if、逻辑运算、==、+ 拼接字符串 2.part-21）手写深度比较，模拟 lodash isEqual1234567891011121314151617181920212223242526272829// 另写一个函数 判断是否为 不为空的对象或数组function isObject(obj)&#123; return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null&#125;// 递归函数function isEqual(obj1,obj2)&#123; // 递归终止 if(!isObject(obj1)||!isObject(obj2))&#123; return obj1 === obj2 &#125; if(obj1 === obj2)&#123; return true &#125; // 确保两个都是对象或数组 且不相等 const obj1Keys = Object.keys(obj1) const obj2Keys = Object.keys(obj2) if(obj1Keys.length !== obj2Keys.length)&#123; return false &#125; // 递归比较 for(let key in obj1)&#123; const res = isEqual(obj1[key],obj2[key]) if(!res)&#123; return false &#125; &#125; return true&#125; 2）split() 和 join() 的区别12&#x27;1-2-3&#x27;.split(&#x27;-&#x27;) // [1,2,3][1,2,3].join(&#x27;-&#x27;) // &#x27;1-2-3&#x27; 3）数组的 pop push unshift shift 分别做什么从三个方面来说 分别的功能 分别的返回值 是否会对原数组造成影响 123456789101112131415// pop 删除最后一个元素，返回删除的这个元素，会改变原数组let a = [1,2,3]console.log(a.pop(),a); // 3, [1,2] // shift 删除第一个元素，返回删除的这个元素，会改变原数组let b = [4,5,6]console.log(b.shift(),b); // 4, [5,6] // push 把元素加到最后面,返回数组的长度，会改变原数组let c = [7,8,9]console.log(c.push(10),c); // 4 [ 7, 8, 9, 10 ] // unshift 把元素加到最前面,返回数组的长度，会改变原数组let d = [11,12,13]console.log(d.unshift(14),d); // 4 [ 14, 11, 12, 13 ] 4）数组的纯函数 API 纯函数的定义——1.不改变原数组；2.返回一个数组。 所以 3）中的 API 都不是纯函数，还有 forEach，some every，reduce，这三个虽然不改变原数组，但不返回一个数组 以下列举一些常见的数组纯函数 API：concat map filter slice 1234567// concat map filter slice 都不会改变原数组 同时返回一个新数组const arr = [1,2,3,4]const arr1 = arr.concat([5,6,7,8]) // 拼接两个数组 [1, 2, 3, 4, 5, 6, 7, 8]const arr2 = arr.map( num =&gt; num * 3) // 按照一定规则遍历改变元素 [ 3, 6, 9, 12 ]const arr3 = arr.filter( num =&gt; num &gt; 2) // 按照一定规则过滤元素 [ 3, 4 ]const arr4 = arr.slice() // 相当于深拷贝原数组 [ 1, 2, 3, 4 ] 3.part31）数组 slice 和 splice 的区别从三个方面来说 功能区别 参数和返回值 是不是纯函数 1234567891011const arr = [1, 2, 3, 4]// slice 纯函数const arr1 = arr.slice() // 深拷贝 [1, 2, 3, 4]const arr2 = arr.slice(1,3) // slice(startIndex,endIndex) 左闭右开 [2, 3]const arr3 = arr.slice(1) // slice(startIndex) 从开始截取到最后 [2, 3, 4]const arr4 = arr.slice(-2) // slice(负值) 倒数的几个值 [3, 4]// splice 非纯函数 三个参数 (startIndex, length, replaceValue) 后两者都是可选的const arr5 = arr.splice(1,2,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)console.log(arr5); // [2, 3]console.log(arr); // [ 1, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 4 ] 2）[10, 20, 30].map(parseInt) map 的参数和返回值 (item, index) 返回一个数组 parseInt 的参数和返回值 parseInt(string, radix); 解析一个字符串并返回指定基数的十进制整数，也就是说 把一个 radix 进制的 string 转换为一个十进制数并且输出 123456789const res = [10,20,30].map(parseInt)console.log(res); // [ 10, NaN, NaN ]// 拆解来看： res = [10, 20, 30].map((item,index)=&gt;&#123; // parseInt(10,0); 0 相当于 10 进制，也就是把一个 10 进制的数变成 10 进制输出 // parseInt(20,1); 把一个 1 进制的数 20 输出为 10 进制，给定的 20 不符合 1 进制 所以输出 NaN return parseInt(item,index)&#125;) 3）ajax 的请求 get 和 post 的区别 get 一般用于查询操作，post 一般用户提交操作 get 参数拼接在 url 上， post 放在请求体内（数据体积更大） 安全性：post 防止 CSRF","categories":[],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"}]},{"title":"手写防抖和节流","slug":"手写防抖和节流","date":"2021-12-14T12:27:11.000Z","updated":"2021-12-18T12:05:02.711Z","comments":true,"path":"2021/12/14/手写防抖和节流/","link":"","permalink":"http://example.com/2021/12/14/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"防抖和节流函数的详细说明","text":"防抖和节流函数的详细说明 1.防抖（1）例子 比如说用户输入搜索事件，如果用 keyup 监听，文字一直在变化 keyup 一直发生，那么就会频繁触发 change 事件。所以我们需要防抖的功能，实现当用户输入结束或者暂停时才触发 change 事件 （2）代码思路演示 123456789101112131415161718const inp1 = document.getElementById(&#x27;inp1&#x27;)// 不做防抖 keyup 不停触发，文字内容不停打印，所以要对 function 做防抖改进// inp1.addEventListener(&#x27;keyup&#x27;,function()&#123;// console.log(inp1.value);// &#125;)let timer = nullinp1.addEventListener(&#x27;keyup&#x27;,function()&#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(function()&#123; // 模拟触发 console.log(inp1.value); // 清空定时器 timer = null &#125;,500)&#125;) （3）流程分析 比如说单独输入 1 就停住了， 一开始没有 timer，等 500 ms 以后打印再清空 timer 但是如果连续输入 123，因为连续输入的时间间隔并没有到 500 ms，所以在输入 2 的时候，timer有值但没有到 500 ms，就会被清空。 一切 value 都要等到 500 ms 到了才会被打印 （4）封装优化 返回一个函数 fn.apply(this,arguments) 相当于 fn(), 只不过更全面，如果用了 apply 的话，在调用的时候，debounce传入的函数不能是箭头函数，不然改不了 this 123456789101112131415function debounce(fn,delay)&#123; let timer = null return function()&#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(()=&gt;&#123; fn.call(this) timer = null &#125;,delay) &#125;&#125;inp1.addEventListener(&#x27;keyup&#x27;,debounce(function()&#123; console.log(inp1.value);&#125;,500)) 2.节流（1）例子 不停拖拽一个元素的时候，我们如果用 drag 事件随时拿到拖拽的位置的话，频繁触发可能会导致卡顿，所以我们需要节流，实现无论拖拽速度有多快，都会每隔固定的一段时间才触发一次 （2）代码思路演示 123456789101112131415// 和防抖差不多 只是if(timer)的处理逻辑不一样let timer = nulldiv1.addEventListener(&#x27;drag&#x27;,function(e)&#123; if(timer)&#123;// 和防抖的区别在这里 节流里 timer 的时间在累加达到定时触发的效果，// 而防抖则是直接清空 timer， 达到 从用户不停输入到停止delay时间的过程中 只触发一次的效果 return &#125; timer = setTimeout(()=&gt;&#123; // 注意 e 是 dragevent 的对象，是传进来函数的参数 不是 setTimeout 的参数 console.log(e.offsetX,e.offsetY); timer = null &#125;,100) &#125;) （3）过程分析 一开始 timer 赋值为 null，最开始先给 timer 赋值，还没到 100ms 就触发了 drag 事件但是 setTimeout 事件还没有到时间，所以 timer 一直有值。 也就是说在 100ms 内，if(timer) 都在 return，什么都不执行。等到了 100ms，就打印，然后又开始下一个 100ms 的进程。 （4）封装优化 1234567891011121314151617const div1 = document.getElementById(&#x27;div1&#x27;)function throttle(fn,delay)&#123; let timer = null; return function()&#123; if(timer)&#123; return &#125; timer = setTimeout( ()=&gt;&#123; fn.apply(this,arguments) timer = null &#125;,delay) &#125;&#125;div1.addEventListener(&#x27;drag&#x27;,throttle(function(e)&#123; console.log(e); console.log(e.offsetX); &#125;,1000))","categories":[],"tags":[{"name":"手写防抖 手写节流","slug":"手写防抖-手写节流","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96-%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81/"}]},{"title":"运行环境","slug":"运行环境","date":"2021-12-14T11:14:44.000Z","updated":"2021-12-16T09:24:42.505Z","comments":true,"path":"2021/12/14/运行环境/","link":"","permalink":"http://example.com/2021/12/14/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","excerpt":"1.运行环境运行环境即浏览器（server端有nodejs），下载网页代码时渲染出页面，期间执行js。为了用户体验，我们要保证代码在浏览器中运行时稳定且高效。","text":"1.运行环境运行环境即浏览器（server端有nodejs），下载网页代码时渲染出页面，期间执行js。为了用户体验，我们要保证代码在浏览器中运行时稳定且高效。 2.网页加载过程2.1加载资源的形式和过程1）资源的形式：html 代码；媒体文件，如图片视频等；js，css文件 2）过程： DNS解析：域名→ IP地址 浏览器根据 IP 地址向服务器发起 http 请求（实际上还涉及到操作系统 三次握手什么的） 服务器处理 http 请求，并返回给浏览器 （返回的形式要看请求的是什么） 2.2渲染页面的过程 根据 HTML 代码生成 DOM Tree 根据 CSS 代码生成 CSSOM 将 DOM Tree 和 CSSOM 整合形成 Render Tree 浏览器根据 Render Tree 渲染页面 遇到 则暂停渲染，优先加载并执行 JS 代码，完成再继续。因为 script 里面可能有改变 DOM 树的代码 2.3 问题1）为什么 css 要放到 head标签里呢？ 在 DOM 树生成以前就可以加载完 CSS，最后按照 CSS 的规则统一渲染，不用重复 2）为什么要把 js 放到 body 最后呢？ 和 1）的解释差不多，如果不放在最后很有可能出现页面渲染到一半停住的情况 3）window.onload 和 DOMContentLoaded 的区别 window.onload 123window.addEventListener(&#x27;load&#x27;,function()&#123; // 页面的资源全部加载完才会执行，包括图片 视频等&#125;) DOMContentLoaded 123document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123; // DOM 渲染完即可执行，此时图片、视频可能还没有加载完，比较快一点&#125;) 4）从输入 url 到显示出整个页面的过程 加载资源→渲染页面 3.性能优化3.1.1 原则 多使用内存、缓存或其它方法 减少 CPU 计算量，减少网络加载耗时 实际上是空间换时间 3.2 具体优化3.2.1 优化的方向1）加载更快 减少压缩体积：压缩代码 减少访问次数：合并代码（http请求耗时相对长，一次 9kb 比 三次3kb 要快很多）、SSR 服务器端渲染、缓存 使用更快的网络：CDN 2）渲染更快 CSS 在 head，JS 在 body 下面 今早开始执行 JS，用 DOMContentLoaded 加载 懒加载 对 DOM 查询进行缓存 频繁 DOM 操作，合并到一起插入 DOM 结构 节流throttle 防抖debounce 3.2.2 一些具体实现1） 缓存 静态资源加 hash 后缀，根据文件内容计算 hash 文件内容不变，那么 hash 不变，那么 url 不变 url 和文件不变，则会自动触发 http 缓存机制，返回 304 2）SSR 服务端渲染：将网页和数据一起加载，一起渲染 非SSR（前后端分离）：先加载网页，再加载数据，在渲染数据 3）懒加载 需要的时候才加载，不需要就不加载 比如说图片，先把图片地址赋值成一张预览图，等用户浏览到这张图片时，再把真正的地址加载出来 4）缓存 DOM 查询 12345678910// 不缓存 DOM 查询结果for(let i = 0;i&lt;document.getElementsByTagName(&#x27;p&#x27;).length;i++)&#123; // 每次循环都会计算length，频繁进行DOM查询&#125;// 缓存 DOM 查询结果let len = document.getElementsByTagName(&#x27;p&#x27;)for(let i = 0;i&lt;len; i++)&#123; // 缓存length 只会查询一次DOM&#125; 5）多个 DOM 操作一起插入到 DOM 结构 1234567891011const list = document.getElementById(&#x27;list&#x27;)// 创建一个文档片段 此时还没有插入到 DOM 结构中const frag = document.createElement(&#x27;fragment&#x27;)for(let i = 0;i&lt;10;i++)&#123; const li = document.createElement(&#x27;li&#x27;) li.innerHTML = `List item $&#123;i&#125;` // 先把 li 插入到 文档片段中 frag.appendChild(li)&#125;// 最后一次性插入到 DOM 结构中list.appendChild(frag) 4.安全4.1.1 XSS跨站请求 攻击1）举例 2）防御 把 &lt;、/&gt;分别变成 &amp;lt；和 &amp;gt；这样会直接显示出来而不执行 4.1.2 XSRF跨站请求 伪造1）举例 2）防御 使用post接口 增加验证","categories":[],"tags":[{"name":"网页加载","slug":"网页加载","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2021-12-14T10:43:14.000Z","updated":"2022-02-27T14:29:17.823Z","comments":true,"path":"2021/12/14/linux常用命令/","link":"","permalink":"http://example.com/2021/12/14/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"1.常用命令","text":"1.常用命令 ls 查看文件夹ls-a 查看隐藏文件ll 列表显示clear 清屏mkdir 创建文件夹rm fileName 删除文件rm -rf fileName 删除文件夹（递归强制全部）cd fileName 跳转目录mv fieName newFileName 修改文件名mv fieName address 移动目录cp fieName newFileName 拷贝文件touch fileName 新建文件vi fileName 有的话直接打开，没有的话新建文件并且打开cat fileName 打印文件所有内容head fileName 打印前面几行tail fileName 打印后面几行grep “keywords” fileName 在文件查找有关键字的内容 2.vim 编辑模式（简单版） 进去vim编辑器模式 先点 i切换到insert模式 esc退出 :w 保存 :q退出 :q! 强制退出 vimtutor：vim官方教程","categories":[],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"手写Promise","slug":"手写Promise","date":"2021-12-12T02:32:43.000Z","updated":"2021-12-17T12:01:08.385Z","comments":true,"path":"2021/12/12/手写Promise/","link":"","permalink":"http://example.com/2021/12/12/%E6%89%8B%E5%86%99Promise/","excerpt":"手写Promise","text":"手写Promise 先给出一个 promise 作为例子 1234const p1 = new Promise((resolve,reject)=&gt;&#123; // resolve(value) // reject(reason)&#125;) I. 结构1.myPromise 类12345678910111213141516171819202122232425262728class myPromise &#123; // 1.需要的全局变量 state = &#x27;pending&#x27; // promise 本身有三个状态，所以我们定义一个状态变量 pending fulfilled rejected value = undefined // 成功后的值 reason = undefined // 失败后的原因 resolveCallbacks = [] // pending 状态下存储成功的回调 rejectCallbacks = [] // pending 状态下存储失败的回调 // 2 定义 constructor // 2.1 从 p1 看出，constructor 参数是两个函数，这两个函数又分别有自己的参数，一个声明为 value 一个声明为 reason constructor(fn)&#123; const resolveHandler = (value)=&gt;&#123;&#125; const rejectHandler = (reason)=&gt;&#123;&#125; // 2.2 为了函数稳定性 在 try catch 里面执行 try&#123; fn( resolveHandler,rejectHandler) &#125;catch(err) &#123; rejectHandler(err) &#125; &#125; // 3 方法 then 和 catch then(fn1,fn2)&#123; &#125; catch(fn)&#123; &#125;&#125; 2.myPromise 的全局静态API1234myPromise.resolve = function()&#123; &#125; myPromise.reject = function()&#123; &#125; myPromise.all = function()&#123; &#125; myPromise.race = function()&#123; &#125; II. 详细代码1.constructor 部分考虑以下几点 1）状态只有 pending → fulfilled 和 pending→rejected 2）回调函数数组里面不只一个函数，所以要遍历执行 123456789101112131415161718constructor(fn)&#123; const resolveHandler = (value)=&gt;&#123; // 执行函数之前，要先判断并且限定状态 if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;fulfilled&#x27; // 把 value 存储起来 this.value = value // 在成功的状态下，就执行成功的回调，但是回调函数不止一个，所以要遍历执行 把 value 传进来 this.resolveCallbacks.forEach(fn =&gt; fn(this.value)) &#125; &#125; const rejectHandler = (reason)=&gt;&#123; if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectCallbacks.forEach(fn =&gt; fn(this.reason)) &#125; &#125; 2.方法部分1） then 里面有两个参数 fn1 fn2 pending状态不执行,把它们存储起来； resolveed状态执行fn1； rejected状态执行 fn2 2）catch 方法相当于 then 的语法糖，因为 then 方法里面本身就可以传进来两个函数，第一个是成功的回调，一个是失败的回调。比如说下面这个例子：then 里面传入两个函数，p2.then() 就执行了后面一个函数。 12345678const p2 = Promise.reject(&#x27;my error&#x27;).catch(err=&gt;&#123; throw new Error(&#x27;catch error&#x27;)&#125;)p2.then(()=&gt;&#123; console.log(&#x27;resolved&#x27;);&#125;,()=&gt;&#123; console.log(&#x27;rejected&#x27;);&#125;) 3）在 then 方法里，主要部分是判断我们 Promise 的状态，不同的状态做不同的事情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455then(fn1,fn2)&#123; // 1.因为传入 then 的时候，第一个参数可能是 null 所以需要判断一下类型，以便决定是否执行 // 1.1如果是函数，就是自己，不是的话，传入什么就是什么 类似于 p.then(v=&gt;v) fn1 = typeof fn1 === &#x27;function&#x27;? fn1 :(v) =&gt; v fn2 = typeof fn1 === &#x27;function&#x27;? fn2 :(err) =&gt; err // 2.接下来需要判断状态 但不管是什么状态 then 里面不管执行什么代码，返回的都是一个新的 promise // 2.1 pending 存储 fn1 fn2 ，也就是添加到回调列表里面 if(this.state === &#x27;pending&#x27;)&#123; const p = new myPromise((resolve,reject)=&gt;&#123; // 在这里我们只是把函数push进来了，还没有开始遍历执行，当它开始执行的时候，说明状态已经变了，value也就存在 this.resolveCallbacks.push(()=&gt;&#123; try&#123; const newValue = fn1(this.value) resolve(newValue) &#125;catch(err)&#123; reject(err) &#125; &#125;) this.rejectCallbacks.push(()=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) &#125;) return p &#125; // 2.2 fulfilled 执行 fn1 if(this.state === &#x27;fulfilled&#x27;)&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newValue = fn1(this.value) // newValue 是 fn1 用了当前promise的value执行后的值，要返回给新的promise（实现链式调用） resolve(newValue)// 把返回的 newValue 给 resolve 再执行 &#125;catch(err)&#123; reject(err) &#125; &#125;) return p1 &#125; // 2.3 rejected 执行 fn2 if(this.state === &#x27;rejected&#x27;)&#123; const p2 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) return p2 &#125; &#125; 4）catch 方法 相当于 then 执行第二个函数 123catch(fn)&#123; return this.then(null,fn) &#125; 3.全局API 部分1）resolve 和 reject 都比较简单 1234567myPromise.resolve = function(value)&#123; return new myPromise((resolve,reject)=&gt;resolve(value))&#125;myPromise.reject = function(reason)&#123; return new myPromise((resolve,reject)=&gt;reject(reason))&#125; 2.race 123456789101112131415161718// race 只要有一个 fulfilled，就返回 promisemyPromise.race = function(promiseList = [])&#123; let resolved = false const p1 = new myPromise((resolve,reject)=&gt;&#123; promiseList.forEach(p=&gt;&#123; p.then((data)=&gt;&#123; if(!resolved)&#123; resolve(data) resolved = true &#125; &#125;).catch((err)=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125; 3)all 12345678910111213141516171819202122// all 传入 promise 数组，等待所有都 fulfilled 之后，返回新 promisemyPromise.all = function(promiseList = [])&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; const result = [] // 存储 promiseList 所有的结果 const length = promiseList.length let resolveCount = 0 // 在 forEach 里面不能用forEach((p,index)=&gt;&#123;&#125;)的index来判断是否都执行完，因为 forEach 很快，index瞬间就加满了，但是 then里面的函数不一定执行完了（尤其是有异步函数的情况） promiseList.forEach(p=&gt;&#123; p.then(data=&gt;&#123; result.push(data) // resolveCount 只能在then里面加，也就是then执行了才能加 resolveCount++ if(resolveCount === length)&#123; resolve(result) &#125; &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125; III. 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class myPromise &#123; class myPromise &#123; state = &#x27;pending&#x27; value = undefined reason = undefined resolveCallbacks = [] rejectCallbacks = [] constructor(fn)&#123; const resolveHandler = (value)=&gt;&#123; if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;fulfilled&#x27; this.value = value this.resolveCallbacks.forEach(fn =&gt; fn(this.value)) &#125; &#125; const rejectHandler = (reason)=&gt;&#123; if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectCallbacks.forEach(fn =&gt; fn(this.reason)) &#125; &#125; try&#123; fn( resolveHandler,rejectHandler) &#125;catch(err)&#123; rejectHandler(err) &#125; &#125; then(fn1,fn2)&#123; fn1 = typeof fn1 === &#x27;function&#x27;? fn1 :(v) =&gt; v fn2 = typeof fn1 === &#x27;function&#x27;? fn2 :(err) =&gt; err if(this.state === &#x27;pending&#x27;)&#123; const p = new myPromise((resolve,reject)=&gt;&#123; this.resolveCallbacks.push(()=&gt;&#123; try&#123; const newValue = fn1(this.value) resolve(newValue) &#125;catch(err)&#123; reject(err) &#125; &#125;) this.rejectCallbacks.push(()=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) &#125;) return p &#125; if(this.state === &#x27;fulfilled&#x27;)&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newValue = fn1(this.value) resolve(newValue) &#125;catch(err)&#123; reject(err) &#125; &#125;) return p1 &#125; if(this.state === &#x27;rejected&#x27;)&#123; const p2 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) return p2 &#125; &#125; catch(fn)&#123; return this.then(null,fn) &#125;&#125;myPromise.resolve = function(value)&#123; return new myPromise((resolve,reject)=&gt;resolve(value))&#125;myPromise.reject = function(reason)&#123; return new myPromise((resolve,reject)=&gt;reject(reason))&#125;myPromise.all = function(promiseList = [])&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; const result = [] const length = promiseList.length let resolveCount = 0 promiseList.forEach(p=&gt;&#123; p.then(data=&gt;&#123; result.push(data) resolveCount++ if(resolveCount === length)&#123; resolve(result) &#125; &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125;myPromise.race = function(promiseList = [])&#123; let resolved = false const p1 = new myPromise((resolve,reject)=&gt;&#123; promiseList.forEach(p=&gt;&#123; p.then((data)=&gt;&#123; if(!resolved)&#123; resolve(data) resolved = true &#125; &#125;).catch((err)=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125;","categories":[],"tags":[{"name":"手写Promise","slug":"手写Promise","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99Promise/"}]},{"title":"JS面试篇-Part9","slug":"JS面试篇-Part9","date":"2021-12-11T10:52:57.000Z","updated":"2021-12-12T07:17:28.172Z","comments":true,"path":"2021/12/11/JS面试篇-Part9/","link":"","permalink":"http://example.com/2021/12/11/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part9/","excerpt":"1.http常见的状态码","text":"1.http常见的状态码 码 含义 1xx 服务器收到请求 2xx 请求成功，如 200 3xx 重定向，如 301(永久重定向) 302（临时重定向）304(资源未被修改) 4xx 客户端错误，如 404(资源未被找到) 403(没有权限) 5xx 服务端错误，如 500(服务器错误) 504(网关错误) 2.http methods Restful API 传统的 methods get 获取数据，post 向服务器发送数据 现在的 methods get 获取数据 post 新建数据 patch/put 更新数据 delete 删除数据 Restful API 一种新的 API 设计方法（早已推广使用） 传统API设计：把每个 url 当做一个功能 Restful API：把每个 url当做一个唯一的资源 如何把 url 设计成一个资源？ 不使用 url 参数 传统 API：/api/list?pageIndex = 2; Restful API: /api/list/2 method 表示操作类型 传统 API： post：/api/create-blog; post: /api/update-blog?id=100; get: /api/get-blog?id=100（url里面就知道要做什么了，也就是功能） Restful API： post: /api/blog; patch: /apiblog/100; get: /api/blog/100 (只能看出来资源标识也就是100，看请求名，才能知道具体要做什么，增加，更新，获得) 3.http headers 常见的 Request Headers 名称 含义 Accept 浏览器可接收的数据格式 Accept-Encoding 浏览器可接收的压缩算法，如gzip Accept-Language 浏览器接收的语言 如 zh-CN Connection: keep-alive 一次TCP链接重复使用 cookie 同域请求，浏览器都会自带 host 请求的域名 User-Agent（UA） 浏览器信息 Content-type 发送数据的格式，如 application/json 常见的 Response Headers 名称 含义 Content-type 返回数据的格式，如 application/json Content-length 返回数据的大小，多少字节 Content- Encoding 返回数据的压缩算法，如 gzip Set-Cookie 服务端修改 cookie 缓存相关的 headers （第四点） cache-control ​ 4.http缓存 缓存介绍 把可以重复利用的存储下来，让下次访问页面加载得更快些 网络请求环节加载比较慢，需要提高速度，优化网络请求需要缓存 静态资源可以被缓存，js css img http 缓存策略（强制缓存+协商缓存） 强制缓存 过程：发送请求到服务器，返回带cache-control给浏览器，浏览器下次就向本地缓存请求返回资源（缓存过期则重新向服务器请求） // 图片 Expires 同在 response headers 中，控制缓存过期，已被 cache-control 替代 cache-control（为主） 名称 含义 max-age 缓存最大过期时间 no-cache 不用本地（强制）缓存，到服务端请求 no-store 不用本地缓存，也不用服务端缓存，服务端直接返回资源即可 private/public 只能用户终端做缓存/中间代理等也可以做缓存 协商缓存（对比缓存） 服务端缓存策略（服务端判断资源是否要缓存，不是说要缓存在服务端） 服务端判断客户端资源是否和服务端资源一样 一致则返回 304，否则返回 200 和最新的资源 资源标识 在response headers 中，有两种 Last-Modified 资源的最后修改时间 Etag 资源的唯一标识（一个字符串，类似于人的指纹） 优先使用Etag，因为Last-Modified 的精度在秒级，精度不高，如果资源被重复生成，而内容不变用Etag比较精确。（因为重复生成时间会变则Last-Modified会变，Etag是基于内容生成的，所以Etag不会变） ​ 刷新方式对缓存的影响 正常操作：地址栏输入 url，跳转链接，前进后退；强制缓存有效，协商缓存有效 手动刷新：F5，右击菜单刷新；强制缓存失效，协商缓存有效 强制刷新：ctrl + f5；强制缓存失效，协商缓存失效 5.https http和https http 明文传书，敏感信息容易被中间劫持 https：http + 加密，劫持了也无法解密 现代浏览器已经开始强制 https 协议 加密方式：对称加密，非对称加密 对称加密：服务端和客户端用同一个 key 在传输过程中加密和解密，不安全，因为key也在传输过程中传输 过程 非对称加密：一对 key，pubkey 加密后只能用 key 来解密 过程 https 用了这两种方式加密 过程 https 证书 中间人攻击，把 pubkey 掉包 使用第三方证书 浏览器校验证书 过程","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}]},{"title":"JS面试篇-Part8","slug":"JS面试篇-Part8","date":"2021-12-11T02:39:39.000Z","updated":"2021-12-18T10:46:49.225Z","comments":true,"path":"2021/12/11/JS面试篇-Part8/","link":"","permalink":"http://example.com/2021/12/11/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part8/","excerpt":"1. ajax","text":"1. ajax 1.1 知识点 XMLHttpRequest 1.前置知识 xhr.readyState 的情况 状态码 含义 0 （未初始化），还没有调用send() 方法 1 （载入）已调用send()方法，正在发送请求 2 （载入完成）send() 方法已经执行完成，接收到全部响应内容 3 （交互）正在解析响应内容 4 （完成）响应内容解析完成，可以在客户端调用 xhr.status 状态码 含义 2xx 请求处理成功（200） 3xx 重定向，浏览器直接跳转，301永久，302暂时跳一次，304资源未改变 4xx 客户端请求错误 404请求地址错误，403客户端没有权限 5xx 服务器端错误 2.请求 get，post，send 123456789101112131415// get 请求const xhr = new XMLHttpRequest()// 方法，地址，true表示异步请求（false表示同步请求）xhr.open(&#x27;GET&#x27;,&#x27;/data/test.json&#x27;,true)xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; alert(xhr.responseText) &#125;else&#123; console.log(&#x27;错误&#x27;); &#125; &#125;&#125;// 不需要sendxhr.send(null) 1234567891011121314151617181920// post 请求xhr.open(&#x27;POST&#x27;,&#x27;/login&#x27;,true)xhr.onreadystatechange = function()&#123;// 记得要判断状态 if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; console.log( JSON.parse(xhr.responseText) ); &#125;else&#123; console.log(&#x27;错误&#x27;); &#125; &#125;&#125;const postData = &#123; userName: &quot;xxx&quot;, password: &quot;xxx&quot;&#125;// 记得send的是字符串xhr.send(JSON.stringify(postData)) 同源策略，跨域 同源策略： ajax 请求时，浏览器要求当前网页和server必须同源（安全），针对的是浏览器环境 搜索引擎，爬虫等是从服务端发送的，一般来说不被同源策略限制 同源：协议、域名、端口，三者必须一致 eg 前端：http://a.com:8080/; server: https://b.com/api/xxx (协议域名端口都不同) 加载图片 css js 可无视同源策略 标签 作用 img 统计打点，可使用第三方统计服务 link，script 使用CDN（一般都是外域） script 实现JSONP 跨域 所有的跨域都必须经过 server 端允许和配合 未经 server 端允许就实现跨域，说明浏览器有漏洞 跨域的实现 JSONP 服务器可以任意动态拼接数据返回，只要符合 html /js 格式要求，并不一定是一个 html /js 文件 12345678910// 原理：利用 script 实现跨域，服务端动态拼接数据返回&lt;p&gt;一段文字&lt;/p&gt; &lt;script&gt; // callback 要挂在 window 上才可以全局调用 window.callback = function(data)&#123; console.log(data); &#125; &lt;/script&gt; // 下面的端口和我们本身的html端口不一样，所以用 script 访问 &lt;script src=&quot;http://localhost:8002/jsonp.js&quot;&gt;&lt;/script&gt; CORS 服务器设置 http header 1.2 问题 手写一个ajax 12345678910111213141516171819202122232425262728293031// 手写 ajaxfunction ajax(url)&#123; const p = new Promise((resolve,reject)=&gt;&#123; const xhr = new XMLHttpRequest() //xhr.open()的第三个参数为布尔值，可选，默认为true表示是否异步执行操作，默认为true。如果值为false，send()方法直到收到答复前不会返回。如果true，已完成事务的通知可供事件监听器使用。 xhr.open(&#x27;GET&#x27;,url) xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; resolve( JSON.parse(xhr.responseText) ) &#125; else if(xhr.status === 404)&#123; reject(new Error(&#x27;404 not found&#x27;)) &#125; &#125; &#125; xhr.send(null) &#125;) return p&#125;const url = &#x27;/data/test.json&#x27; // 正确的 url 和错误的 urlajax(url).then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.error(err)&#125;) 跨域的实现方式 JSONP（理解原理） CORS 纯服务端 1.3 常用插件 jquery fetch axios 2.存储2.1 知识点 cookie 实际上用于 浏览器 和 server 之间通讯，但可以被借用到存储中 前端可以用 document.cookie = ‘’ 添加， 修改，获得，只要不删除存储的内容就一直在 缺点：最大存 4kb；http请求时需要发送到服务端，增加请求数据量；只能用 document.cookie 来修改，不好用 localStorge 和 sessionStorage HTML 专门为存储设计，最大可存 5M API 简易可用 setItem getItem 不会随着 http 发送出去 区别：localStorage 数据会永久存储，除非代码手动删除；sessionStorage 数据存在于当前会话，浏览器关闭就清空 localStorage 使用的比较多 2.2 问题 cookie localStorage sessionStorage 的区别 存储大小 API易用性 是否随http发送","categories":[],"tags":[{"name":"ajax 跨域 同源策略","slug":"ajax-跨域-同源策略","permalink":"http://example.com/tags/ajax-%E8%B7%A8%E5%9F%9F-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"}]},{"title":"JS面试篇-Part7","slug":"JS面试篇-Part7","date":"2021-12-10T01:17:09.000Z","updated":"2021-12-16T09:30:58.125Z","comments":true,"path":"2021/12/10/JS面试篇-Part7/","link":"","permalink":"http://example.com/2021/12/10/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part7/","excerpt":"1.与前面知识的联系与区别 JS基础知识，规定语法（ECMA 262 标准规定）","text":"1.与前面知识的联系与区别 JS基础知识，规定语法（ECMA 262 标准规定） 变量的类型和计算、原型和原型链、作用域和闭包等 JS Web API，网页操作的API （W3C 标准规定） DOM、BOM、事件绑定、ajax、存储 前者是后者的基础，两者结合才能实际应用 2.DOM（Document Object Model）操作知识点2.1 DOM本质 HTML是XML的一种，结构和标签都已经规定好了 DOM 本质是一棵树（和HTML是两个意思，HTML是一个文件，DOM是浏览器根据HTML文件初始化的一棵树） 2.2 DOM节点操作2.2.1 获取DOM节点1234 &lt;!-- CSS --&gt; .red &#123; color: red;&#125; 12345678910&lt;!-- HTML结构 --&gt;&lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt;&lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;一段文字 1&lt;/p&gt; &lt;p&gt;一段文字 2&lt;/p&gt; &lt;p&gt;一段文字 3&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;container&quot;&gt; &lt;p&gt;图片&lt;/p&gt; &lt;img src=&quot;../image/xiaoxin.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 1234567891011121314151617181920// js// 1. 通过id来获取const div1 = document.getElementById(&#x27;div1&#x27;)console.log(&#x27;div1&#x27;,div1);// 2. 通过 tagName 获取const divList = document.getElementsByTagName(&#x27;div&#x27;)console.log(&#x27;divList length&#x27;,divList.length);console.log(&#x27;divList[0]&#x27;,divList[0]);// 3. 通过class获取const containerList = document.getElementsByClassName(&#x27;container&#x27;)console.log(&#x27;containerList length&#x27;,containerList.length);console.log(&#x27;containerList[0]&#x27;,containerList[0]);// 4. querySelectorconst pList = document.querySelectorAll(&#x27;p&#x27;)console.log(&#x27;pList&#x27;,pList); 2.2.2 修改节点属性 attribute 和 property attribute 修改html属性，会改变HTML（DOM树）结构 123// attribute 可以作用到DOM结构里面p1.setAttribute(&#x27;style&#x27;,&#x27;font-size: 50px&#x27;) // p1 的标签中会添加上修改后的样式console.log(p1.getAttribute(&#x27;style&#x27;)); property 修改对象属性，不会体现到HTML结构中 1234567891011const pList = document.querySelectorAll(&#x27;p&#x27;)const p1 = pList[0]// property 形式 改变页面样式或者渲染结构p1.style.width = &#x27;100px&#x27;console.log(p1.style.width);p1.className = &#x27;red&#x27;console.log(p1.className);// 获得nodeName（标签节点的名称）console.log(p1.nodeName);// 获得nodeType 一般是 1 不常用console.log(p1.nodeType); 二者都有可能引起DOM重新渲染，但是attribute一般来说都会，所以尽量用property操作js 2.2 DOM结构操作 新增/移动节点 12345678910// 1.增加节点const div1 = document.getElementById(&#x27;div1&#x27;)const newP = document.createElement(&#x27;p&#x27;)newP.innerHTML = &#x27;this is newP&#x27;div1.appendChild(newP)// 2. 移动节点 获取节点以后 用 appendChild 添加至想要移动到的区域const p1 = document.getElementById(&#x27;p1&#x27;)const div2 = document.getElementById(&#x27;div2&#x27;)div2.appendChild(p1) 获取子元素列表，获取父元素 12345678910111213141516171819// 3.获取父元素console.log(p1.parentNode);// 4. 获取子元素列表 全部获取 不只有 p 标签 还有 text 可以用nodeType 来区分，一般标签为 1，text 为 3const div1ChildNodes = div1.childNodesconsole.log(div1ChildNodes);// 按照一定规则找出想要的标签// Array.prototype.slice.call(div1ChildNodes) 把 div1ChildNodes 变成数组// filter 按照一定条件过滤const div1ChildNodesP = Array.prototype.slice.call(div1ChildNodes).filter(child=&gt;&#123; if(child.nodeType === 1)&#123; return true &#125; else&#123; return false &#125;&#125;)console.log(div1ChildNodesP ); 删除元素 12// 删除一个 p 标签div1.removeChild(div1ChildNodesP[0]) 2.3 DOM性能 DOM 操作非常昂贵，避免频繁的DOM操作 对DOM查询做缓存 12345678910// 不缓存 DOM 查询结果for(let i = 0;i&lt;document.getElementsByTagName(&#x27;p&#x27;).length;i++)&#123; // 每次循环都会计算length，频繁进行DOM查询&#125;// 缓存 DOM 查询结果let len = document.getElementsByTagName(&#x27;p&#x27;)for(let i = 0;i&lt;len; i++)&#123; // 缓存length 只会查询一次DOM&#125; 将频繁操作改为一次性操作 eg：给页面插入十个 li 标签，（提前在网页创建一个 id 为 list 的 div） 1234567// 频繁操作的情况 const list = document.getElementById(&#x27;list&#x27;)for(let i = 0;i&lt;10;i++)&#123; const li = document.createElement(&#x27;li&#x27;) li.innerHTML = `List item $&#123;i&#125;` list.appendChild(li)&#125; 1234567891011const list = document.getElementById(&#x27;list&#x27;)// 创建一个文档片段 此时还没有插入到 DOM 结构中const frag = document.createElement(&#x27;fragment&#x27;)for(let i = 0;i&lt;10;i++)&#123; const li = document.createElement(&#x27;li&#x27;) li.innerHTML = `List item $&#123;i&#125;` // 先把 li 插入到 文档片段中 frag.appendChild(li)&#125;// 最后一次性插入到 DOM 结构中list.appendChild(frag) 2.4 DOM相关问题 Q: DOM 是哪种数据结构？ ​ A: 树 Q: Property 和 attribute 的区别 A: property 修改对象属性，不会体现到HTML结构中，attribute 修改 HTML属性，会体现到HTML 结构中 ​ 二者都有可能引起DOM重渲染，但是 property 主要是在js中修改，性能更好更推荐 Q: DOM 性能 ​ A: 频繁操作和一次性操作 3.BOM（Browser Object Model）问题3.1 BOM知识点 navigator(识别浏览器的类型) 和 screen 1234567const ua = navigator.userAgent // navigator.userAgent 获得浏览器的信息，但判断不是很准确，确切的判断浏览器类型等需要具体策略const isChrome = ua.indexOf(&#x27;Chrome&#x27;)console.log(isChrome)// screenconsole.log(screen.height)console.log(screen.width) location (分别拆解 url 各个部分)和 history 12345678910console.log(location.href);console.log(location.protocol);console.log(location.host);console.log(location.search);console.log(location.hash);console.log(location.pathname);// historyhistory.backhistory.forward 4.事件4.0 知识点 事件绑定 事件冒泡 事件代理 4.1 事件绑定1234567891011// 事件绑定函数(不全面)const bindEvent = (elem, type, fn)=&gt;&#123; elem.addEventListener(type,fn)&#125;// egconst btn1 = document.getElementById(&#x27;btn1&#x27;)bindEvent(btn1,&#x27;click&#x27;,(e)=&gt;&#123; console.log(e.target); // 获取点击对象 e.preventDefault() // 阻止默认行为 alert(&#x27;点击成功&#x27;)&#125;) 4.2 事件冒泡 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个事件处理程序（同样的激活事件，比如说 click，激活之后要做什么要看具体的回调函数），如果是，则运行它 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达&lt;html&gt;元素。 12345678910&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt; &lt;/div&gt; 1234567891011121314const body = document.bodyconst p1 = document.getElementById(&#x27;p1&#x27;)// 1.阻止事件冒泡bindEvent(p1,&#x27;click&#x27;,e=&gt;&#123; e.stopPropagation() // 阻止事件冒泡 console.log(e.target); console.log(&#x27;激活&#x27;);&#125;)// 2.利用事件冒泡机制，多个p标签都实现取消功能，那么给它们的共同祖先绑定可以一次性实现对应功能bindEvent(body,&#x27;click&#x27;,e=&gt;&#123; console.log(e.target); console.log(&#x27;取消&#x27;);&#125;) 4.3 事件代理 代码简洁，减少浏览器内存占用 不能滥用，有一定复杂度，一般用在瀑布流上 1234567&lt;div id=&quot;div3&quot;&gt; &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;&lt;br&gt; &lt;button&gt;点击加载更多...&lt;/button&gt; &lt;/div&gt; 123456789// 事件代理const div3 = document.getElementById(&#x27;div3&#x27;)bindEvent(div3,&#x27;click&#x27;,e=&gt;&#123; e.stopPropagation() // 阻止默认事件：点击 a标签 跳转到链接 const target = e.target if(target.nodeName === &#x27;A&#x27;)&#123; // 如果点击了 a标签，进行相应的逻辑，所以需要判断 alert(target.innerHTML); &#125;&#125;) 4.4 相关题目 编写一个通用的事件监听函数 把 target 改成 this 12345678910111213141516171819202122function bindEvent (elem, type, selector,fn)&#123; // 只传入三个参数，说明没有选择器 if(fn == null)&#123; fn = selector selector = null &#125; // 这里用普通函数可以用this，用箭头函数的话，fn.call 会把 this 指向window // 如果用箭头函数，那么使用该函数时就不要用 this ，给谁绑就写谁的名字 elem.addEventListener(type,function(e)&#123; const target = e.target // 代理事件绑定 if(selector )&#123; if(target.matches(selector))&#123; fn.call(target,e) &#125; &#125; // 普通事件绑定 else&#123; fn.call(target,e) &#125; &#125;)&#125; 123456// egconst div3 = document.getElementById(&#x27;div3&#x27;)bindEvent(div3,&#x27;click&#x27;,&#x27;a&#x27;,function(e)&#123; e.stopPropagation() alert(this.innerHTML)&#125;) 使用箭头函数（虽然代码量比较少，但是调用的时候不那么优雅） 1234567891011// 通用的事件绑定函数function bindEvent (elem, type, selector,fn)&#123; // 只传入三个参数，说明没有选择器 if(fn == null)&#123; fn = selector selector = null &#125; elem.addEventListener(type,e=&gt;&#123; fn(e) &#125;)&#125; 123456const div3 = document.getElementById(&#x27;div3&#x27;)bindEvent(div3,&#x27;click&#x27;,&#x27;a&#x27;,e=&gt;&#123; e.stopPropagation() // 用 e.target 表示触发元素 alert(e.target.innerHTML)&#125;) 描述事件冒泡的流程 基于DOM树形结构 事件会顺着触发元素向上冒泡 应用场景：事件代理 无限下拉的图片列表，如何监听每个图片的点击？ 事件代理 用 e.target 获取触发元素 用 matches 来判断是否是触发元素","categories":[],"tags":[{"name":"JS Web API","slug":"JS-Web-API","permalink":"http://example.com/tags/JS-Web-API/"}]},{"title":"JS面试篇-Part6","slug":"JS面试篇-Part6","date":"2021-12-09T06:33:35.000Z","updated":"2021-12-16T09:29:31.133Z","comments":true,"path":"2021/12/09/JS面试篇-Part6/","link":"","permalink":"http://example.com/2021/12/09/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part6/","excerpt":"1.宏任务 macroTask 和 微任务 microTask 宏任务： setTimeout，setInterval，Ajax，DOM事件 微任务：Promise async/await","text":"1.宏任务 macroTask 和 微任务 microTask 宏任务： setTimeout，setInterval，Ajax，DOM事件 微任务：Promise async/await 12345678910console.log(100); // 1setTimeout(()=&gt;&#123; console.log(200);&#125;) // 4Promise.resolve().then(()=&gt;&#123; console.log(300); // 3&#125;)console.log(400); // 2 2. eventloop和DOM渲染 eventloop里面 call Stack 空的时候，DOM 开始渲染 微任务比宏任务执行时间要早，在DOM渲染前触发 宏任务在DOM渲染完成之后触发 代码示例：promise→DOM渲染→setTImeout 12345678910111213141516171819const $p1 = $(&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;)const $p2 = $(&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;)const $p3 = $(&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;)$(&#x27;#container&#x27;) .append($p1) .append($p2) .append($p3)Promise.resolve().then(()=&gt;&#123; console.log(&#x27;length1&#x27;, $(&#x27;#container&#x27;).children().length); alert(&#x27;Promise then&#x27;)&#125;) // DOM渲染前触发setTimeout(()=&gt;&#123; console.log(&#x27;length2&#x27;, $(&#x27;#container&#x27;).children().length); alert(&#x27;setTimeout&#x27;)&#125;) // DOM渲染后触发 3.微任务执行更早的原因 微任务是ES6语法规定的，不会经过Web APIs 宏任务是由浏览器规定的，按照eventloop常规流程（浏览器→call stack→WebAPIs（等待时机）→进入Callback QUeue→触发eventloop） 总的来说：1. Call Stack清空（同步代码都执行完） ​ 2.执行当前的微任务（micro task stack） ​ 3.尝试DOM渲染 ​ 4.触发eventloop（宏任务） 4.问题4.1 描述eventloop流程（可画图）A:回顾eventloop的过程即可，不需要一下子就把DOM渲染还有微任务宏任务这些一起说出来，容易乱 4.2 宏任务和微任务，二者区别A: 二者分类，区别就是执行时机，微任务在DOM渲染前，宏任务在DOM渲染后 4.3 promise的三种状态，变化A: pending resolved rejected；pending可以变成resolve也可以变成rejected，不可逆；resolve可以触发 then，reject可以触发 catch 4.4 promise场景题 part5 里的第 4点4.5 async/await场景题 执行async 返回的promise 不管里面是什么 执行 await 后面的相当于 then 123456789async function fn()&#123; return 100&#125; (async function ()&#123; const a = fn() // async 返回的是一个 promise 对象 const b = await fn() // await 相当于 then，可以拿到 return 的数据 console.log(a); // Promise &#123; 100 &#125; console.log(b); // 100 &#125;)() 1234567891011(async function()&#123; console.log(&#x27;start&#x27;); const a = await 100 // 相当于返回 100 console.log(&#x27;a&#x27;,a); const b = await Promise.resolve(200) console.log(&#x27;b&#x27;,b); const c = await Promise.reject(200) // await 相当于then 只会被resolve状态触发，所以rejected状态以后的所有代码都不会被执行 console.log(&#x27;c&#x27;,c); console.log(&#x27;end&#x27;);&#125;)()// 依次打印 start a 100 b 200 4.6 promise和setTimeout的顺序123456789101112console.log(100); // 1setTimeout(()=&gt;&#123; console.log(200);&#125;) // 4Promise.resolve().then(()=&gt;&#123; console.log(300); // 3&#125;)console.log(400); // 2// 依次打印 100 400 300 200 4.6 外加 async/await 的顺序问题12345678910111213141516171819202122232425262728293031323334// 先执行同步，call stack清空，执行微任务，DOM渲染，再执行宏任务async function async1()&#123; console.log(&#x27;async1 start&#x27;); // 2.立即执行async里的函数体 await async2() // 先执行 async2 再执行 await，await后面的都是异步回调 作为微任务 console.log(&#x27;async1 end&#x27;); // 6 执行微任务 打印async1 end（如果前面没有await 则也一样立即执行）&#125; async function async2()&#123; console.log(&#x27;async2&#x27;); // 3.立即执行 async里面的函数体&#125;console.log(&#x27;script start&#x27;); // 1.打印 script startsetTimeout(()=&gt;&#123; console.log(&#x27;setTimeout&#x27;);&#125;,0) // 8.宏任务 最后执行async1() // 顺序执行 async1 的函数体 执行到3 async1 里面的同步代码就执行完了 继续往下走new Promise(function(resolve)&#123; console.log(&#x27;promise1&#x27;); // 4.promise里面的function立即执行 resolve(); // 返回resolve状态 后面的then就是回调了 作为微任务&#125;).then(function()&#123; console.log(&#x27;promise2&#x27;); //7. 执行微任务 打印 promise2&#125;)console.log(&#x27;script end&#x27;); // 5. 到这里整个函数的同步任务就执行完了 开始执行微任务// script start// async1 start// async2// promise1// script end// async1 end// promise2// setTimeout 5.手写promise5.1要求 初始化，异步调用 1234567// 初始化const p = newMyPromise((resolve,reject)=&gt;&#123; // resolve(data) 同步调用 setTimeout(()=&gt;&#123; resolve(data) // 异步调用 &#125;)&#125;) ​ 2. then catch 链式调用 123456789101112131415161718p.then(data=&gt;&#123; return data + 1&#125;).then(data =&gt;&#123; return data + 2&#125;).catch(err =&gt;&#123; console.error(err)&#125;)// 拆开写，只是为了表述出 then catch 返回出的是一个新的promiseconst p11 = p.then(data =&gt;&#123; return data + 1&#125;)const p12 = p11.then(data =&gt;&#123; return data + 2&#125;)const p13 = p12.catch(err =&gt;&#123; console.error(err)&#125;) 支持常见API： .resolve .reject .all .race 1234const p2 = MyPromise.resolve(200)const p3 = MyPromise.reject(&#x27;错误信息...&#x27;)const p4 = MyPromise.all([p1,p2])const p5 = MyPromise.race([p1,p2]) 5.2 代码实现 （By双越老师）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/**/** * @description MyPromise * @author 双越 */ class MyPromise &#123; state = &#x27;pending&#x27; // 状态，&#x27;pending&#x27; &#x27;fulfilled&#x27; &#x27;rejected&#x27; value = undefined // 成功后的值 reason = undefined // 失败后的原因 resolveCallbacks = [] // pending 状态下，存储成功的回调 rejectCallbacks = [] // pending 状态下，存储失败的回调 constructor(fn) &#123; const resolveHandler = (value) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;fulfilled&#x27; this.value = value this.resolveCallbacks.forEach(fn =&gt; fn(this.value)) &#125; &#125; const rejectHandler = (reason) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectCallbacks.forEach(fn =&gt; fn(this.reason)) &#125; &#125; try &#123; fn(resolveHandler, rejectHandler) &#125; catch (err) &#123; rejectHandler(err) &#125; &#125; then(fn1, fn2) &#123; fn1 = typeof fn1 === &#x27;function&#x27; ? fn1 : (v) =&gt; v fn2 = typeof fn2 === &#x27;function&#x27; ? fn2 : (e) =&gt; e if (this.state === &#x27;pending&#x27;) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; this.resolveCallbacks.push(() =&gt; &#123; try &#123; const newValue = fn1(this.value) resolve(newValue) &#125; catch (err) &#123; reject(err) &#125; &#125;) this.rejectCallbacks.push(() =&gt; &#123; try &#123; const newReason = fn2(this.reason) reject(newReason) &#125; catch (err) &#123; reject(err) &#125; &#125;) &#125;) return p1 &#125; if (this.state === &#x27;fulfilled&#x27;) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; try &#123; const newValue = fn1(this.value) resolve(newValue) &#125; catch (err) &#123; reject(err) &#125; &#125;) return p1 &#125; if (this.state === &#x27;rejected&#x27;) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; try &#123; const newReason = fn2(this.reason) reject(newReason) &#125; catch (err) &#123; reject(err) &#125; &#125;) return p1 &#125; &#125; // 就是 then 的一个语法糖，简单模式 catch(fn) &#123; return this.then(null, fn) &#125;&#125;MyPromise.resolve = function (value) &#123; return new MyPromise((resolve, reject) =&gt; resolve(value))&#125;MyPromise.reject = function (reason) &#123; return new MyPromise((resolve, reject) =&gt; reject(reason))&#125;MyPromise.all = function (promiseList = []) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; const result = [] // 存储 promiseList 所有的结果 const length = promiseList.length let resolvedCount = 0 promiseList.forEach(p =&gt; &#123; p.then(data =&gt; &#123; result.push(data) // resolvedCount 必须在 then 里面做 ++ // 不能用 index resolvedCount++ if (resolvedCount === length) &#123; // 已经遍历到了最后一个 promise resolve(result) &#125; &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;) return p1&#125;MyPromise.race = function (promiseList = []) &#123; let resolved = false // 标记 const p1 = new Promise((resolve, reject) =&gt; &#123; promiseList.forEach(p =&gt; &#123; p.then(data =&gt; &#123; if (!resolved) &#123; resolve(data) resolved = true &#125; &#125;).catch((err) =&gt; &#123; reject(err) &#125;) &#125;) &#125;) return p1&#125;","categories":[],"tags":[{"name":"微任务 宏任务 eventloop和dom渲染 手写promise","slug":"微任务-宏任务-eventloop和dom渲染-手写promise","permalink":"http://example.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E5%AE%8F%E4%BB%BB%E5%8A%A1-eventloop%E5%92%8Cdom%E6%B8%B2%E6%9F%93-%E6%89%8B%E5%86%99promise/"}]},{"title":"JS面试篇-Part5","slug":"JS面试篇-Part5","date":"2021-12-04T12:21:45.000Z","updated":"2021-12-16T09:28:39.767Z","comments":true,"path":"2021/12/04/JS面试篇-Part5/","link":"","permalink":"http://example.com/2021/12/04/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part5/","excerpt":"1.event loop(事件循环/事件轮询)","text":"1.event loop(事件循环/事件轮询) JS是单线程运行的 从前到后逐行执行；某一行报错则停止，不执行后面的代码；先执行同步再执行异步 异步要基于回调来实现 event loop 就是异步回调的实现原理 演示代码如下 ```jsconsole.log(‘Hi’);setTimeout(function cb1() { console.log(&#39;callback&#39;); }, 1000);console.log(‘Bye’); 12345678910111213141516171819202122232425262728- 解释如下： 1. 同步代码，一行一行放在 Call Stack 里面执行 2. 遇到异步，先记录下来，等待时机到达（定时，网络请求等） 3. 时机到了，就移动到 Call Queue 里面 4. 如果 Call Stack 为空（即同步代码执行完），Event Loop 开始工作 5. 轮询查找 Callback Queue,如有则移动到 Call Stack 执行 6. 然后继续轮询查找#### 2.DOM事件和Event Loop- JS是单线程的- 异步（setTimeout，ajax）使用回调，基于event loop- DOM事件也使用回调，基于event loop （DOM事件不是异步）```js &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;script&gt; let btn = document.querySelector(&#x27;button&#x27;) console.log(&#x27;HI&#x27;); btn.addEventListener(&#x27;click&#x27;,function(e)&#123; console.log(&#x27;button clicked&#x27;); &#125;) console.log(&#x27;Bye&#x27;); &lt;/script&gt; 同步代码立即执行，btn.addEventListener也是立即执行，但是里面的回调函数先进去Call Stack 等待，点击以后进入Web APIs 再进入 Callback Queue 给event loop 执行 3.Promise深入 三种状态 pending、resolved、rejected 12345678910111213141516171819202122232425// 三种状态const p1 = new Promise((resolve,reject)=&gt;&#123;&#125;)console.log(&#x27;p1&#x27;,p1); // p1 Promise &#123; &lt;pending&gt; &#125;const p2 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve() &#125;)&#125;)console.log(&#x27;p2&#x27;,p2); // pendingsetTimeout(()=&gt;&#123; console.log(&#x27;p2-setTimeOut&#x27;,p2); // resolved （fulfilled）&#125;)const p3 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject() &#125;)&#125;)console.log(&#x27;p3&#x27;,p3); // pendingsetTimeout(()=&gt;&#123; console.log(&#x27;p3-setTimeout&#x27;,p3); // rejected&#125;) 状态的表现和变化 pending状态，不会触发 then 和 catch resolved 状态，会触发 then 回调函数 rejected 状态，会触发 catch 回调函数 1234567891011121314 // 状态转换 不会触发什么 会触发什么const p1 = Promise.resolve(100) // 单独用的时候，promise 不用 newp1.then((data)=&gt;&#123; console.log(&#x27;data1&#x27;,data);&#125;).catch(err=&gt;&#123; console.error(&#x27;err1&#x27;,err)&#125;) // resolve 只会执行 then 结果 data1 100const p2 = Promise.reject(&#x27;err&#x27;)p2.then(data=&gt;&#123; console.log(&#x27;data2&#x27;,data);&#125;).catch(err=&gt;&#123; console.log(&#x27;err2&#x27;,err);&#125;) // reject 只会执行 catch 结果 err2 err then 和 catch 对状态的影响 then 正常返回 resolved ， 里面有报错则返回 rejected （完整来说eg：then正常返回一个 resolved 状态的 promise） 12345678910111213141516171819202122const p1 = Promise.resolve().then(()=&gt;&#123; return 100 // then 正常执行&#125;)console.log(&#x27;p1&#x27;,p1); // 一开始是pending 执行后是 resolvedconst p2 = Promise.resolve().then(()=&gt;&#123; throw new Error([&#x27;then error&#x27;]) // then 里面有报错 返回 rejected&#125;)console.log(&#x27;p2&#x27;,p2); // 一开始是pending 执行后是 rejected// 执行p1.then(data=&gt;&#123; console.log(data); // 因为 p1 = 返回了一个resolved状态的promise 所以可以执行 then&#125;).catch(err=&gt;&#123; console.error(&#x27;err1&#x27;,err); // catch 不会被执行&#125;)p2.then(data=&gt;&#123; console.log(data);&#125;).catch(err=&gt;&#123; console.error(&#x27;err2&#x27;,err) // p2 = 返回了一个rejected 状态的 promise 执行catch // 打印 err2 Error: then error（p2 throw 出来的错误）&#125;) catch 正常返回 resolved，里面有报错则返回 rejected 123456789101112const p3 = Promise.reject(&#x27;my error&#x27;).catch(err=&gt;&#123; console.error(&#x27;err&#x27;,err)&#125;)console.log(&#x27;p3&#x27;,p3); // reject 是正常执行了的 所以 promise 的状态是 resolved（fulfilled）p3.then(()=&gt;&#123; console.log(&#x27;100&#x27;); // 可以打印出来 100&#125;)const p4 = Promise.reject(&#x27;my error&#x27;).catch(err=&gt;&#123; throw new Error(&#x27;catch error&#x27;)&#125;)console.log(&#x27;p4&#x27;,p4); // reject 的 catch 报错，返回一个 rejected 的 promise 4.Promise 的状态相关问题 第一题 123456789Promise.resolve().then(()=&gt;&#123; console.log(1); // resolve 状态 可以执行then then没有报错，返回 resolve状态的promise&#125;).catch(()=&gt;&#123; console.log(2);&#125;).then(()=&gt;&#123; console.log(3); // 所以上一个then返回的promise执行下一个then的回调，不会执行catch&#125;) // 最后返回一个 resolve 状态的promise// 打印 1 3 第二题 12345678910Promise.resolve().then(()=&gt;&#123; // resolve 执行 then console.log(1); throw new Error(&#x27;erro1&#x27;) // 报错 返回reject&#125;).catch(()=&gt;&#123; console.log(2); // 执行 catch成功 返回 resolve&#125;).then(()=&gt;&#123; console.log(3); // 所以会执行 then&#125;)// 打印 1 2 3 第三题 12345678910Promise.resolve().then(()=&gt;&#123; // resolve 执行 then console.log(1); throw new Error(&#x27;error1&#x27;) // 报错 返回 reject 执行 catch&#125;).catch(()=&gt;&#123; console.log(2); // 成功执行 返回resolve &#125;).catch(()=&gt;&#123; console.log(3); // 在resolve状态下 不能被执行&#125;)// 打印 1 2 5.async/await 异步回调 callback hell Promise then catch 链式调用，但也基于回调函数 async/await 是同步语法，彻底消灭回调函数 12345678910111213141516171819202122232425262728function loadImg(src) &#123; const res = new Promise((resolve,reject) =&gt; &#123; const img = document.createElement(&#x27;img&#x27;) img.onload = () =&gt;&#123; resolve(img) &#125; img.onerror = ()=&gt;&#123; const err = new Error(`图片加载失败$&#123;src&#125;`) reject(err) &#125; img.src = src &#125;) return res&#125; const url1 = &#x27;/image/xiaoxin.jpg&#x27; const url2 = &#x27;/image/scene.jpg&#x27; // 这里加 ！ 是为了避免上面的语句没有打分号 使得函数不能正确识别 // 和之前插入图片的代码作比较 可以发现简洁了很多!(async function () &#123; const img1 = await loadImg(url1) console.log(img1.height,img1.width); const img2 = await loadImg(url2) console.log(img2.height,img2.width); &#125;)() async/await 和 Promise 相关的关系 执行 async 函数，返回的是 Promise 对象 1234567async function fn1()&#123; return 100 // async 返回的是 Promise 函数&#125;console.log(&#x27;fn1:&#x27;,fn1()); // Promise &#123; 100 &#125; fn1().then((data)=&gt;&#123; console.log(data); // 100 &#125;) await 相当于 Promise 的 then 1234567// 1.await 相当于 then!(async function () &#123; // 立即执行匿名函数 const p1 = Promise.resolve(300) const data1 = await p1 // await 相当于 promise then ，直接拿到 return 的数据 console.log(data1); // 300&#125;)() 123456// 2.如果 await 后面跟的不是 promise 的值 相当于封装成 一个 promise!(async function () &#123; const data2 = await 400 // await Promise.resolve(400) console.log(data2); // 400&#125;)() 12345// 3. await 后面接一个返回promise对象的函数!(async function () &#123; const data3 = await fn1() console.log(data3); // 100&#125;)() try…catch 可以捕获异常，代替了 Promise 的 catch 12345678910//1.try...catch举例!(async function()&#123; const p4 = Promise.reject(&#x27;err&#x27;) try&#123; const res = await p4 console.log(&#x27;res&#x27;,res); &#125;catch(ex)&#123; console.error(&#x27;ex&#x27;,ex) // ex err &#125;&#125;)() 123456// 2.await 的一种冲突，用try...catch来解决!(async function()&#123; const p5 = Promise.reject(&#x27;err&#x27;) const res = await p5 // 因为 await 相当于 then 所以 rejected状态的promise走不到这一步 console.log(res);&#125;) 6. 异步的本质是回调 async-await 是语法糖，只是语法层面上像同步，但是很好用 代码示例 1234567891011121314151617181920212223// async 里面的函数体（除了await）都是立即执行的async function async1() &#123; console.log(&#x27;async1 start&#x27;); //2. await async2() // 先执行async函数体内容 然后执行await // 因为 async相当于返回 undefined 所以 await后面没有promise // 但是 await 后面的语句都可以当做是异步 所以要最后执行 // 最后一句类似于setTimeout(()=&gt;&#123; console.log(&#x27;async1 end&#x27;);&#125;) // (当然只是举例，也有可能是promise.then()) console.log(&#x27;async1 end&#x27;); //5.&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);//3. &#125;console.log(&#x27;script start&#x27;); //1.async1()console.log(&#x27;script end&#x27;);//4.// script start//async1 start//async2//script end//async1 end 1234567891011121314151617181920212223242526async function async1() &#123; console.log(&#x27;async1 start&#x27;); await async2() // 下面三句都是异步回调 console.log(&#x27;async1 end&#x27;); await async3() // 下面一行是异步回调 console.log(&#x27;async1 end2&#x27;);&#125;async function async2() &#123; console.log(&#x27;async2&#x27;); &#125;async function async3() &#123; console.log(&#x27;async3&#x27;);&#125;console.log(&#x27;script start&#x27;); async1()console.log(&#x27;script end&#x27;); // async1 start// async2// script end// async1 end// async3// async1 end2 7.for…of for … in (以及 forEach for) 是常规的同步遍历 for … of 常用于 异步的遍历（需要熟练掌握） 1234567891011121314151617181920212223242526function multi(num)&#123; return new Promise( resolve=&gt;&#123; setTimeout(()=&gt;&#123; resolve(num*num) &#125;,1000) &#125; )&#125;const nums = [1,2,3]// 1s 间隔后立即打印出 res 的三个结果 1 4 9nums.forEach( async(i)=&gt;&#123; const res = await multi(i) console.log(res); &#125; ) // 如果要按照 1s 间隔逐个打印出来 for...of 用在异步当中!(async function()&#123; for(let i of nums)&#123; const res = await multi(i) console.log(res); &#125;&#125;)()","categories":[],"tags":[{"name":"EventLoop Promise async await for...of","slug":"EventLoop-Promise-async-await-for-of","permalink":"http://example.com/tags/EventLoop-Promise-async-await-for-of/"}]},{"title":"JS面试篇-Part4","slug":"JS面试篇-Part4","date":"2021-12-04T09:28:51.000Z","updated":"2021-12-18T08:48:04.903Z","comments":true,"path":"2021/12/04/JS面试篇-Part4/","link":"","permalink":"http://example.com/2021/12/04/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part4/","excerpt":"1.单线程和异步","text":"1.单线程和异步 1.1 单线程 JS是单线程语言，同一时间只能做一件事，会阻塞代码执行 因为JS可以修改DOM结构，所以JS和DOM渲染共用一个线程 浏览器和nodejs已经支持JS启动进程，如Web Worker 1.2 为什么要异步 遇到等待（网络请求，定时任务） 不能卡住 基于callback来实现，不会阻塞代码执行 2.应用场景 定时任务 如 setTImeout ```js// setTimeoutconsole.log(100);setTimeout(function() {console.log(200); },1000)console.log(300);12345678- ```js // setInterval 循环执行 每隔 interval 执行一次 console.log(100); setInterval(() =&gt; &#123; console.log(200); &#125;, 1000); console.log(300); 网络请求 如 ajax图片加载 ```js// ajax 图片加载console.log(“start”);let img = document.createElement(‘img’)img.onload = function (){console.log(&#39;loaded&#39;); }img.src = ‘/xxx.png’console.log(“end”);1234567891011121314151617 #### 3.callback hell 和 Promise- callback hell - ```js $.get(url1,(data1)=&gt;&#123; console.log(data1); $.get(url2,(data2)=&gt;&#123; console.log(data2); $.get(url3,(data3)=&gt;&#123; console.log(data3); &#125;) &#125;) &#125;) Promise ```jsfunction getData(url ) {return new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url, success(data)&#123; resolve(data) &#125;, error(err)&#123; reject(err) &#125; &#125;) &#125;)&#125; //使用 const url1 = ‘/data1.json’const url2 = ‘/data2.json’const url3 = ‘/data3.json’getData(url1).then(data1=&gt;{console.log(data1); return getData(url2) }).then(data2=&gt;{console.log(data2); return getData(url3) }).then(data3=&gt;{console.log(data3); }).catch(err =&gt; console.error(err))123456789101112131415161718192021222324252627282930313233343536373839 #### 问题- 同步和异步的区别是什么​ 如上- 手写promise加载一张图片 ```jsconst url = &#x27; &#x27; // new Promise格式分析 function loadImg(src) &#123; const res = new Promise((resolve,reject) =&gt; &#123; const img = document.createElement(&#x27;img&#x27;) // img 加载完成以后执行 resolve 函数 img.onload = () =&gt;&#123; resolve(img) &#125; // img 加载失败执行 reject 函数 img.onerror = ()=&gt;&#123; const err = new Error(`图片加载失败$&#123;src&#125;`) reject(err) &#125; img.src = src &#125;) return res&#125;loadImg(url).then(img=&gt;&#123; console.log(img.width); // return 的 数据给下一个 .then 用 return img&#125;).then(img=&gt;&#123; console.log(img.height);&#125;).catch(ex =&gt;&#123; console.error(ex)&#125;) 加载多张图片 12345678910111213141516// 加上面的代码 const url2 = &#x27;/image/scene.jpg&#x27;loadImg(url1).then(img1=&gt;&#123; console.log(img1.width); return img1 // 返回普通对象 &#125;).then(img1=&gt;&#123; console.log(img1.height); return loadImg(url2) // 返回 promise 实例 &#125;).then(img2=&gt;&#123; console.log(img2.width); return img2 &#125;).then( img2=&gt;&#123; console.log(img2.height); &#125;).catch(err=&gt;&#123; console.error(err) &#125;) 前端使用异步的应用场景 ​ 各种等待的场景 setTimeout 笔试题 console.log(1); setTimeout(() =&gt; &#123; console.log(2); &#125;, 1000); setTimeout(() =&gt; &#123; console.log(3); &#125;, 0); console.log(4); // 1 4 3 2","categories":[],"tags":[{"name":"同步 异步","slug":"同步-异步","permalink":"http://example.com/tags/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/"}]},{"title":"java读取文件的六种方式","slug":"java读取文件的六种方式","date":"2021-12-03T07:58:57.000Z","updated":"2021-12-17T15:12:38.771Z","comments":true,"path":"2021/12/03/java读取文件的六种方式/","link":"","permalink":"http://example.com/2021/12/03/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"我们 java 老师很喜欢让我们自学，说程序在课堂上是学不会的，所以他要多布置作业督促我们。 这次作业是分析他之前项目的一个天体测量文件，所以我顺便记录一下在 java 里读取文件的几种方式","text":"我们 java 老师很喜欢让我们自学，说程序在课堂上是学不会的，所以他要多布置作业督促我们。 这次作业是分析他之前项目的一个天体测量文件，所以我顺便记录一下在 java 里读取文件的几种方式 1.Scanner + new File12345678910111213141516171819202122232425262728293031package readFile_learning;import java.io.FileReader;import java.io.IOException;import java.util.Scanner;//Scanner + new File 既可以按行读取 也可以按分隔符获取public class methods_1 &#123; public static void main(String[] args) throws IOException&#123; // TODO Auto-generated method stub// String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; String fileName = &quot;D:\\\\javaTest\\\\test1.txt&quot;;// 按行读取 try(Scanner sc = new Scanner(new FileReader(fileName)))&#123; while(sc.hasNextLine()) &#123; String line = sc.nextLine(); System.out.println(line); &#125; &#125;// 按分隔符读取 try(Scanner sc = new Scanner(new FileReader(fileName)))&#123; sc.useDelimiter(&quot;\\\\!!!&quot;); while(sc.hasNext()) &#123; String str = sc.next(); System.out.println(str); &#125; &#125; catch (Exception e) &#123; System.out.println(&quot;文件读取错误!&quot;); &#125; &#125;&#125; 2.Stream流123456789101112131415161718192021222324252627282930313233343536package readFile_learning;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class methods_2 &#123;//按行读取 推荐 public static void main(String[] args) throws IOException&#123; // TODO Auto-generated method stub String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;;// 读取文件内容到Stream流中，按行读取,不用一次性把文件加载到内存中 每一行都存在Stream流中 @SuppressWarnings(&quot;resource&quot;) Stream&lt;String&gt; lines = Files.lines(Paths.get(fileName));// 随机按行处理 就去掉Ordered// lines.forEachOrdered(ele -&gt;&#123;;// System.out.println(ele);// &#125;);// 按文件顺序处理// lines.forEachOrdered(System.out::println); 不知道为什么跑出不来 代码是对的// 其它要求// 并行流 利用cpu加快行处理速度 lines.parallel().forEachOrdered(ele -&gt;&#123;; System.out.println(ele); &#125;);// 转换为 List对象 不适合文件大的情况 List&lt;String&gt; collect = lines.collect(Collectors.toList()); &#125;&#125; 3.List String1234567891011121314151617181920package readFile_learning; import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.List;public class methods_3 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub//直接转换为List String 一次性把文件加到lines里 适合文件不是很大 需要对文件按行处理时 String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; List&lt;String&gt; lines = Files.readAllLines(Paths.get(fileName)); lines.forEach(System.out::println); &#125;&#125; Files.readString(Paths.get(fileName)) 12345678910111213141516171819package readFile_learning;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;public class methods_4 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub// java 11 支持的方式 读取文件不超过2G 不是按行读取 一次性读取出来 String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; String s = Files.readString(Paths.get(fileName)); System.out.println(s); &#125;&#125; 5.非JDK11 一次性读取文件的办法1234567891011121314151617181920package readFile_learning;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;public class methods_5 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;;// 不是JDK11 但是要一次性读取全部文件 byte[] bytes = Files.readAllBytes(Paths.get(fileName)); String content = new String(bytes,StandardCharsets.UTF_8); System.out.println(content); &#125;&#125; 6.管道流12345678910111213141516171819202122package readFile_learning;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class methods_6 &#123;//管道流 适合读取文件内存比较大的 public static void main(String[] args) throws FileNotFoundException, IOException &#123; // TODO Auto-generated method stub String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; try(BufferedReader br = new BufferedReader(new FileReader(fileName)))&#123; String line; while((line = br.readLine())!=null) &#123; System.out.println(line); &#125; &#125; &#125;&#125; 之前我们还写 JavaMail 来着，一开始我看到都两眼一蒙不知道是什么，后来自己去搜索自学，发现还是挺简单的。感谢互联网","categories":[],"tags":[{"name":"java读取文件","slug":"java读取文件","permalink":"http://example.com/tags/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/"}]},{"title":"JS面试篇-Part3","slug":"JS面试篇-Part3","date":"2021-11-30T12:32:38.000Z","updated":"2021-12-16T09:26:58.958Z","comments":true,"path":"2021/11/30/JS面试篇-Part3/","link":"","permalink":"http://example.com/2021/11/30/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part3/","excerpt":"1.作用域","text":"1.作用域 全局作用域 函数作用域 块级作用域 ```js// 在 if for while 这些语句的作用域叫块级作用域if(true){let x = 100 }console.log(x) // 报错1234567891011121314151617181920- 代码演示```jsfunction fn1()&#123; let a = 100 fn2() function fn2()&#123; let a1 = 200 function fn3()&#123; let a2 = 300 return a + a1 + a2 &#125; return fn3() &#125; return fn2()&#125;console.log(fn1()) 2.自由变量 在本级作用域使用但是没有定义的变量 一级一级向上找，直到找到为止 如果找不到则报错 xx is not defined 3.闭包 闭包：（所有的）自由变量查找，是在函数定义的地方向上查找，不是在函数执行的地方！！！ 作用域应用的特殊情况有以下两种 函数作为返回值 123456789101112131415// 函数作为返回值function create()&#123; const a = 100 return function ()&#123; console.log(a) &#125;&#125;// 因为返回的是一个函数 如果要执行这个返回的函数 需要拿一个函数接着const createExecu = create()createExecu() // 100const a = 200createExecu() // 100let b = 200createExecu(b) // 100 函数作为参数 123456789function print(fn)&#123; const a = 200 fn()&#125;const a = 100function fn()&#123; console.log(a);&#125;print(fn) // 100 4.thisthis 在函数执行的时候才确定值，不是在函数定义的时候确认的 4.1调用场景 作为普通函数 返回window 使用 call apply bind ```jsfunction fn1(){console.log(this); }fn1() // window// call 和 bind 可以改变函数 this 的指向 但是用法有所不同fn1.call( {x:100} ) // { x: 100 }// bind 返回一个新的函数执行const fn2 = fn1.bind( {x:200} )fn2() // { x: 200 }1234567891011121314151617- 作为对象方法被调用 setTImeout里面用普通函数，this 指向 window - ```js const zhangsan = &#123; name: &quot;张三&quot;, sayHi()&#123; console.log(this); &#125;, wait()&#123; setTimeout(function()&#123; console.log(this); &#125;) &#125; &#125; zhangsan.sayHi() // 当前对象 也就是 zhangsan 这个对象 zhangsan.wait() // setTimeout 里面的普通函数 this 指向 window 箭头函数 setTimeout里是箭头函数 指向上一级this ```jsconst zhangsan = { waitAgain()&#123; setTimeout(()=&gt;&#123; console.log(this); &#125;) &#125; } zhangsan.waitAgain() // 当前对象 也就是 zhangsan 这个对象123456789101112131415- class方法中调用```jsclass People&#123; constructor(name,number)&#123; this.name = name this.number = number &#125; sayHi()&#123; console.log(this) &#125;&#125;const zhangsan = new People(&#x27;张三&#x27;,40)zhangsan.sayHi() // this 指向 zhangsan 5.题目5.1.this的不同应用场景4.1就是答案 情况很多，需要重复记忆 5.2.手写bind函数bind 传入一个this 返回一个函数 注释分析版 123456789101112131415161718192021222324252627282930313233function fn1(a,b,c)&#123; console.log(&quot;this&quot;,this); // 单纯的this 就是window console.log( a,b,c) return &quot;this is fn1&quot;&#125; // const fn2 = fn1.bind(&#123;x:100&#125;,1,2,3) //bind改变函数this的指向// fn2() //this &#123; x: 100 &#125;// 原型链分析// let flag = fn1.hasOwnProperty(&quot;bind&quot;)// console.log(flag) // false// flag = fn1.__proto__===Function.prototype?true:false // true// console.log(flag); Function.prototype.bind1 = function() &#123; // 先把传进来的参数列表变成数组 arguments 可以获得所用的参数 const args = Array.prototype.slice.call(arguments) // 用shift 获取 args 的第一项也就是传进来的this（shift会改变原数组） const t = args.shift() // 原本的this 也就是 fn1 拿出来 const self = this // 返回一个函数（实现bind的功能） return function () &#123; // apply 第一个参数是 this 第二个参数是 参数数组 return self.apply(t,args) &#125; &#125;const fn3 = fn1.bind1(&#123;x:100&#125;,1,2,3) //bind1改变函数this的指向fn3() //this &#123; x: 100 &#125; 答案版 12345678Function.prototype.bind1 = function() &#123; const args = Array.prototype.slice.call(arguments) const t = args.shift() const self = this return function () &#123; return self.apply(t,args) &#125; &#125; 还有手写 call apply 等 5.3.实际开发中闭包的应用场景，举例说明 隐藏数据 不让外部改变 做一个简单的 cache 工具 1234567891011121314151617function createCache() &#123; let data = &#123;&#125; return &#123; // set: function(key,value)&#123;&#125; 格式也是对的 set(key,value)&#123; data[key] = value &#125;, get(key)&#123; return data[key] &#125; &#125; &#125;const fn1 = createCache()fn1.set(&quot;age&quot;,18)console.log(fn1.get(&quot;age&quot;)); 5.4 创建10个 a 标签点击的时候弹出相应的序号12345678910111213// 创建10个 a 标签，点击弹出相应索引 // 考点在于 如果 i 在 外部声明而不是for循环里面声明 那么最后i的值就一直是 10 // 因为遍历创建 a 标签的速度很快 i又是全局变量 所以一下就加完了，但是事件不是同步任务，需要点击才能触发，所以当我们点击 a 标签的时候，i 已经变成 10 了 只有把 i 放到块级作用域里，才能和alert事件同步。因为每遍历一次，i会开辟一个新的作用域，在alert的时候，就在对应作用域里找 i 是多少 let a for(let i = 0;i&lt;10;i++)&#123; a = document.createElement(&#x27;a&#x27;) a.innerHTML = i + &#x27;&lt;br&gt;&#x27; a.addEventListener(&#x27;click&#x27;,function(e)&#123; e.preventDefault() alert(i) &#125;) document.body.appendChild(a) &#125;","categories":[],"tags":[{"name":"作用域 闭包 this 手写bind","slug":"作用域-闭包-this-手写bind","permalink":"http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-this-%E6%89%8B%E5%86%99bind/"}]},{"title":"JS面试篇-Part2","slug":"JS面试篇-Part2","date":"2021-11-29T12:40:28.000Z","updated":"2021-12-16T09:26:09.026Z","comments":true,"path":"2021/11/29/JS面试篇-Part2/","link":"","permalink":"http://example.com/2021/11/29/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part2/","excerpt":"JS 本身是基于原型链的语言","text":"JS 本身是基于原型链的语言 1.class constructor 属性 方法 1234567891011121314151617181920212223242526class Student &#123; // constructor constructor(name, number)&#123; // this 当前的类 this.name = name this.number = number // 属性也可以自定义，不需要传 this.school = &#x27;阳光小学&#x27; &#125; // 定义方法 sayHi()&#123; console.log( `姓名： $&#123;this.name&#125; 学号: $&#123;this.number&#125; 学校: $&#123;this.school&#125; ` ); &#125;&#125;// 通过类 new 对象/实例 也就是说用 new 关键字把这个模板赋给我们需要的变量let stu1 = new Student(&#x27;moon&#x27;,&#x27;1234&#x27;)let stu2 = new Student(&#x27;sun&#x27;, &#x27;67890&#x27;)console.log(stu1.number);console.log(stu2.name);stu1.sayHi(); 2.继承 某些类有相同的属性和方法时，可以抽象出来归为一个父类共同继承 extends super 扩展或重写方法 123456789101112131415161718192021222324252627282930313233343536373839404142// 父类class People&#123; constructor(name,favorite)&#123; this.name = name this.favorite = favorite &#125; eat()&#123; console.log(`$&#123;this.name&#125; likes to eat $&#123;this.favorite&#125;`); &#125;&#125;// 子类1// extends 关键字 表示继承于class Student extends People&#123; constructor(name,favorite,number)&#123; // super 关键字 把这些属性给父类处理 super(name, favorite) this.number = number this.school = &quot;School_A&quot; &#125; sayHi()&#123; console.log( `姓名 $&#123;this.name&#125; 学号 $&#123;this.number&#125;`) &#125;&#125;// 子类2class Teacher extends People&#123; constructor(name,favorite,major)&#123; super(name,favorite) this.major = major &#125; teach()&#123; console.log( ` $&#123;this.name&#125; 教授 $&#123;this.major&#125;`) &#125;&#125;// 实例let stu = new Student(&#x27;sam&#x27;,&#x27;banana&#x27;,&#x27;123456&#x27;)let teacher = new Teacher(&#x27;Miss Wang&#x27;,&#x27;grape&#x27;,&#x27;JavaScript&#x27;) stu.sayHi()stu.eat()teacher.teach()teacher.eat() 3.类型判断 instanceof1234567891011function log(x)&#123; console.log(x)&#125;// 判断这个变量是不是这个类构建出来的 log(stu instanceof People ) //true log(stu instanceof Student) //true log(stu instanceof Object) //true log(stu instanceof Teacher) //false log([] instanceof Array) //true log([] instanceof Object) //true log(&#123;&#125; instanceof Object) //true 4.原型以及原型链12345log(stu.__proto__) //People &#123;&#125;log(Student.prototype) //People &#123;&#125;log(stu.__proto__ === Student.prototype) // truelog (stu.__proto__.sayHi()) // undefinedlog (stu.__proto__.name) //undefined 因为相当于 stu.__proto__ 作为this了，这个this上没有name没有number 4.1原型关系 每个class都有显式原型（prototype） 每个实例都有隐式原型 （proto) 实例的proto指向class的prototype 图解 自己本身声明的，叫prototype 自己从别人那继承来的属性和方法，叫__proto__ 自己所可以使用的全部方法和属性就是自己的 .prototype 属性 4.2 原型执行规则 获取实例的属性或者执行方法时，现在自身属性和方法中查找 找不到就去隐式原型中找 4.3 原型链12345log(Student.prototype.__proto__) //&#123;&#125;log(People.prototype) //&#123;&#125;log(Student.prototype.__proto__ === People.prototype) //true 图解 5.问题5.1 如何准确判断一个变量是不是数组？a instanceof Array 5.2 class的原型本质，如何理解？ 原型链的图 原型的执行规则 5.3 手写简易jquery，考虑插件和扩展性1234567891011121314151617181920212223242526class jQuery&#123; constructor(selector)&#123; const result = document.querySelectorAll(selector) const length = result.length for(let i = 0;i&lt;length;i++)&#123; this[i] = result[i] &#125; this.length = length this.selector = selector &#125; get(index)&#123; return this[index] &#125; // 方法遍历元素 each(fn)&#123; for(let i = 0;i&lt;this.length;i++)&#123; const elem = this[i] fn(elem) &#125; &#125; on(type,fn)&#123; return this.each(elem=&gt;&#123; elem.addEventListener(type,fn,false) &#125;) &#125;&#125;","categories":[],"tags":[{"name":"原型 原型链 class继承 instanceof","slug":"原型-原型链-class继承-instanceof","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-class%E7%BB%A7%E6%89%BF-instanceof/"}]},{"title":"JS面试篇-Part1","slug":"JS面试篇-Part1","date":"2021-11-28T08:35:03.000Z","updated":"2021-12-17T12:40:06.739Z","comments":true,"path":"2021/11/28/JS面试篇-Part1/","link":"","permalink":"http://example.com/2021/11/28/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part1/","excerpt":"1.值类型和引用类型以及区别","text":"1.值类型和引用类型以及区别 1.1 定义 值类型，value直接存储在栈中，值的地址互不干扰 12345let a = 100;let b = a;a = 200;console.log(a); //200console.log(b); //100 引用类型，元素指向地址，值存放在元素指向的地址中 1234let a = &#123; age: 20 &#125;;let b = a;b.age = 21;console.log(a.age); //21 a 和 b 指向的地址都是一样的，所以改了 b 后 a 也会改 引用类型比值类型占用的内存要大得多，如果直接复制值，资源浪费大，并且复制时间长。 1.2 常见值类型123456let a //undefinedconst a // 会报错,const 必须赋值const s = &#x27;abc&#x27;const n = 100const b = trueconst sym = Symbol(&#x27;s&#x27;) 1.3常见引用类型1234const obj = &#123; x: 100 &#125;const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const n = null //特殊引用类型，指针指向空地址function fn() &#123;&#125; //特殊引用类型，不用于存储数据，所以不存在“深拷贝”，“浅拷贝”，也可以看做第三个类型 1.4 值类型和引用类型例题123456789const obj1 =&#123; x:100, y:200&#125; const obj2 = obj1let x1 = obj1.xx1 = 102 // 干扰项，x1 是值类型，直接赋值，它的改变不会影响其它的量obj2.x = 101console.log(obj1.x); // 101 1.5 typeof 可以判断的类型 识别所有值类型 识别函数 判断是否为引用类型（不再细分） 12345678let a //typeof(a) undefined const s = &#x27;abc&#x27; //typeof(s) stringconst n = 100 //typeof(n) numberconst b = true //typeof(b) booleanconst sym = Symbol(&#x27;s&#x27;) //typeof(sym) symboltypeof(console.log) //function// 其余引用类型 typeof 只能判断为 object 2.变量计算-类型转换2.1 字符串拼接12345const a = 100 + 10 //110const b = 100 + &#x27;10&#x27; //&#x27;10010&#x27;const c = true + &#x27;10&#x27; //true10// 强制类型转换const d = 100 + parseInt(&#x27;100&#x27;); //200 2.2 何时使用 == 何时使用 === == 尽量转换 让二者相等 123456// 用 == 基本都是true，=== 才会返回false100 == &#x27;100&#x27; //true0 == &#x27;&#x27; //true0 == false //truefalse == &#x27;&#x27; //truenull == undefined //true 除了 == null 以外，其他一律都用 === 2.3 if语句和逻辑运算 truly 和 falsely 变量 123456789101112// truly 变量!!a === true// falsely 变量!!b === false// 以下是 falsely 变量，其余都是 truly 变量!!0 === false!!NaN === false!!&#x27;&#x27; === false!!null === false!!undefined === false!!false === false 在 if 语句中的应用（if判断 !! 之后是 truly 变量还是 falsely 变量） 123456789// truly 变量 const a = true if (a)&#123; ... &#125; const b = 100 if(b)&#123; ... &#125; 1234567891011121314151617// falsely 变量 const c = &#x27;&#x27; if(c)&#123; ... &#125; const d = null if(d)&#123; ... &#125; let e if(e)&#123; ... &#125; else&#123; //会走到这一步 &#125; 逻辑判断 123console.log(10 &amp;&amp; 0) // 0console.log(&#x27;&#x27; || &#x27;abc&#x27;) // &#x27;abc&#x27;console.log(window.abc) //true 2.4 手写深拷贝 注意判断值类型和引用类型 注意判断数组和对象 递归 123456789101112131415161718192021222324252627// 深拷贝部分 function deepClone(obj)&#123; let res = obj instanceof Array?[]:&#123;&#125;; if(typeof(obj)!==&#x27;object&#x27; || typeof(obj) == null)&#123; return obj; &#125; for(let key in obj)&#123; // 确保key不是原型链上的 if(obj.hasOwnProperty(key))&#123; // 递归（重点） key要一层一层遍历，比如说 obj&#123; address:&#123;city: &#x27;Beijing&#x27;&#125;&#125; res[key] = deepClone(obj[key]) &#125; &#125; return res;&#125;// test 部分let obj1 = &#123; address:&#123; city:&quot;Beijing&quot; &#125;&#125;let obj2 = deepClone(obj1);obj2.address.city = &quot;Shanghai&quot;;console.log(obj1.address.city);console.log(obj2.address.city); Q：深拷贝的堆栈模型图？","categories":[],"tags":[{"name":"值类型 引用类型 深拷贝 ==和=== truly和falsely变量","slug":"值类型-引用类型-深拷贝-和-truly和falsely变量","permalink":"http://example.com/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E5%92%8C-truly%E5%92%8Cfalsely%E5%8F%98%E9%87%8F/"}]},{"title":"前端面试CSS 响应式","slug":"前端面试CSS-响应式","date":"2021-10-22T11:33:37.000Z","updated":"2021-12-16T09:23:28.383Z","comments":true,"path":"2021/10/22/前端面试CSS-响应式/","link":"","permalink":"http://example.com/2021/10/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"1.rem是什么","text":"1.rem是什么 1.1 常见单位 px 绝对长度单位，最常用 em，相对长度单位，但是相对于父元素，所以不常用 rem，相对长度单位，相对于根元素，常用 1.2 代码展示123456789101112131415161718192021222324252627&lt;style&gt; html&#123; //作为基准的尺寸 font-size: 100px; &#125; div&#123; background-color: #ccc; height: 0.3rem; font-size: 0.1rem; margin-top: 0.1rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;width: 0.4rem;&quot;&gt; div1 &lt;/div&gt; &lt;div style=&quot;width: 0.5rem;&quot;&gt; div2 &lt;/div&gt; &lt;div style=&quot;width: 0.6rem;&quot;&gt; div3 &lt;/div&gt; &lt;/body&gt; 2.如何实现响应式 media-query 根据不同的屏幕宽度设置根元素的font-size rem，基于根元素的相关单位 2.1代码示例123456789101112131415161718@media screen and (max-width: 414px) &#123; html &#123; font-size: 18px &#125;&#125;@media screen and (max-width: 375px) &#123; html &#123; font-size: 16px &#125;&#125;@media screen and (max-width: 320px) &#123; html &#123; font-size: 12px &#125;&#125; 3.vw/vh3.1 rem的弊端rem具有“阶梯型”，标准卡得很死，范围不够动态。 3.2 网页视口尺寸（以height为例） window.screen.height 整个屏幕高度 window.innerHeight 网页视口高度，浏览器可以显示内容部分的高度 document.body.clientHeight 动态的，看内容有多高 3.3 vh和vm vh 网页视口高度的1/100 vm 网页视口宽度的 1/100 vmax 取两者的最大值；vmin取两者的最小值（一般来说，vh比较大，但是屏幕横过来，vm会比较大）","categories":[],"tags":[{"name":"rem vw vh响应式","slug":"rem-vw-vh响应式","permalink":"http://example.com/tags/rem-vw-vh%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"前端面试CSS 图文样式","slug":"前端面试CSS-图文样式","date":"2021-10-21T11:33:00.000Z","updated":"2021-12-16T09:23:17.387Z","comments":true,"path":"2021/10/21/前端面试CSS-图文样式/","link":"","permalink":"http://example.com/2021/10/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%9B%BE%E6%96%87%E6%A0%B7%E5%BC%8F/","excerpt":"1.line-height的继承问题","text":"1.line-height的继承问题 12345678910body&#123; font-size: 20px; line-height: 200%;&#125;p&#123; font-size:16px;&#125;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt;&lt;/body&gt; Q: p 标签的行高是多少？ A：40px 分析： 具体数值，则直接继承 写比例，直接继承 本身*比例 写百分比，先算完再继承（考点）","categories":[],"tags":[{"name":"line-height的继承问题","slug":"line-height的继承问题","permalink":"http://example.com/tags/line-height%E7%9A%84%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/"}]},{"title":"前端面试CSS 定位","slug":"前端面试CSS-定位","date":"2021-10-21T11:31:37.000Z","updated":"2021-12-16T09:23:10.477Z","comments":true,"path":"2021/10/21/前端面试CSS-定位/","link":"","permalink":"http://example.com/2021/10/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%AE%9A%E4%BD%8D/","excerpt":"1.absolute和relative分别依据什么定位","text":"1.absolute和relative分别依据什么定位 子绝父相 relative 根据自身定位 对外界元素不会有任何影响 absolute 根据最近一层父元素定位 2.居中对齐有什么方式 水平居中 inline元素 text-align：center 给父元素给自身都可以 它没有宽高 只是看文字 block元素 margin：auto 给自身 absolute元素 left：50% + margin-left 负值 （子元素的宽度的一半）给自身 注意父元素要relative 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;title&gt;水平居中&lt;/title&gt; &lt;style&gt; .container&#123; background-color: #9dd3a8; margin: 10px; padding: 10px; width: 500px; height: 50px; &#125; .item&#123; background-color: #fdc4b6; text-align: center; &#125; .container-1&#123; text-align: center; &#125; .container-2 .item&#123; width: 100px; margin: auto; &#125; .container-3&#123; position: relative; &#125; .container-3 .item&#123; position: absolute; width: 300px; left: 50%; margin-left: -150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container container-1&quot;&gt; &lt;span class=&quot;item&quot;&gt; inline元素 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container container-2 &quot;&gt; &lt;div class=&quot;item&quot;&gt; block元素 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container container-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; absolute元素 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 垂直居中（和水平居中情况类似） inline元素：line-height 等于height absolute元素： top：50% + margin-top负值 （知道子元素的高度） left: 50% + top: 50% + transform: translate(-50%，-50%) top left right bottom = 0 + margin：auto","categories":[],"tags":[{"name":"absolute relative 居中对齐","slug":"absolute-relative-居中对齐","permalink":"http://example.com/tags/absolute-relative-%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/"}]},{"title":"前端面试CSS 布局","slug":"前端面试CSS-布局","date":"2021-10-20T06:51:13.000Z","updated":"2021-12-16T09:22:32.733Z","comments":true,"path":"2021/10/20/前端面试CSS-布局/","link":"","permalink":"http://example.com/2021/10/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%B8%83%E5%B1%80/","excerpt":"1.盒子模型的宽度如何计算","text":"1.盒子模型的宽度如何计算 Q:div1 的offsetWidth 为多大？offsetWidth=（内容宽度 + 内边距 + 边框），无外边距（也就是没有margin） 12345678910111213&lt;style&gt; #div1&#123; width: 100px; padding: 10px; border: 1px solid #ccc; margin: 10px; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;/body&gt; A1：122px Q2：如果要让offsetWidth等于100 该怎么做？ A2： 加 box-sizing: border-box; 也就是说让width不再是单纯的内容宽度，而是border-box的宽度（包括到边框的宽度，也就是offsetWidth），这样内容宽度会缩小，但是padding和border和margin不会 2.margin纵向重叠的问题Q：AAA和BBB之间的距离是多少？ 12345678910111213141516&lt;style&gt; /* margin纵向重叠 */ p &#123; font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;BBB&lt;/p&gt;&lt;/body&gt; A：15px 相邻元素的margin-top 和 margin-bottom 会发生重叠，空白内容的 p 标签页会被重叠（我的理解是没有高度也没有内容的情况下，设置margin也没用，忽略即可）。 3.margin负值的问题Q：margin的bottom top left right设置成负值分别的作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;style&gt; body&#123; margin: 20px; &#125; .float-left&#123; float: left; &#125; .clearfix::after&#123; content: &#x27;&#x27;; display: table; clear: both; &#125; .container&#123; border: 1px solid #ccc; padding: 10px; &#125; .container .item&#123; width: 100px; height: 100px; &#125; .container .border-blue&#123; border: 1px solid blue; &#125; .container .border-red&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;marigin top bottom 为负值的情况&lt;/p&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 设置top 负值 item1自己往上移动 设置bottom负值 item2往上移动--&gt; &lt;div class=&quot;item border-blue&quot; style=&quot;margin-top: -20px;&quot;&gt; this is item1 &lt;/div&gt; &lt;div class=&quot;item border-red&quot;&gt; this is item2 &lt;/div&gt; &lt;/div&gt; &lt;p&gt;marigin left right 为负值的情况&lt;/p&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;!-- 设置left 负值 item1自己往左移动 设置right负值 item2往左移动--&gt; &lt;div class=&quot;item border-blue float-left&quot; style=&quot;margin-left: -20px;&quot;&gt; this is item3 &lt;/div&gt; &lt;div class=&quot;item border-red float-left&quot;&gt; this is item4 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; A： margin-top 和 margin-left 负值，元素向上、向左移动； margin-right负值，右侧元素左移，自身不受影响； margin-bottom负值，下方元素上移，自身元素不受影响 总的来说，都是让元素向左移/右移，只不过一个让自己移动，一个让别人移动 4.BFC理解和应用一般来说直接问，因为没有很适合的场景 Q: 什么是BFC以及如何应用 A： Block format context：块级格式化上下文；一块独立渲染区域，内部元素的渲染不会影响边界以外的元素 形成BFC的常见条件 float 不是 none position 是 absolute 或 fixed overflow 不是 visible display 是 flex inline-block等 前三者比较常用 BFC的常见应用 清除浮动（可以用clearfix也可以用BFC） 123456789101112131415&lt;style&gt; .container&#123; background-color: #ccc; &#125; .left&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;img/test2.jpg&quot; class=&quot;left&quot;&gt; &lt;p&gt;test.....&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 因为图片设置了浮动，所以会脱离文本流，飘在上面，但是没有bfc时，不会撑开自己本身的div，从而影响到其它块外的元素 用 overflow: hidden; 触发块级元素的bfc，也就是container的bfc，使得它里面的元素独立渲染 123456//style增加加.bfc&#123; overflow: hidden; &#125;//container增加&lt;div class=&quot;container bfc&quot;&gt;&lt;/div&gt; 5.float布局的问题以及 clearfixQ1:float布局：圣杯布局A1: 目的： 三栏布局，中间一栏最先加载和渲染（内容最重要） 两侧内容固定，中间内容随着宽度自适应 一般用于PC网页 技术总结（按照这三点来写代码，回答问题） 使用float布局 两侧使用margin负值，以便和中间内容横向重叠 防止中间内容被两侧覆盖，padding+margin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;style&gt; body&#123; min-width: 550px; &#125; .header&#123; text-align: center; background-color: #f1f1f1; &#125; .container&#123; /* padding 给左右两个盒子留出宽度 */ padding-left: 200px ; padding-right: 150px &#125; .center&#123; background-color: #ccc; width: 100%; &#125; .left&#123; /* left position设置relative margin-left设置本身宽度的负值 */ position: relative; background-color: yellow; width: 200px; margin-left: -200px; &#125; .right&#123; /* margin-right设置本身宽度的负值 */ background-color: pink; width: 150px; margin-right: -150px; &#125; .footer&#123; /* 给container里的元素设置了浮动会导致footer浮上来 所以需要设置clear：both清除浮动 */ clear: both; text-align: center; background-color: #f1f1f1; &#125; .column&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;center column&quot;&gt;center&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; Q2:双飞翼布局A2：用margin留白 用margin-left移动 比较简单1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; body&#123; min-width: 550px; &#125; #main&#123; width: 100%; height: 200px; background-color: pink; &#125; #main-wrap&#123; margin: 0 190px 0 190px; &#125; #left&#123; width: 190px; height: 200px; background-color: yellow; margin-left: -100%; &#125; #right&#123; width: 190px; height: 200px; background-color: orange; margin-left: -190px ; &#125; .column&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;main&quot; class=&quot;column&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt; main &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt; left &lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt; right &lt;/div&gt;&lt;/body&gt; Q3:手写clearfixA3：123456/* 比如说圣杯布局 不给foot单独加去浮动的话，可以给container加这个清除浮动 不影响后面的元素 */ .clearfix::after&#123; content: &#x27;&#x27;; display: table; clear: both; &#125; 6.flex布局 常用语法 flex-direction justify-content align-items flex-wrap align-self Q：实现一个三点的色子A： 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .box&#123; width: 200px; height: 200px; border: 2px solid #ccc; border-radius: 10px; padding: 20px; /* 关键 */ display: flex; justify-content: space-between; //两端对齐 &#125; .item&#123; display: block; width: 40px; height: 40px; border-radius: 50%; background-color: pink; &#125; /* 关键 */ .item:nth-child(2)&#123; align-self: center; //第二项居中对齐 &#125; .item:nth-child(3)&#123; align-self: flex-end; //第三项尾对齐 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"盒模型 margin BFC 圣杯/双飞翼布局 flex布局","slug":"盒模型-margin-BFC-圣杯-双飞翼布局-flex布局","permalink":"http://example.com/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B-margin-BFC-%E5%9C%A3%E6%9D%AF-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80-flex%E5%B8%83%E5%B1%80/"}]},{"title":"前端面试HTML篇","slug":"前端面试HTML篇","date":"2021-10-19T11:24:06.000Z","updated":"2021-12-16T09:23:44.539Z","comments":true,"path":"2021/10/19/前端面试HTML篇/","link":"","permalink":"http://example.com/2021/10/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95HTML%E7%AF%87/","excerpt":"1.如何理解语义化1）给人看：具有可读性，易懂 2）给搜索引擎看：让搜索引擎读得懂（机器可以识别标签），SEO优化","text":"1.如何理解语义化1）给人看：具有可读性，易懂 2）给搜索引擎看：让搜索引擎读得懂（机器可以识别标签），SEO优化 12345678&lt;div&gt;标题&lt;/div&gt;&lt;div&gt; &lt;div&gt;文字内容&lt;/div&gt; &lt;div&gt; &lt;div&gt;列表1&lt;/div&gt; &lt;div&gt;列表2&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678&lt;h1&gt;标题&lt;/h1&gt;&lt;div&gt; &lt;p&gt;文字&lt;/p&gt; &lt;ul&gt; &lt;li&gt;列表1&lt;/li&gt; &lt;li&gt;列表2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.HTML标签：块级元素和内联元素1）块级元素： 12display：block/tablediv h1 h2 table ul ol p 2）内联元素 12display：inline/inline-blockbutton img span input","categories":[],"tags":[{"name":"语义化 块级元素 内联元素","slug":"语义化-块级元素-内联元素","permalink":"http://example.com/tags/%E8%AF%AD%E4%B9%89%E5%8C%96-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0/"}]},{"title":"Flex布局总结","slug":"Flex布局总结","date":"2021-10-19T02:21:14.000Z","updated":"2021-11-25T08:57:29.894Z","comments":true,"path":"2021/10/19/Flex布局总结/","link":"","permalink":"http://example.com/2021/10/19/Flex%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93/","excerpt":"1.布局原理","text":"1.布局原理 flexible Box 意思是弹性布局 通过给父元素添加flex属性，从而控制子盒子的位置和排列方式。任何元素（块级和行内块元素）都可以采用flex布局。采用flex布局以后，float，clear和vertical-align都会失效 1.1container和item 采用Flex布局的元素叫做container（容器），它的所有子元素自动称为容器成员，称为flex item （项目） item可以纵向排列也可以横行排列 2.父元素常见属性 属性 作用 flex-direction 设置主轴方向 justify-content 设置主轴上子元素排列方式 flex-wrap 设置子元素是否换行 align-content 设置侧轴子元素的排列方式（多行） align-items 设置侧轴子元素的排列方式（单行） flex-flow 复合属性，相当于 flex-direction + flex-wrap 2.1 flex-direction 元素是跟着主轴排列的，设置 x 为主轴，那么 y 就是侧轴，反之亦然； 属性 属性值 作用 row 默认主轴为x轴，从左到右 row-reverse 从右到左，元素顺序也会跟着翻转 column 设置主轴为y轴，从上到下 column-reverse 从下到上，元素顺序也会跟着翻转 2.2 justify-content 设置主轴上子元素的排列方式，使用之前要确定好主轴方向 属性 属性 作用 flex-start 默认值，从左到右/从上到下排列 flex-end 从尾部开始排列 center 在主轴居中对齐 space-around 平分剩余空间（eg：主轴是x轴，子元素margin-left和margin-right相同） space-between 两边贴边，中间元素平分空间（重要） 2.3 flex-wrap 设置子元素是否换行 当子元素在父元素中空间不够时，flex布局默认不换行，等比例缩小子元素宽度之后排成一行 no-wrap 不换行 / wrap 不够另起一行 2.4 align-items 设置侧轴元素排列方式（单行） 设置侧轴元素排列方式 和主轴搭配使用可以实现居正中效果 属性 （默认侧轴是 y 轴） 属性 作用 flex-start 从上到下 flex-end 从下到上 center 垂直居中 stretch 拉伸（默认值） 2.5 align-content 设置侧轴元素排列方式（多行） 多行：子元素出现要换行的情况 （flex-wrap: wrap;） 属性 属性 作用 flex-start 默认从侧轴头部开始排列 flex-end 从侧轴尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 两边贴边，中间元素平分空间 stretch 设置子项元素平分父元素高度 2.6 flex-flow eg：flex-wrap: column wrap 3.子元素常用属性 flex items占的份数 align-self 控制子项自己在侧轴排列的方式 order 属性定义子项的排列顺序（前后顺序） 3.1 flex 属性 分配剩余空间 flex: number 默认是 0 3.2 align-self 允许单个item与其它 item 有不一样的对齐方式，覆盖align-items属性 3.3 order 定义item的排列顺序 数值越小顺序越前","categories":[],"tags":[{"name":"flex","slug":"flex","permalink":"http://example.com/tags/flex/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2021-10-18T06:51:13.000Z","updated":"2021-12-16T09:31:43.935Z","comments":true,"path":"2021/10/18/KMP算法/","link":"","permalink":"http://example.com/2021/10/18/KMP%E7%AE%97%E6%B3%95/","excerpt":"1.概述：KMP算法主要用在字符串匹配上，需要一个前缀表和一个next数组","text":"1.概述：KMP算法主要用在字符串匹配上，需要一个前缀表和一个next数组 2.过程：以模板字符串 aabaaf 和目标字符串 aabaabaafa 为例： 1）如果暴力匹配，那么在 f 匹配不上时，就需要从头开始匹配，效率很低 2）如果是KMP算法，模板字符串匹配到 f 时， 不从头开始，而是从 b 开始匹配。思想非常简单，我们可以发现，对于 aabaabaafa 在第二个 b 我们匹配不上了，但是这个b前面的aa和模板字符串的开头aa是一样的，所以从aa后面一个值开始匹配是效率最高的。 动图如下： 3.前缀表现在有一个问题是，在字符不匹配时，我们怎么知道下一步该从哪里开始呢？这里就需要用到前缀表了。 1）先说一下什么是前缀和后缀：前缀：不包括最后一个字符，包括第一个字符的所有连续子字符串。 eg：aabaaf的所有前缀：a, aa, aab, aaba, aabaa 不包括aabaaf 后缀：与前缀刚好相反 eg：aabaaf的所有后缀：f, af, aaf, baaf, abaaf 不包括aabaaf 2）前缀表：记录当前索引 i 之前（包括 i ）的字符串中，有多大长度的相同前后缀。aabaaf的前缀表 0 1 2 3 4 a aa aab aaba aabaa 0 1 0 1 2 单纯得到这个表还是很简单的，要么把字符串的前后缀都写出来，看交集最长为多少，要么就直接看字符串前后重合的字符有多少个。关键是要理解这个表的意思。 3)前缀表的含义前面已经说过，碰到不匹配的字符串时，我们不能浪费掉之前已经匹配过的字符串，我们跳过索引 i 之前已经匹配好了的字符串，从这个字符串的后面一个开始匹配。 目标字符串从索引5的 b 开始不匹配，也就是说b以前的都是匹配的，而我们又知道在模板字符串里，同样索引位置的前两个字符在开头有重复，所以，我们就可以跳到第三个（索引2）开始下一次匹配。这也是KMP算法对暴力算法的优化所在于，它不再从头开始。 4.得到next数组123456789101112131415const getNext = (s)=&gt;&#123; let next = []; let j = 0; next.push(j); for(let i = 1;i&lt;s.length;++i)&#123; //注意这里是while 不是 if 因为j是连续回跳，直到到了索引0或者跳到了指定位置 while(j&gt;0&amp;&amp;s[i]!==s[j])&#123; j = next[j-1] &#125; if(s[i]===s[j]) j++; next.push(j); &#125; return next; &#125; 5.例题leetcode459 重复的字符子串 https://leetcode-cn.com/problems/repeated-substring-pattern/给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 1234567示例：输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。输入: &quot;aba&quot;输出: False 1234567891011121314151617181920212223// KMPvar repeatedSubstringPattern = function(s) &#123; if(s.length === 0) return false; const getNext = (s)=&gt;&#123; let next = []; let j = 0; next.push(j); for(let i = 1;i&lt;s.length;++i)&#123; while(j&gt;0&amp;&amp;s[i]!==s[j])&#123; j = next[j-1] &#125; if(s[i]===s[j]) j++; next.push(j); &#125; return next; &#125; let next = getNext(s); if(next[next.length-1]!==0 &amp;&amp; s.length%(s.length - next[next.length - 1])===0) return true; return false;&#125;; leetcode28 实现 strStr() 函数 https://leetcode-cn.com/problems/implement-strstr给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 12345678910111213141516171819202122232425262728var strStr = function(haystack, needle) &#123; if(needle.length === 0) return 0; const getNext = (needle)=&gt;&#123; let next = []; let j = 0; next.push(j); for(let i = 1;i&lt;needle.length;++i)&#123; while(j&gt;0&amp;&amp;needle[i]!==needle[j])&#123; j = next[j-1] &#125; if(needle[i]===needle[j]) j++; next.push(j); &#125; return next; &#125; let next = getNext(needle); let j = 0; for(let i = 0;i&lt;haystack.length;++i)&#123; while(j&gt;0&amp;&amp;haystack[i]!==needle[j]) j = next[j-1]; if(haystack[i]===needle[j]) j++; if(j === needle.length) return (i-needle.length+1) &#125; return -1;&#125;;","categories":[],"tags":[{"name":"KMP算法","slug":"KMP算法","permalink":"http://example.com/tags/KMP%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"babel babel-polyfill babel-runtime","slug":"babel-babel-polyfill-babel-runtime","permalink":"http://example.com/tags/babel-babel-polyfill-babel-runtime/"},{"name":"webpack 性能优化","slug":"webpack-性能优化","permalink":"http://example.com/tags/webpack-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"webpack 前端打包","slug":"webpack-前端打包","permalink":"http://example.com/tags/webpack-%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85/"},{"name":"Redux-Toolkit","slug":"Redux-Toolkit","permalink":"http://example.com/tags/Redux-Toolkit/"},{"name":"RESTful","slug":"RESTful","permalink":"http://example.com/tags/RESTful/"},{"name":"tsconfig.json编译器配置文档","slug":"tsconfig-json编译器配置文档","permalink":"http://example.com/tags/tsconfig-json%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"},{"name":"React-Hooks","slug":"React-Hooks","permalink":"http://example.com/tags/React-Hooks/"},{"name":"函数式编程 JSX本质 合成事件 组件渲染 setState","slug":"函数式编程-JSX本质-合成事件-组件渲染-setState","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-JSX%E6%9C%AC%E8%B4%A8-%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6-%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93-setState/"},{"name":"redux react-redux","slug":"redux-react-redux","permalink":"http://example.com/tags/redux-react-redux/"},{"name":"React 高级特性","slug":"React-高级特性","permalink":"http://example.com/tags/React-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"},{"name":"React 基本使用","slug":"React-基本使用","permalink":"http://example.com/tags/React-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"name":"Vue3 生命周期  ref toRef toRefs","slug":"Vue3-生命周期-ref-toRef-toRefs","permalink":"http://example.com/tags/Vue3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-ref-toRef-toRefs/"},{"name":"渲染更新过程 前端路由","slug":"渲染更新过程-前端路由","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"},{"name":"模板编译","slug":"模板编译","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"},{"name":"组件化 响应式 vdom diff 模板编译 渲染过程 前端路由","slug":"组件化-响应式-vdom-diff-模板编译-渲染过程-前端路由","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%93%8D%E5%BA%94%E5%BC%8F-vdom-diff-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"},{"name":"vue2 高级特性","slug":"vue2-高级特性","permalink":"http://example.com/tags/vue2-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"},{"name":"Vue组件 生命周期","slug":"Vue组件-生命周期","permalink":"http://example.com/tags/Vue%E7%BB%84%E4%BB%B6-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"Vue2 基础知识","slug":"Vue2-基础知识","permalink":"http://example.com/tags/Vue2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"深拷贝 简单深比较","slug":"深拷贝-简单深比较","permalink":"http://example.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E7%AE%80%E5%8D%95%E6%B7%B1%E6%AF%94%E8%BE%83/"},{"name":"前端面试","slug":"前端面试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"},{"name":"手写防抖 手写节流","slug":"手写防抖-手写节流","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96-%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81/"},{"name":"网页加载","slug":"网页加载","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD/"},{"name":"Linux命令","slug":"Linux命令","permalink":"http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"手写Promise","slug":"手写Promise","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99Promise/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"},{"name":"ajax 跨域 同源策略","slug":"ajax-跨域-同源策略","permalink":"http://example.com/tags/ajax-%E8%B7%A8%E5%9F%9F-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"JS Web API","slug":"JS-Web-API","permalink":"http://example.com/tags/JS-Web-API/"},{"name":"微任务 宏任务 eventloop和dom渲染 手写promise","slug":"微任务-宏任务-eventloop和dom渲染-手写promise","permalink":"http://example.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E5%AE%8F%E4%BB%BB%E5%8A%A1-eventloop%E5%92%8Cdom%E6%B8%B2%E6%9F%93-%E6%89%8B%E5%86%99promise/"},{"name":"EventLoop Promise async await for...of","slug":"EventLoop-Promise-async-await-for-of","permalink":"http://example.com/tags/EventLoop-Promise-async-await-for-of/"},{"name":"同步 异步","slug":"同步-异步","permalink":"http://example.com/tags/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/"},{"name":"java读取文件","slug":"java读取文件","permalink":"http://example.com/tags/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/"},{"name":"作用域 闭包 this 手写bind","slug":"作用域-闭包-this-手写bind","permalink":"http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-this-%E6%89%8B%E5%86%99bind/"},{"name":"原型 原型链 class继承 instanceof","slug":"原型-原型链-class继承-instanceof","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-class%E7%BB%A7%E6%89%BF-instanceof/"},{"name":"值类型 引用类型 深拷贝 ==和=== truly和falsely变量","slug":"值类型-引用类型-深拷贝-和-truly和falsely变量","permalink":"http://example.com/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E5%92%8C-truly%E5%92%8Cfalsely%E5%8F%98%E9%87%8F/"},{"name":"rem vw vh响应式","slug":"rem-vw-vh响应式","permalink":"http://example.com/tags/rem-vw-vh%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"line-height的继承问题","slug":"line-height的继承问题","permalink":"http://example.com/tags/line-height%E7%9A%84%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/"},{"name":"absolute relative 居中对齐","slug":"absolute-relative-居中对齐","permalink":"http://example.com/tags/absolute-relative-%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/"},{"name":"盒模型 margin BFC 圣杯/双飞翼布局 flex布局","slug":"盒模型-margin-BFC-圣杯-双飞翼布局-flex布局","permalink":"http://example.com/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B-margin-BFC-%E5%9C%A3%E6%9D%AF-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80-flex%E5%B8%83%E5%B1%80/"},{"name":"语义化 块级元素 内联元素","slug":"语义化-块级元素-内联元素","permalink":"http://example.com/tags/%E8%AF%AD%E4%B9%89%E5%8C%96-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0/"},{"name":"flex","slug":"flex","permalink":"http://example.com/tags/flex/"},{"name":"KMP算法","slug":"KMP算法","permalink":"http://example.com/tags/KMP%E7%AE%97%E6%B3%95/"}]}