{"meta":{"title":"D-Moon's Blog","subtitle":"","description":"划船要不要用桨呢？这是一个问题","author":"D-Moon","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"JS的一些简单手写题","slug":"JS的一些简单手写题","date":"2021-12-17T12:39:56.000Z","updated":"2021-12-17T15:03:04.722Z","comments":true,"path":"2021/12/17/JS的一些简单手写题/","link":"","permalink":"http://example.com/2021/12/17/JS%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%89%8B%E5%86%99%E9%A2%98/","excerpt":"","text":"为了方便查找，我把 JS 的一些简单手写题做了一个汇总。 这些题目比较小，但是细节多，需要时时复习 1.手写深拷贝在JavaScript中，数组和对象都是引用类型，直接复制的是地址，所以需要深度拷贝以便修改不影响原来的数组或对象。主要运用到递归 1234567891011121314151617181920212223242526272829303132333435function deepClone(obj)&#123; // 先判断结果应该是 数组 还是 对象 let res = obj instanceof Array? []:&#123;&#125; // 递归终止条件 if(typeof(obj)!==&#x27;object&#x27; || obj == null)&#123; return obj &#125; for(let key in obj)&#123; // hasOwnProperty 返回一个布尔值，表示自身属性中是否具有指定的键，用在这里是为了多层的情况考虑 if(obj.hasOwnProperty(key))&#123; res[key] = deepClone(obj[key]) &#125; &#125; return res&#125;let obj1 = &#123; address:&#123; city: &#123; name:&quot;beijing&quot; &#125; &#125;&#125;// hasOwnProperty 介绍console.log(obj1.hasOwnProperty(&#x27;address&#x27;));// expected output: trueconsole.log(obj1.address.city.hasOwnProperty(&#x27;name&#x27;));// expected output: trueconsole.log(obj1.address.city.hasOwnProperty(&#x27;code&#x27;));// expected output: false// testlet obj2 = deepClone(obj1);obj2.address.city.name = &quot;Shanghai&quot;;console.log(obj1.address.city.name);console.log(obj2.address.city.name); 2.手写深度比较 （简单版）网上深度比较有很多的代码，简单的也有，复杂的也有，但是复杂的考虑得太全面了，考虑到我当前水平，还是简洁一点的比较适合我 我对这段代码主要是两个问题： 一是网上很多在判断的地方有一段代码： 判断是否传入同一个对象 123if(obj1 === obj2)&#123; return true &#125; 一开始我本地跑了好几次也没有用上过这段，所以就删掉了。 后来我想了想才发现，因为我们在写代码的时候，要从用户的角度出发，也就是我们不知道用户到底会传什么进来，有可能两个参数传递是一个对象，所以这段代码就是为了应对这种情况，不需要再浪费时间遍历递归去比较，还是很有必要的 还有一段是：判断任意一个不为引用类型的时候是否相等，大家都用的 || 123if(!isObject(obj1)&amp;&amp;!isObject(obj2))&#123; return obj1 === obj2 &#125; 这我也觉得很奇怪，如果一个是对象一个不是，那不是全部都是 false 吗？ 后来我换成 &amp;&amp; 试了一下，发现也是正确的，只是走的路径不一样。所以这里 || 或者 &amp;&amp; 应该都是正确的 123456789101112131415161718192021222324252627282930// 另写一个函数 判断是否为 不为空的对象或数组function isObject(obj)&#123; return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null&#125;// 递归函数function isEqual(obj1,obj2)&#123; // 递归终止条件 if(!isObject(obj1)||!isObject(obj2))&#123; return obj1 === obj2 &#125; if(obj1 === obj2)&#123; return true &#125; // 获取所有属性 const obj1Keys = Object.keys(obj1) const obj2Keys = Object.keys(obj2) if(obj1Keys.length !== obj2Keys.length)&#123; return false &#125; // 遍历递归比较 for(let key in obj1)&#123; const res = isEqual(obj1[key],obj2[key]) if(!res)&#123; return false &#125; &#125; return true&#125; 3.","categories":[],"tags":[{"name":"深拷贝 简单深比较","slug":"深拷贝-简单深比较","permalink":"http://example.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E7%AE%80%E5%8D%95%E6%B7%B1%E6%AF%94%E8%BE%83/"}]},{"title":"前端面试真题-part5","slug":"前端面试真题-part5","date":"2021-12-15T14:05:42.000Z","updated":"2021-12-17T12:03:19.267Z","comments":true,"path":"2021/12/15/前端面试真题-part5/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part5/","excerpt":"主要内容：Map Set 有序和无序 数组reduce求和","text":"主要内容：Map Set 有序和无序 数组reduce求和 1-part11） Map 和 Set 有序和无序 有序慢，无序快。但是无序本身就是一个缺点。比如说 v-dom里面，object什么的可以无序排列，但是数组必须是有序的。不然渲染过程会出现问题 可以结合二者优点：二叉树及其变种 2）Map 和 Object 区别 API 不同（略过，比较简单），Map可以以任意类型为 key 1234567function fn()const obj = &#123;&#125;let m = new Map()m.set(fn,&#x27;fn key&#x27;) m.set(obj,&#x27;obj key&#x27;)// 如果说是 Objectobj.fn() =&#x27;XXX&#x27; h// 报错 object 只能以 字符串为 key Map 是有序结构（重要） 12345678910111213let map = new Map([ [&#x27;key1&#x27;,&#x27;1&#x27;], [&#x27;key2&#x27;,&#x27;2&#x27;], [&#x27;key3&#x27;,&#x27;3&#x27;] ]) map.forEach((value,key)=&gt;&#123; console.log(key,value)&#125;) // key1 1// key2 2// key3 3// 如果把 map 的顺序改了 输出的顺序也会改 Map 操作同样很快 对比无序结构object 的 查找和删除操作 map 甚至会更快一点。 123456789101112131415161718192021const obj = &#123;&#125;for(let i = 0;i&lt;1000*1000;i++)&#123; obj[i+&#x27;&#x27;] = i&#125;console.time(&#x27;obj find&#x27;);obj[&#x27;500000&#x27;]console.timeEnd(&#x27;obj find&#x27;);console.time(&#x27;obj delete&#x27;);delete obj[&#x27;500000&#x27;]console.timeEnd(&#x27;obj delete&#x27;);const map = new Map()for(let i = 0;i&lt;1000*1000;i++)&#123; map.set(i+&#x27;&#x27;,i)&#125;console.time(&#x27;map find&#x27;);map.has(&#x27;500000&#x27;)console.timeEnd(&#x27;map find&#x27;);console.time(&#x27;map delete&#x27;);map.delete(&#x27;500000&#x27;)console.timeEnd(&#x27;map delete&#x27;); 3）Set 和 数组的区别 API 不同 123456const set = new Set([10,20,30])set.add(50)set.delete(20)set.has(30)set.sizeser.forEach(val=&gt; console.log(val)) // 无序结构 没有index Set 元素不能重复 Set 是无序结构，操作很快，和上面的代码差不多 1234567891011121314 // 数组比较慢 尤其是查找let arr = [10,20,30]for(let i = 0;i&lt;1000*1000;i++)&#123; arr[i] = i&#125;console.time(&#x27;arr push&#x27;);arr.push(&#x27;a&#x27;)console.timeEnd(&#x27;arr push&#x27;);console.time(&#x27;arr unshift&#x27;);arr.unshift(&#x27;b&#x27;)console.timeEnd(&#x27;arr unshift&#x27;);console.time(&#x27;arr includes&#x27;);arr.includes(100000)console.timeEnd(&#x27;arr includes&#x27;); 123456789101112// set 就快很多let set = new Set([10,20,30])for(let i = 0;i&lt;1000*1000;i++)&#123; set.add(i)&#125;console.time(&#x27;set add&#x27;);set.add(&#x27;a&#x27;)console.timeEnd(&#x27;set add&#x27;); console.time(&#x27;set has&#x27;);set.has(100000)console.timeEnd(&#x27;set has&#x27;); 4）WeakMap 和 WeakSet 弱引用，防止内存泄漏 ​ 可以随意添加信息，但是执行完了之后，对象就被销毁了，不用考虑是否还需要引用这些对象 WeakMap 只能用对象作为 key ，WeakSet 只能用 对象作为 value 没有 forEach 和 size ，只能用 add has delete 5）数组求和- Array reduce12345678910let arr = [1,2,3,4]// 比较简单易读，但是会多一个变量function sum(arr)&#123; let res = 0 for(let i = 0;i&lt;arr.length;i++)&#123; res += arr[i] &#125; return res&#125;console.log(sum(arr)); Array reduce 数组的拼接 计数什么的都很好用 123456789101112let arr = [1,2,3,4]const sum = arr.reduce((sum,curVal,index,arr)=&gt;&#123; console.log(&#x27;reduce function&#x27;); console.log(&#x27;sum&#x27;,sum); console.log(&#x27;curVal&#x27;,curVal); console.log(&#x27;index&#x27;,index); console.log(&#x27;arr&#x27;,arr); return sum + curVal&#125;,0) console.log(&#x27;final sum&#x27;,sum);","categories":[],"tags":[]},{"title":"前端面试真题-part4","slug":"前端面试真题-part4","date":"2021-12-15T12:37:06.000Z","updated":"2021-12-17T12:04:15.005Z","comments":true,"path":"2021/12/15/前端面试真题-part4/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part4/","excerpt":"主要内容：捕获异常，JSON ，获取 URL 参数，手写深拷贝","text":"主要内容：捕获异常，JSON ，获取 URL 参数，手写深拷贝 1-part11）如何捕获 JS 程序中的异常solution1 手动捕获(比较长的一串，所以用在高风险区域) 1234567try&#123; // todo&#125;catch(ex)&#123; console.error(ex)&#125;finally&#123; // todo&#125; solution 2 自动捕获 1234window.onerror = function(message,source,linNum,colNum,error)&#123; // 第一 对于跨域的 js ，比如 CDN 的，不会有详细的报错信息 // 第二，对于压缩的 js ，还要配合 sourceMap 反差到未压缩代码的行、列&#125; 2）什么是 JSON JSON 是一种数据格式，本质是一段字符串 JSON 格式和 js 对象结构一致，对 JS 语言更友好 window.JSON 是一个全局对象：JSON.stringify JSON.parse 123456789&#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;info&quot;: &#123; &quot;single&quot;: true, &quot;age&quot;: 30 &quot;city&quot;: &quot;Beijing&quot; &#125;, &quot;like&quot;: [&quot;music&quot;,&#x27;basketball&#x27;]&#125; 3）获取当前页面 url 参数 传统方式: location.search 假设 HTML 文件的参数列表为 ?a=10&amp;b=20&amp;c=30 （自己定义就是在 地址栏html 后面加上这一串） 1234567891011121314function query(name)&#123; const search = location.search.substring(1) // 去掉 search 前面的问号 // search = &#x27;a=10&amp;b=20&amp;c=30&#x27; const reg = new RegExp(`(^|&amp;)$&#123;name&#125;=([^&amp;]*)(&amp;|$)`,&#x27;i&#x27;) const res = search.match(reg) if(res === null)&#123; return null &#125; return res[2]&#125;const res = query(&#x27;a&#x27;)console.log(res); //10const res1 = query(&#x27;d&#x27;)console.log(res1); // null 新 API: URLSearchParams (兼容问题) 1234567function query(name)&#123; const search = location.search const p = new URLSearchParams(search) return p.get(name)&#125;res = query(&#x27;a&#x27;)console.log(res); 2-part21）将 url 解析为 JS 对象其实和获取当前页面 url 参数是一个意思，只不过不用正则表达式，用一个对象来接收 1234567891011121314function queryToObj()&#123; const res = &#123;&#125; const search = location.search.substring(1) // &#x27;a=10&amp;b=20&amp;c=30&#x27; search.split(&#x27;&amp;&#x27;).forEach(ele=&gt;&#123; const arr = ele.split(&#x27;=&#x27;) const key = arr[0] const val = arr[1] res[key] = val &#125;) return res&#125;console.log(queryToObj()); solution 2 12345678function queryToObj()&#123; const res = &#123;&#125; const pList = new URLSearchParams(location.search) pList.forEach((key,val)=&gt;&#123; res[key] = val &#125;) return res&#125; 2）手写 flatern 考虑多层级123456789function flat(arr)&#123; let isDeep = arr.some(item=&gt; item instanceof Array) if(!isDeep)&#123; return arr &#125; // Array.prototype.concat.apply([],arr) 只能拍平两层 所以要递归 let res = Array.prototype.concat.apply([],arr) return flat(res)&#125; 3）数组去重solution 1 // 用 indexOf 判断 res 里面有没有这个值 123456789function unique(arr)&#123; const res = [] arr.forEach(item =&gt; &#123; if(res.indexOf(item)&lt;0)&#123; res.push(item) &#125; &#125;); return res&#125; solution 2 使用 set（无序结构，不允许由于重复元素） 12345function unique(arr)&#123; const set = new Set(arr) return [...set]&#125; 3-part31）手写深拷贝 必会！！！注意 Object.assign 不是深拷贝，只是拷贝了第一层 1234567891011121314function deepClone(obj)&#123; if(typeof(obj)!==&#x27;object&#x27; || typeof(obj) == null)&#123; return obj; &#125; let res = obj instanceof Array?[]:&#123;&#125;; for(let key in obj)&#123; // 确保key不是原型链上的 if(obj.hasOwnProperty(key))&#123; // 递归（重点） key要一层一层遍历，比如说 obj&#123; address:&#123;city: &#x27;Beijing&#x27;&#125;&#125; res[key] = deepClone(obj[key]) &#125; &#125; return res;&#125; 2）介绍 RAF requestAnimationFrame 动画流畅，更新频率要达到 60帧/s ，即 16.67ms 更新一次视图 setTimeout 需要手动控制频率，而 RAF 浏览器会自动控制 后台标签隐藏在 iframe 中，RAF 会暂停，而 setTimeout 依然执行 1234567891011121314// html 里有一个 div 标签const $div1 = $(&#x27;#div1&#x27;)const max = 640let curWidth = 100function animate()&#123; curWidth = curWidth + 3 $div1.css(&#x27;width&#x27;,curWidth) if(curWidth&lt;max)&#123; // 如果是 setTimeout 的写法 setTimeOut(animate,16.7) 16.7这个数字要自己计算 window.requestAnimationFrame(animate) &#125;&#125;animate() 3）性能优化从哪几个方面考虑 原则：多使用内存，缓存，减少计算，减少网络请求 方向：加载页面，页面渲染，页面操作流畅度","categories":[],"tags":[]},{"title":"前端面试真题-part3","slug":"前端面试真题-part3","date":"2021-12-15T11:13:57.000Z","updated":"2021-12-17T12:04:52.536Z","comments":true,"path":"2021/12/15/前端面试真题-part3/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part3/","excerpt":"主要内容：函数声明和函数表达式、new Obeject() 和 Object.create()、 this","text":"主要内容：函数声明和函数表达式、new Obeject() 和 Object.create()、 this 1.part11）函数声明和函数表达式的区别 函数声明 function fn(){…} 函数表达式 const fn = function() {…} 函数声明会在代码执行前预加载，但是函数表达式不会 123456789101112131415// 函数声明 代码执行前函数已经初始化好了，所以不会报错const res = sum(10,20) console.log(res)function sum(x, y)&#123; return x +y&#125; // 函数表达式，用 let const 声明，不会提升所以函数就不会提前初始化，会报错// 用 var 定义，则 sum 已经变量提升，执行的时候 sum 是 undefined，代码会报错 sum is not a functionconst res = min(10,20)console.log(res)const min =&gt; (a,b)&#123; return a - b&#125; 2）new Obeject() 和 Object.create() 的区别 new Object() 和 {} 是等同的，所以它们的原型都是 Object.prototype Object.create(null) 没有原型（）里的是要传给其的参数 Object.create({…}) 可以指定原型 1234567891011121314const obj1 = &#123; a: 10, b: 20, sum()&#123; return this.a + this.b &#125;&#125;const obj2 = new Object(obj1) // obj1 === obj2const obj3 = Object.create(null) // 没有属性 没有原型const obj4 = new Object(null) // 没有属性 但是有原型const obj5 = Object.create(obj1) // 此时 obj5 的隐式原型是 obj1 也就是 Object，所以 obj5 的属性是空的，但是可以读取原型上的属性和方法const flag = (obj1 === obj5) // falseconst flag1 = (obj5.__proto__ === obj1) // true 3）关于 this 的场景题原则：函数里面 this 的值在执行的时候才知道， 1234567891011121314151617const User = &#123; count: 1, getCount: function()&#123; return this.count &#125;&#125;const a = &#123; count: 2&#125;console.log(User.getCount()); // 1 ，this 就是 User， this.count 就是 User.countconst func = User.getCount// 如果把 User的 getCount 作为单独的函数执行，那么this 就相当于 window了console.log(func()); // undefined console.log(func.call(a)); // 执行的时候 this 指向 a 就有 count 了 2.part21）关于作用域和自由变量的场景题-1一是全局变量，二是 setTimeout 是异步函数 对于全局变量，由于setTimeout 是异步函数，循环是同步，所以要等同步函数执行完，但是这样全局变量已经加到 4 了 123456789101112131415161718192021let ifor(i = 1; i&lt;=3; i++)&#123; setTimeout(()=&gt;&#123; console.log(i) &#125;,0)&#125;// 4 4 4for(let i = 1;i&lt;=3;i++)&#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 0);&#125;// 1 2 3let j for(j = 1;j&lt;=3;j++)&#123; console.log(j)&#125;console.log(j)// 1 2 3 4 对于同步函数 一次循环从上往下执行 所以即使是全局变量 也是一个挨一个打印 2）关于作用域和自由变量的场景题-2123456789let a = 100function test()&#123; alert(a) a = 10 alert(a)&#125;test()alert(a)// 100 10 10 3）判断字符串以字母开头，后面字母数字下划线，长度 6-30原则：利用正则表达式（一般来说面试的题比较简单，日常工作还是需要查的） 解释：/ $/ 正则表达式的开头结尾（可选，看是要全部满足还是满足开头或者结尾）；^ 表示字符串开始；[ ] 里的内容表示选择规则，也就是 a-zA-Z的字母保留 \\w 表示 匹配字母数字下划线，{5,29} 表示长度 是 &gt;= 5 &lt;=29 (因为前面 \\w 已经占了一个长度) 1const reg = /^[a-zA-Z]\\w&#123;5,29&#125;$/ 123456789101112//基础的正则表达式// 邮政编码/\\d&#123;6&#125;/// 英文小写字母/^[a-z]+$/// 英文字母/^[a-zA-Z]+$/// 日期格式/^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/// 简单的IP地址/\\d+\\.\\d+\\.\\d+/ 常见正则表达式 https://deerchao.cn/tutorials/regex/regex.htm https://www.runoob.com/regexp/regexp-tutorial.html 3.part31）手写字符串 trim（把开头和结尾的空格删掉） 方法，保证浏览器兼容性原则：用 正则表达式 来解决，同时也有原型和this 12345678if(!String.prototype.trim)&#123; String.prototype.trim = function()&#123; return this.replace(/^\\s+/,&#x27;&#x27;).replace(/\\s+$/,&#x27;&#x27;)&#125;&#125;// replace(/^\\s+/,&#x27;&#x27;)选中开头是多个（+号的作用）空格的字符串，把多个空格用 &#x27;&#x27; 代替// replace(/\\s+$/,&#x27;&#x27;)选中结尾是多个（+号的作用）空格的字符串，把多个空格用 &#x27;&#x27; 代替// 因为 trim 是 ES5 的，可能有的不支持，所以先判断 String 的原型上有没有 trim 方法，没有就添加// this 通过 字符串.prototype 执行，this 就是这个字符串 2）如何获取多个数组中的最大值solution 1 12Math.max()Math.min() solution 2 1234567891011function findMax ()&#123; const nums = Array.prototype.slice.call(arguments) // 不知道为什么用箭头函数的话 nums 就会执行不出来 很奇怪 let max = nums[0] console.log(nums); nums.forEach(i =&gt; &#123; if(max &lt;= i ) max = i &#125;); return max&#125; 3）如何用 JS 实现继承 class 继承（更加推荐） prototype 继承（不推荐） ​","categories":[],"tags":[]},{"title":"前端面试真题-part2","slug":"前端面试真题-part2","date":"2021-12-15T08:18:44.000Z","updated":"2021-12-17T12:05:28.858Z","comments":true,"path":"2021/12/15/前端面试真题-part2/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part2/","excerpt":"主要内容：事件代理、闭包、事件冒泡","text":"主要内容：事件代理、闭包、事件冒泡 1-part11）call 和 apply 的区别123// call 和 applyfn.call(this,p1,p2,p3)fn.apply(this,arguments) 2）事件代理（委托）是什么3）闭包是什么？有何特性？有何影响？ 作用域和自由变量 闭包应用场景 自由变量的查找，要在函数定义的地方（而不是执行的地方） 影响：有可能变量会常驻内存，得不到释放。闭包不要乱用。不一定是内存泄漏 内存泄漏：自由变量，也就是返回的值是自由变量，用完就释放，但是如果返回/传入的是带参数的函数，那么这个参数因为之后还有可能会被使用，所以就不会释放 2-part21）如何阻止事件冒泡和默认行为12event.stopPropagation()event.preventDefault() 2）查找、添加、删除、移动 DOM 节点的方法？1 3）如何减少 DOM 操作？ 缓存 DOM 查询结果 多次 DOM 操作，合并到一次插入 3-part31）解释 jsonp 原理，为何不是真正的 ajax 浏览器的同源策略（服务端没有同源策略，其实是没有 跨域 这一说，叫转发）和跨域 jsonp 利用的 script 标签 的跨域功能，ajax 利用 XMLRequest API 来执行的 哪些 HTML 标签可以绕过跨域 jsonp 原理：其实就是 2）== 和 === 的区别 == 强制类型转换 === 严格相等 只有 == null 才用 两等 3）document load 和 ready 的区别 load 网络所有资源全部加载完成才执行 ready DOM渲染完即可执行","categories":[],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"}]},{"title":"前端面试真题-part1","slug":"前端面试真题-part1","date":"2021-12-15T05:57:04.000Z","updated":"2021-12-17T13:07:17.599Z","comments":true,"path":"2021/12/15/前端面试真题-part1/","link":"","permalink":"http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98-part1/","excerpt":"主要内容：var let const 、深度比较、数组的方法","text":"主要内容：var let const 、深度比较、数组的方法 1. part-11）var let const 的区别 var 是 ES5 语法，let const 是 ES6 语法；var 有变量提升 123456789// ES5 变量提升// ES5在执行的时候，会先把 var 定义的值先提出来定义为 undefinedconsole.log(a); // undefiendvar a = 200// 相当于 var aconsole.log(a); // undefienda = 200 var 和 let 是变量，可以修改，const 是常量， 不可以修改 let 和 const 都有块级作用域，var 没有 12345678910111213// var 定义的变量是全局变量for(var i = 0;i&lt;10;++i)&#123; var j = i + 1&#125;console.log(i,j); // 10// let 定义的变量只在自己的块级作用域里// 块级作用域for(let i = 0;i&lt;10;++i)&#123; let j = i + 1&#125;console.log(i,j); // 报错 undefined 2）typeof 返回 undefined string number boolean symbol （值类型） object （注意 typeof null === ‘object’）（引用类型都判断为 object） function （函数是单独的） 3）列举 强制类型转换 和 隐式类型 转换 强制：parseInt parseFloat toString 隐式：if、逻辑运算、==、+ 拼接字符串 2.part-21）手写深度比较，模拟 lodash isEqual1234567891011121314151617181920212223242526272829// 另写一个函数 判断是否为 不为空的对象或数组function isObject(obj)&#123; return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null&#125;// 递归函数function isEqual(obj1,obj2)&#123; // 递归终止 if(!isObject(obj1)||!isObject(obj2))&#123; return obj1 === obj2 &#125; if(obj1 === obj2)&#123; return true &#125; // 确保两个都是对象或数组 且不相等 const obj1Keys = Object.keys(obj1) const obj2Keys = Object.keys(obj2) if(obj1Keys.length !== obj2Keys.length)&#123; return false &#125; // 递归比较 for(let key in obj1)&#123; const res = isEqual(obj1[key],obj2[key]) if(!res)&#123; return false &#125; &#125; return true&#125; 2）split() 和 join() 的区别12&#x27;1-2-3&#x27;.split(&#x27;-&#x27;) // [1,2,3][1,2,3].join(&#x27;-&#x27;) // &#x27;1-2-3&#x27; 3）数组的 pop push unshift shift 分别做什么从三个方面来说 分别的功能 分别的返回值 是否会对原数组造成影响 123456789101112131415// pop 删除最后一个元素，返回删除的这个元素，会改变原数组let a = [1,2,3]console.log(a.pop(),a); // 3, [1,2] // shift 删除第一个元素，返回删除的这个元素，会改变原数组let b = [4,5,6]console.log(b.shift(),b); // 4, [5,6] // push 把元素加到最后面,返回数组的长度，会改变原数组let c = [7,8,9]console.log(c.push(10),c); // 4 [ 7, 8, 9, 10 ] // unshift 把元素加到最前面,返回数组的长度，会改变原数组let d = [11,12,13]console.log(d.unshift(14),d); // 4 [ 14, 11, 12, 13 ] 4）数组的纯函数 API 纯函数的定义——1.不改变原数组；2.返回一个数组。 所以 3）中的 API 都不是纯函数，还有 forEach，some every，reduce，这三个虽然不改变原数组，但不返回一个数组 以下列举一些常见的数组纯函数 API：concat map filter slice 1234567// concat map filter slice 都不会改变原数组 同时返回一个新数组const arr = [1,2,3,4]const arr1 = arr.concat([5,6,7,8]) // 拼接两个数组 [1, 2, 3, 4, 5, 6, 7, 8]const arr2 = arr.map( num =&gt; num * 3) // 按照一定规则遍历改变元素 [ 3, 6, 9, 12 ]const arr3 = arr.filter( num =&gt; num &gt; 2) // 按照一定规则过滤元素 [ 3, 4 ]const arr4 = arr.slice() // 相当于深拷贝原数组 [ 1, 2, 3, 4 ] 3.part31）数组 slice 和 splice 的区别从三个方面来说 功能区别 参数和返回值 是不是纯函数 1234567891011const arr = [1, 2, 3, 4]// slice 纯函数const arr1 = arr.slice() // 深拷贝 [1, 2, 3, 4]const arr2 = arr.slice(1,3) // slice(startIndex,endIndex) 左闭右开 [2, 3]const arr3 = arr.slice(1) // slice(startIndex) 从开始截取到最后 [2, 3, 4]const arr4 = arr.slice(-2) // slice(负值) 倒数的几个值 [3, 4]// splice 非纯函数 三个参数 (startIndex, length, replaceValue) 后两者都是可选的const arr5 = arr.splice(1,2,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)console.log(arr5); // [2, 3]console.log(arr); // [ 1, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 4 ] 2）[10, 20, 30].map(parseInt) map 的参数和返回值 (item, index) 返回一个数组 parseInt 的参数和返回值 parseInt(string, radix); 解析一个字符串并返回指定基数的十进制整数，也就是说 把一个 radix 进制的 string 转换为一个十进制数并且输出 123456789const res = [10,20,30].map(parseInt)console.log(res); // [ 10, NaN, NaN ]// 拆解来看： res = [10, 20, 30].map((item,index)=&gt;&#123; // parseInt(10,0); 0 相当于 10 进制，也就是把一个 10 进制的数变成 10 进制输出 // parseInt(20,1); 把一个 1 进制的数 20 输出为 10 进制，给定的 20 不符合 1 进制 所以输出 NaN return parseInt(item,index)&#125;) 3）ajax 的请求 get 和 post 的区别 get 一般用于查询操作，post 一般用户提交操作 get 参数拼接在 url 上， post 放在请求体内（数据体积更大） 安全性：post 防止 CSRF","categories":[],"tags":[{"name":"前端面试","slug":"前端面试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"}]},{"title":"手写防抖和节流","slug":"手写防抖和节流","date":"2021-12-14T12:27:11.000Z","updated":"2021-12-16T09:24:02.876Z","comments":true,"path":"2021/12/14/手写防抖和节流/","link":"","permalink":"http://example.com/2021/12/14/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"1.防抖","text":"1.防抖 1）例子 比如说用户输入搜索事件，如果用 keyup 监听，文字一直在变化 keyup 一直发生，那么就会频繁触发 change 事件。所以我们需要防抖的功能，实现当用户输入结束或者暂停时才触发 change 事件 2）代码思路演示 123456789101112131415161718const inp1 = document.getElementById(&#x27;inp1&#x27;)// 不做防抖 keyup 不停触发，文字内容不停打印，所以要对 function 做防抖改进// inp1.addEventListener(&#x27;keyup&#x27;,function()&#123;// console.log(inp1.value);// &#125;)let timer = nullinp1.addEventListener(&#x27;keyup&#x27;,function()&#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(function()&#123; // 模拟触发 console.log(inp1.value); // 清空定时器 timer = null &#125;,500)&#125;) 3）流程分析 比如说单独输入 1， 一开始没有 timer，所以就在 500 ms 以后打印 如果连续输入 123， 4）封装优化 返回一个函数 fn.apply(this,arguments) 相当于 fn(), 只不过更全面，如果用了 apply 的话，在调用的时候，debounce传入的函数不能是箭头函数，不然改不了 this 123456789101112131415function debounce(fn,delay)&#123; let timer = null return function()&#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(function()&#123; fn.apply(this,arguments) timer = null &#125;,delay) &#125;&#125;inp1.addEventListener(&#x27;keyup&#x27;,debounce(function()&#123; console.log(inp1.value);&#125;,500)) 2.节流1）例子 不停拖拽一个元素的时候，我们如果用 drag 事件随时拿到拖拽的位置的话，频繁触发可能会导致卡顿，所以我们需要节流，实现无论拖拽速度有多快，都会每隔固定的一段时间才出发啊一次 2）代码思路演示 12345678910111213// 和防抖差不多 只是if(timer)的处理逻辑不一样let timer = nulldiv1.addEventListener(&#x27;drag&#x27;,function(e)&#123; if(timer)&#123; return &#125; timer = setTimeout(()=&gt;&#123; // 注意 e 是 dragevent 的对象，是传进来函数的参数 不是 setTimeout 的参数 console.log(e.offsetX,e.offsetY); timer = null &#125;,100) &#125;) 3）过程分析 一开始 timer 赋值为 null，最开始先给 timer 赋值，还没到 100ms 就触发了 drag 事件但是 setTimeout 事件还没有到时间，所以 timer 一直有值。 也就是说在 100ms 内，if(timer) 都在 return，什么都不执行。等到了 100ms，就打印，然后又开始下一个 100ms 的进程。 4）封装优化 1234567891011121314151617const div1 = document.getElementById(&#x27;div1&#x27;)function throttle(fn,delay)&#123; let timer = null; return function()&#123; if(timer)&#123; return &#125; timer = setTimeout( ()=&gt;&#123; fn.apply(this,arguments) timer = null &#125;,delay) &#125;&#125;div1.addEventListener(&#x27;drag&#x27;,throttle(function(e)&#123; console.log(e); console.log(e.offsetX);&#125;,1000)) 如果要获得触发事件的元素 e ，有两个要注意的点，setTimeout 里面是箭头函数，而是传给 throttle 的函数里面要传参 e","categories":[],"tags":[{"name":"手写防抖 手写节流","slug":"手写防抖-手写节流","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96-%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81/"}]},{"title":"运行环境","slug":"运行环境","date":"2021-12-14T11:14:44.000Z","updated":"2021-12-16T09:24:42.505Z","comments":true,"path":"2021/12/14/运行环境/","link":"","permalink":"http://example.com/2021/12/14/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","excerpt":"1.运行环境运行环境即浏览器（server端有nodejs），下载网页代码时渲染出页面，期间执行js。为了用户体验，我们要保证代码在浏览器中运行时稳定且高效。","text":"1.运行环境运行环境即浏览器（server端有nodejs），下载网页代码时渲染出页面，期间执行js。为了用户体验，我们要保证代码在浏览器中运行时稳定且高效。 2.网页加载过程2.1加载资源的形式和过程1）资源的形式：html 代码；媒体文件，如图片视频等；js，css文件 2）过程： DNS解析：域名→ IP地址 浏览器根据 IP 地址向服务器发起 http 请求（实际上还涉及到操作系统 三次握手什么的） 服务器处理 http 请求，并返回给浏览器 （返回的形式要看请求的是什么） 2.2渲染页面的过程 根据 HTML 代码生成 DOM Tree 根据 CSS 代码生成 CSSOM 将 DOM Tree 和 CSSOM 整合形成 Render Tree 浏览器根据 Render Tree 渲染页面 遇到 则暂停渲染，优先加载并执行 JS 代码，完成再继续。因为 script 里面可能有改变 DOM 树的代码 2.3 问题1）为什么 css 要放到 head标签里呢？ 在 DOM 树生成以前就可以加载完 CSS，最后按照 CSS 的规则统一渲染，不用重复 2）为什么要把 js 放到 body 最后呢？ 和 1）的解释差不多，如果不放在最后很有可能出现页面渲染到一半停住的情况 3）window.onload 和 DOMContentLoaded 的区别 window.onload 123window.addEventListener(&#x27;load&#x27;,function()&#123; // 页面的资源全部加载完才会执行，包括图片 视频等&#125;) DOMContentLoaded 123document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123; // DOM 渲染完即可执行，此时图片、视频可能还没有加载完，比较快一点&#125;) 4）从输入 url 到显示出整个页面的过程 加载资源→渲染页面 3.性能优化3.1.1 原则 多使用内存、缓存或其它方法 减少 CPU 计算量，减少网络加载耗时 实际上是空间换时间 3.2 具体优化3.2.1 优化的方向1）加载更快 减少压缩体积：压缩代码 减少访问次数：合并代码（http请求耗时相对长，一次 9kb 比 三次3kb 要快很多）、SSR 服务器端渲染、缓存 使用更快的网络：CDN 2）渲染更快 CSS 在 head，JS 在 body 下面 今早开始执行 JS，用 DOMContentLoaded 加载 懒加载 对 DOM 查询进行缓存 频繁 DOM 操作，合并到一起插入 DOM 结构 节流throttle 防抖debounce 3.2.2 一些具体实现1） 缓存 静态资源加 hash 后缀，根据文件内容计算 hash 文件内容不变，那么 hash 不变，那么 url 不变 url 和文件不变，则会自动触发 http 缓存机制，返回 304 2）SSR 服务端渲染：将网页和数据一起加载，一起渲染 非SSR（前后端分离）：先加载网页，再加载数据，在渲染数据 3）懒加载 需要的时候才加载，不需要就不加载 比如说图片，先把图片地址赋值成一张预览图，等用户浏览到这张图片时，再把真正的地址加载出来 4）缓存 DOM 查询 12345678910// 不缓存 DOM 查询结果for(let i = 0;i&lt;document.getElementsByTagName(&#x27;p&#x27;).length;i++)&#123; // 每次循环都会计算length，频繁进行DOM查询&#125;// 缓存 DOM 查询结果let len = document.getElementsByTagName(&#x27;p&#x27;)for(let i = 0;i&lt;len; i++)&#123; // 缓存length 只会查询一次DOM&#125; 5）多个 DOM 操作一起插入到 DOM 结构 1234567891011const list = document.getElementById(&#x27;list&#x27;)// 创建一个文档片段 此时还没有插入到 DOM 结构中const frag = document.createElement(&#x27;fragment&#x27;)for(let i = 0;i&lt;10;i++)&#123; const li = document.createElement(&#x27;li&#x27;) li.innerHTML = `List item $&#123;i&#125;` // 先把 li 插入到 文档片段中 frag.appendChild(li)&#125;// 最后一次性插入到 DOM 结构中list.appendChild(frag) 4.安全4.1.1 XSS跨站请求 攻击1）举例 2）防御 把 &lt;、/&gt;分别变成 &amp;lt；和 &amp;gt；这样会直接显示出来而不执行 4.1.2 XSRF跨站请求 伪造1）举例 2）防御 使用post接口 增加验证","categories":[],"tags":[{"name":"网页加载","slug":"网页加载","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2021-12-14T10:43:14.000Z","updated":"2021-12-16T08:52:57.702Z","comments":true,"path":"2021/12/14/linux常用命令/","link":"","permalink":"http://example.com/2021/12/14/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"1.常用命令","text":"1.常用命令 ls 查看文件夹ls-a 查看隐藏文件ll 列表显示clear 清屏mkdir 创建文件夹rm fileName 删除文件rm -rf fileName 删除文件夹（递归强制全部）cd fileName 跳转目录mv fieName newFileName 修改文件名mv fieName address 移动目录cp fieName newFileName 拷贝文件touch fileName 新建文件vi fileName 有的话直接打开，没有的话新建文件并且打开cat fileName 打印文件所有内容head fileName 打印前面几行tail fileName 打印后面几行grep “keywords” fileName 在文件查找有关键字的内容 2.vim 编辑模式（简单版） 进去vim编辑器模式 先点 i切换到insert模式 esc退出 :w 保存 :q退出 :q! 强制退出 vimtutor：vim官方教程","categories":[],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"手写Promise","slug":"手写Promise","date":"2021-12-12T02:32:43.000Z","updated":"2021-12-17T12:01:08.385Z","comments":true,"path":"2021/12/12/手写Promise/","link":"","permalink":"http://example.com/2021/12/12/%E6%89%8B%E5%86%99Promise/","excerpt":"手写Promise","text":"手写Promise 先给出一个 promise 作为例子 1234const p1 = new Promise((resolve,reject)=&gt;&#123; // resolve(value) // reject(reason)&#125;) I. 结构1.myPromise 类12345678910111213141516171819202122232425262728class myPromise &#123; // 1.需要的全局变量 state = &#x27;pending&#x27; // promise 本身有三个状态，所以我们定义一个状态变量 pending fulfilled rejected value = undefined // 成功后的值 reason = undefined // 失败后的原因 resolveCallbacks = [] // pending 状态下存储成功的回调 rejectCallbacks = [] // pending 状态下存储失败的回调 // 2 定义 constructor // 2.1 从 p1 看出，constructor 参数是两个函数，这两个函数又分别有自己的参数，一个声明为 value 一个声明为 reason constructor(fn)&#123; const resolveHandler = (value)=&gt;&#123;&#125; const rejectHandler = (reason)=&gt;&#123;&#125; // 2.2 为了函数稳定性 在 try catch 里面执行 try&#123; fn( resolveHandler,rejectHandler) &#125;catch(err) &#123; rejectHandler(err) &#125; &#125; // 3 方法 then 和 catch then(fn1,fn2)&#123; &#125; catch(fn)&#123; &#125;&#125; 2.myPromise 的全局静态API1234myPromise.resolve = function()&#123; &#125; myPromise.reject = function()&#123; &#125; myPromise.all = function()&#123; &#125; myPromise.race = function()&#123; &#125; II. 详细代码1.constructor 部分考虑以下几点 1）状态只有 pending → fulfilled 和 pending→rejected 2）回调函数数组里面不只一个函数，所以要遍历执行 123456789101112131415161718constructor(fn)&#123; const resolveHandler = (value)=&gt;&#123; // 执行函数之前，要先判断并且限定状态 if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;fulfilled&#x27; // 把 value 存储起来 this.value = value // 在成功的状态下，就执行成功的回调，但是回调函数不止一个，所以要遍历执行 把 value 传进来 this.resolveCallbacks.forEach(fn =&gt; fn(this.value)) &#125; &#125; const rejectHandler = (reason)=&gt;&#123; if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectCallbacks.forEach(fn =&gt; fn(this.reason)) &#125; &#125; 2.方法部分1） then 里面有两个参数 fn1 fn2 pending状态不执行,把它们存储起来； resolveed状态执行fn1； rejected状态执行 fn2 2）catch 方法相当于 then 的语法糖，因为 then 方法里面本身就可以传进来两个函数，第一个是成功的回调，一个是失败的回调。比如说下面这个例子：then 里面传入两个函数，p2.then() 就执行了后面一个函数。 12345678const p2 = Promise.reject(&#x27;my error&#x27;).catch(err=&gt;&#123; throw new Error(&#x27;catch error&#x27;)&#125;)p2.then(()=&gt;&#123; console.log(&#x27;resolved&#x27;);&#125;,()=&gt;&#123; console.log(&#x27;rejected&#x27;);&#125;) 3）在 then 方法里，主要部分是判断我们 Promise 的状态，不同的状态做不同的事情 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455then(fn1,fn2)&#123; // 1.因为传入 then 的时候，第一个参数可能是 null 所以需要判断一下类型，以便决定是否执行 // 1.1如果是函数，就是自己，不是的话，传入什么就是什么 类似于 p.then(v=&gt;v) fn1 = typeof fn1 === &#x27;function&#x27;? fn1 :(v) =&gt; v fn2 = typeof fn1 === &#x27;function&#x27;? fn2 :(err) =&gt; err // 2.接下来需要判断状态 但不管是什么状态 then 里面不管执行什么代码，返回的都是一个新的 promise // 2.1 pending 存储 fn1 fn2 ，也就是添加到回调列表里面 if(this.state === &#x27;pending&#x27;)&#123; const p = new myPromise((resolve,reject)=&gt;&#123; // 在这里我们只是把函数push进来了，还没有开始遍历执行，当它开始执行的时候，说明状态已经变了，value也就存在 this.resolveCallbacks.push(()=&gt;&#123; try&#123; const newValue = fn1(this.value) resolve(newValue) &#125;catch(err)&#123; reject(err) &#125; &#125;) this.rejectCallbacks.push(()=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) &#125;) return p &#125; // 2.2 fulfilled 执行 fn1 if(this.state === &#x27;fulfilled&#x27;)&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newValue = fn1(this.value) // newValue 是 fn1 用了当前promise的value执行后的值，要返回给新的promise（实现链式调用） resolve(newValue)// 把返回的 newValue 给 resolve 再执行 &#125;catch(err)&#123; reject(err) &#125; &#125;) return p1 &#125; // 2.3 rejected 执行 fn2 if(this.state === &#x27;rejected&#x27;)&#123; const p2 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) return p2 &#125; &#125; 4）catch 方法 相当于 then 执行第二个函数 123catch(fn)&#123; return this.then(null,fn) &#125; 3.全局API 部分1）resolve 和 reject 都比较简单 1234567myPromise.resolve = function(value)&#123; return new myPromise((resolve,reject)=&gt;resolve(value))&#125;myPromise.reject = function(reason)&#123; return new myPromise((resolve,reject)=&gt;reject(reason))&#125; 2.race 123456789101112131415161718// race 只要有一个 fulfilled，就返回 promisemyPromise.race = function(promiseList = [])&#123; let resolved = false const p1 = new myPromise((resolve,reject)=&gt;&#123; promiseList.forEach(p=&gt;&#123; p.then((data)=&gt;&#123; if(!resolved)&#123; resolve(data) resolved = true &#125; &#125;).catch((err)=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125; 3)all 12345678910111213141516171819202122// all 传入 promise 数组，等待所有都 fulfilled 之后，返回新 promisemyPromise.all = function(promiseList = [])&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; const result = [] // 存储 promiseList 所有的结果 const length = promiseList.length let resolveCount = 0 // 在 forEach 里面不能用forEach((p,index)=&gt;&#123;&#125;)的index来判断是否都执行完，因为 forEach 很快，index瞬间就加满了，但是 then里面的函数不一定执行完了（尤其是有异步函数的情况） promiseList.forEach(p=&gt;&#123; p.then(data=&gt;&#123; result.push(data) // resolveCount 只能在then里面加，也就是then执行了才能加 resolveCount++ if(resolveCount === length)&#123; resolve(result) &#125; &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125; III. 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class myPromise &#123; class myPromise &#123; state = &#x27;pending&#x27; value = undefined reason = undefined resolveCallbacks = [] rejectCallbacks = [] constructor(fn)&#123; const resolveHandler = (value)=&gt;&#123; if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;fulfilled&#x27; this.value = value this.resolveCallbacks.forEach(fn =&gt; fn(this.value)) &#125; &#125; const rejectHandler = (reason)=&gt;&#123; if(this.state === &#x27;pending&#x27;)&#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectCallbacks.forEach(fn =&gt; fn(this.reason)) &#125; &#125; try&#123; fn( resolveHandler,rejectHandler) &#125;catch(err)&#123; rejectHandler(err) &#125; &#125; then(fn1,fn2)&#123; fn1 = typeof fn1 === &#x27;function&#x27;? fn1 :(v) =&gt; v fn2 = typeof fn1 === &#x27;function&#x27;? fn2 :(err) =&gt; err if(this.state === &#x27;pending&#x27;)&#123; const p = new myPromise((resolve,reject)=&gt;&#123; this.resolveCallbacks.push(()=&gt;&#123; try&#123; const newValue = fn1(this.value) resolve(newValue) &#125;catch(err)&#123; reject(err) &#125; &#125;) this.rejectCallbacks.push(()=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) &#125;) return p &#125; if(this.state === &#x27;fulfilled&#x27;)&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newValue = fn1(this.value) resolve(newValue) &#125;catch(err)&#123; reject(err) &#125; &#125;) return p1 &#125; if(this.state === &#x27;rejected&#x27;)&#123; const p2 = new myPromise((resolve,reject)=&gt;&#123; try&#123; const newReason = fn2(this.reason) reject(newReason) &#125;catch(err)&#123; reject(err) &#125; &#125;) return p2 &#125; &#125; catch(fn)&#123; return this.then(null,fn) &#125;&#125;myPromise.resolve = function(value)&#123; return new myPromise((resolve,reject)=&gt;resolve(value))&#125;myPromise.reject = function(reason)&#123; return new myPromise((resolve,reject)=&gt;reject(reason))&#125;myPromise.all = function(promiseList = [])&#123; const p1 = new myPromise((resolve,reject)=&gt;&#123; const result = [] const length = promiseList.length let resolveCount = 0 promiseList.forEach(p=&gt;&#123; p.then(data=&gt;&#123; result.push(data) resolveCount++ if(resolveCount === length)&#123; resolve(result) &#125; &#125;).catch(err=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125;myPromise.race = function(promiseList = [])&#123; let resolved = false const p1 = new myPromise((resolve,reject)=&gt;&#123; promiseList.forEach(p=&gt;&#123; p.then((data)=&gt;&#123; if(!resolved)&#123; resolve(data) resolved = true &#125; &#125;).catch((err)=&gt;&#123; reject(err) &#125;) &#125;) &#125;) return p1 &#125;","categories":[],"tags":[{"name":"手写Promise","slug":"手写Promise","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99Promise/"}]},{"title":"JS面试篇-Part9","slug":"JS面试篇-Part9","date":"2021-12-11T10:52:57.000Z","updated":"2021-12-12T07:17:28.172Z","comments":true,"path":"2021/12/11/JS面试篇-Part9/","link":"","permalink":"http://example.com/2021/12/11/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part9/","excerpt":"1.http常见的状态码","text":"1.http常见的状态码 码 含义 1xx 服务器收到请求 2xx 请求成功，如 200 3xx 重定向，如 301(永久重定向) 302（临时重定向）304(资源未被修改) 4xx 客户端错误，如 404(资源未被找到) 403(没有权限) 5xx 服务端错误，如 500(服务器错误) 504(网关错误) 2.http methods Restful API 传统的 methods get 获取数据，post 向服务器发送数据 现在的 methods get 获取数据 post 新建数据 patch/put 更新数据 delete 删除数据 Restful API 一种新的 API 设计方法（早已推广使用） 传统API设计：把每个 url 当做一个功能 Restful API：把每个 url当做一个唯一的资源 如何把 url 设计成一个资源？ 不使用 url 参数 传统 API：/api/list?pageIndex = 2; Restful API: /api/list/2 method 表示操作类型 传统 API： post：/api/create-blog; post: /api/update-blog?id=100; get: /api/get-blog?id=100（url里面就知道要做什么了，也就是功能） Restful API： post: /api/blog; patch: /apiblog/100; get: /api/blog/100 (只能看出来资源标识也就是100，看请求名，才能知道具体要做什么，增加，更新，获得) 3.http headers 常见的 Request Headers 名称 含义 Accept 浏览器可接收的数据格式 Accept-Encoding 浏览器可接收的压缩算法，如gzip Accept-Language 浏览器接收的语言 如 zh-CN Connection: keep-alive 一次TCP链接重复使用 cookie 同域请求，浏览器都会自带 host 请求的域名 User-Agent（UA） 浏览器信息 Content-type 发送数据的格式，如 application/json 常见的 Response Headers 名称 含义 Content-type 返回数据的格式，如 application/json Content-length 返回数据的大小，多少字节 Content- Encoding 返回数据的压缩算法，如 gzip Set-Cookie 服务端修改 cookie 缓存相关的 headers （第四点） cache-control ​ 4.http缓存 缓存介绍 把可以重复利用的存储下来，让下次访问页面加载得更快些 网络请求环节加载比较慢，需要提高速度，优化网络请求需要缓存 静态资源可以被缓存，js css img http 缓存策略（强制缓存+协商缓存） 强制缓存 过程：发送请求到服务器，返回带cache-control给浏览器，浏览器下次就向本地缓存请求返回资源（缓存过期则重新向服务器请求） // 图片 Expires 同在 response headers 中，控制缓存过期，已被 cache-control 替代 cache-control（为主） 名称 含义 max-age 缓存最大过期时间 no-cache 不用本地（强制）缓存，到服务端请求 no-store 不用本地缓存，也不用服务端缓存，服务端直接返回资源即可 private/public 只能用户终端做缓存/中间代理等也可以做缓存 协商缓存（对比缓存） 服务端缓存策略（服务端判断资源是否要缓存，不是说要缓存在服务端） 服务端判断客户端资源是否和服务端资源一样 一致则返回 304，否则返回 200 和最新的资源 资源标识 在response headers 中，有两种 Last-Modified 资源的最后修改时间 Etag 资源的唯一标识（一个字符串，类似于人的指纹） 优先使用Etag，因为Last-Modified 的精度在秒级，精度不高，如果资源被重复生成，而内容不变用Etag比较精确。（因为重复生成时间会变则Last-Modified会变，Etag是基于内容生成的，所以Etag不会变） ​ 刷新方式对缓存的影响 正常操作：地址栏输入 url，跳转链接，前进后退；强制缓存有效，协商缓存有效 手动刷新：F5，右击菜单刷新；强制缓存失效，协商缓存有效 强制刷新：ctrl + f5；强制缓存失效，协商缓存失效 5.https http和https http 明文传书，敏感信息容易被中间劫持 https：http + 加密，劫持了也无法解密 现代浏览器已经开始强制 https 协议 加密方式：对称加密，非对称加密 对称加密：服务端和客户端用同一个 key 在传输过程中加密和解密，不安全，因为key也在传输过程中传输 过程 非对称加密：一对 key，pubkey 加密后只能用 key 来解密 过程 https 用了这两种方式加密 过程 https 证书 中间人攻击，把 pubkey 掉包 使用第三方证书 浏览器校验证书 过程","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}]},{"title":"JS面试篇-Part8","slug":"JS面试篇-Part8","date":"2021-12-11T02:39:39.000Z","updated":"2021-12-16T09:31:19.190Z","comments":true,"path":"2021/12/11/JS面试篇-Part8/","link":"","permalink":"http://example.com/2021/12/11/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part8/","excerpt":"1. ajax","text":"1. ajax 1.1 知识点 XMLHttpRequest 1.前置知识 xhr.readyState 的情况 状态码 含义 0 （未初始化），还没有调用send() 方法 1 （载入）已调用send()方法，正在发送请求 2 （载入完成）send() 方法已经执行完成，接收到全部响应内容 3 （交互）正在解析响应内容 4 （完成）响应内容解析完成，可以在客户端调用 xhr.status 状态码 含义 2xx 请求处理成功（200） 3xx 重定向，浏览器直接跳转，301永久，302暂时跳一次，304资源未改变 4xx 客户端请求错误 404请求地址错误，403客户端没有权限 5xx 服务器端错误 2.请求 get，post，send 123456789101112131415161718// get 请求const xhr = new XMLHttpRequest()// 方法，地址，true表示异步请求（false表示同步请求）xhr.open(&#x27;GET&#x27;,&#x27;/data/test.json&#x27;,true)xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; // console.log( // JSON.parse(xhr.responseText) // ); alert(xhr.responseText) &#125;else&#123; console.log(&#x27;情况有误&#x27;); &#125; &#125;&#125;// 不需要sendxhr.send(null) 1234567891011121314151617181920// post 请求xhr.open(&#x27;POST&#x27;,&#x27;/login&#x27;,true)xhr.onreadystatechange = function()&#123;// 记得要判断状态 if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; console.log( JSON.parse(xhr.responseText) ); &#125;else&#123; console.log(&#x27;情况有误&#x27;); &#125; &#125;&#125;const postData = &#123; userName: &quot;xxx&quot;, password: &quot;xxx&quot;&#125;// 记得send的是字符串xhr.send(JSON.stringify(postData)) 同源策略，跨域 同源策略： ajax 请求时，浏览器要求当前网页和server必须同源（安全），针对的是浏览器环境 搜索引擎，爬虫等是从服务端发送的，一般来说不被同源策略限制 同源：协议、域名、端口，三者必须一致 eg 前端：http://a.com:8080/; server: https://b.com/api/xxx (协议域名端口都不同) 加载图片 css js 可无视同源策略 标签 作用 img 统计打点，可使用第三方统计服务 link，script 使用CDN（一般都是外域） script 实现JSONP 跨域 所有的跨域都必须经过 server 端允许和配合 未经 server 端允许就实现跨域，说明浏览器有漏洞 跨域的实现 JSONP 服务器可以任意动态拼接数据返回，只要符合 html /js 格式要求，并不一定是一个 html /js 文件 12345678910// 原理：利用 script 实现跨域，服务端动态拼接数据返回&lt;p&gt;一段文字&lt;/p&gt; &lt;script&gt; // callback 要挂在 window 上才可以全局调用 window.callback = function(data)&#123; console.log(data); &#125; &lt;/script&gt; // 下面的端口和我们本身的html端口不一样，所以用 script 访问 &lt;script src=&quot;http://localhost:8002/jsonp.js&quot;&gt;&lt;/script&gt; CORS 服务器设置 http header 1.2 问题 手写一个ajax 123456789101112131415161718192021222324252627282930// 手写 ajaxfunction ajax(url)&#123; const p = new Promise((resolve,reject)=&gt;&#123; const xhr = new XMLHttpRequest() xhr.open(&#x27;GET&#x27;,url,true) xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; resolve( JSON.parse(xhr.responseText) ) &#125; else if(xhr.status === 404)&#123; reject(new Error(&#x27;404 not found&#x27;)) &#125; &#125; &#125; xhr.send(null) &#125;) return p&#125;const url = &#x27;/data/test.json&#x27; // 正确的 url 和错误的 urlajax(url).then(res=&gt;&#123; console.log(res);&#125;).catch(err=&gt;&#123; console.error(err)&#125;) 跨域的实现方式 JSONP（理解原理） CORS 纯服务端 1.3 常用插件 jquery fetch axios 2.存储2.1 知识点 cookie 实际上用于 浏览器 和 server 之间通讯，但可以被借用到存储中 前端可以用 document.cookie = ‘’ 添加， 修改，获得，只要不删除存储的内容就一直在 缺点：最大存 4kb；http请求时需要发送到服务端，增加请求数据量；只能用 document.cookie 来修改，不好用 localStorge 和 sessionStorage HTML 专门为存储设计，最大可存 5M API 简易可用 setItem getItem 不会随着 http 发送出去 区别：localStorage 数据会永久存储，除非代码手动删除；sessionStorage 数据存在于当前会话，浏览器关闭就清空 localStorage 使用的比较多 2.2 问题 cookie localStorage sessionStorage 的区别 存储大小 API易用性 是否随http发送","categories":[],"tags":[{"name":"ajax 跨域 同源策略","slug":"ajax-跨域-同源策略","permalink":"http://example.com/tags/ajax-%E8%B7%A8%E5%9F%9F-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"}]},{"title":"JS面试篇-Part7","slug":"JS面试篇-Part7","date":"2021-12-10T01:17:09.000Z","updated":"2021-12-16T09:30:58.125Z","comments":true,"path":"2021/12/10/JS面试篇-Part7/","link":"","permalink":"http://example.com/2021/12/10/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part7/","excerpt":"1.与前面知识的联系与区别 JS基础知识，规定语法（ECMA 262 标准规定）","text":"1.与前面知识的联系与区别 JS基础知识，规定语法（ECMA 262 标准规定） 变量的类型和计算、原型和原型链、作用域和闭包等 JS Web API，网页操作的API （W3C 标准规定） DOM、BOM、事件绑定、ajax、存储 前者是后者的基础，两者结合才能实际应用 2.DOM（Document Object Model）操作知识点2.1 DOM本质 HTML是XML的一种，结构和标签都已经规定好了 DOM 本质是一棵树（和HTML是两个意思，HTML是一个文件，DOM是浏览器根据HTML文件初始化的一棵树） 2.2 DOM节点操作2.2.1 获取DOM节点1234 &lt;!-- CSS --&gt; .red &#123; color: red;&#125; 12345678910&lt;!-- HTML结构 --&gt;&lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt;&lt;/div&gt; &lt;p id=&quot;p1&quot;&gt;一段文字 1&lt;/p&gt; &lt;p&gt;一段文字 2&lt;/p&gt; &lt;p&gt;一段文字 3&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;container&quot;&gt; &lt;p&gt;图片&lt;/p&gt; &lt;img src=&quot;../image/xiaoxin.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 1234567891011121314151617181920// js// 1. 通过id来获取const div1 = document.getElementById(&#x27;div1&#x27;)console.log(&#x27;div1&#x27;,div1);// 2. 通过 tagName 获取const divList = document.getElementsByTagName(&#x27;div&#x27;)console.log(&#x27;divList length&#x27;,divList.length);console.log(&#x27;divList[0]&#x27;,divList[0]);// 3. 通过class获取const containerList = document.getElementsByClassName(&#x27;container&#x27;)console.log(&#x27;containerList length&#x27;,containerList.length);console.log(&#x27;containerList[0]&#x27;,containerList[0]);// 4. querySelectorconst pList = document.querySelectorAll(&#x27;p&#x27;)console.log(&#x27;pList&#x27;,pList); 2.2.2 修改节点属性 attribute 和 property attribute 修改html属性，会改变HTML（DOM树）结构 123// attribute 可以作用到DOM结构里面p1.setAttribute(&#x27;style&#x27;,&#x27;font-size: 50px&#x27;) // p1 的标签中会添加上修改后的样式console.log(p1.getAttribute(&#x27;style&#x27;)); property 修改对象属性，不会体现到HTML结构中 1234567891011const pList = document.querySelectorAll(&#x27;p&#x27;)const p1 = pList[0]// property 形式 改变页面样式或者渲染结构p1.style.width = &#x27;100px&#x27;console.log(p1.style.width);p1.className = &#x27;red&#x27;console.log(p1.className);// 获得nodeName（标签节点的名称）console.log(p1.nodeName);// 获得nodeType 一般是 1 不常用console.log(p1.nodeType); 二者都有可能引起DOM重新渲染，但是attribute一般来说都会，所以尽量用property操作js 2.2 DOM结构操作 新增/移动节点 12345678910// 1.增加节点const div1 = document.getElementById(&#x27;div1&#x27;)const newP = document.createElement(&#x27;p&#x27;)newP.innerHTML = &#x27;this is newP&#x27;div1.appendChild(newP)// 2. 移动节点 获取节点以后 用 appendChild 添加至想要移动到的区域const p1 = document.getElementById(&#x27;p1&#x27;)const div2 = document.getElementById(&#x27;div2&#x27;)div2.appendChild(p1) 获取子元素列表，获取父元素 12345678910111213141516171819// 3.获取父元素console.log(p1.parentNode);// 4. 获取子元素列表 全部获取 不只有 p 标签 还有 text 可以用nodeType 来区分，一般标签为 1，text 为 3const div1ChildNodes = div1.childNodesconsole.log(div1ChildNodes);// 按照一定规则找出想要的标签// Array.prototype.slice.call(div1ChildNodes) 把 div1ChildNodes 变成数组// filter 按照一定条件过滤const div1ChildNodesP = Array.prototype.slice.call(div1ChildNodes).filter(child=&gt;&#123; if(child.nodeType === 1)&#123; return true &#125; else&#123; return false &#125;&#125;)console.log(div1ChildNodesP ); 删除元素 12// 删除一个 p 标签div1.removeChild(div1ChildNodesP[0]) 2.3 DOM性能 DOM 操作非常昂贵，避免频繁的DOM操作 对DOM查询做缓存 12345678910// 不缓存 DOM 查询结果for(let i = 0;i&lt;document.getElementsByTagName(&#x27;p&#x27;).length;i++)&#123; // 每次循环都会计算length，频繁进行DOM查询&#125;// 缓存 DOM 查询结果let len = document.getElementsByTagName(&#x27;p&#x27;)for(let i = 0;i&lt;len; i++)&#123; // 缓存length 只会查询一次DOM&#125; 将频繁操作改为一次性操作 eg：给页面插入十个 li 标签，（提前在网页创建一个 id 为 list 的 div） 1234567// 频繁操作的情况 const list = document.getElementById(&#x27;list&#x27;)for(let i = 0;i&lt;10;i++)&#123; const li = document.createElement(&#x27;li&#x27;) li.innerHTML = `List item $&#123;i&#125;` list.appendChild(li)&#125; 1234567891011const list = document.getElementById(&#x27;list&#x27;)// 创建一个文档片段 此时还没有插入到 DOM 结构中const frag = document.createElement(&#x27;fragment&#x27;)for(let i = 0;i&lt;10;i++)&#123; const li = document.createElement(&#x27;li&#x27;) li.innerHTML = `List item $&#123;i&#125;` // 先把 li 插入到 文档片段中 frag.appendChild(li)&#125;// 最后一次性插入到 DOM 结构中list.appendChild(frag) 2.4 DOM相关问题 Q: DOM 是哪种数据结构？ ​ A: 树 Q: Property 和 attribute 的区别 A: property 修改对象属性，不会体现到HTML结构中，attribute 修改 HTML属性，会体现到HTML 结构中 ​ 二者都有可能引起DOM重渲染，但是 property 主要是在js中修改，性能更好更推荐 Q: DOM 性能 ​ A: 频繁操作和一次性操作 3.BOM（Browser Object Model）问题3.1 BOM知识点 navigator(识别浏览器的类型) 和 screen 1234567const ua = navigator.userAgent // navigator.userAgent 获得浏览器的信息，但判断不是很准确，确切的判断浏览器类型等需要具体策略const isChrome = ua.indexOf(&#x27;Chrome&#x27;)console.log(isChrome)// screenconsole.log(screen.height)console.log(screen.width) location (分别拆解 url 各个部分)和 history 12345678910console.log(location.href);console.log(location.protocol);console.log(location.host);console.log(location.search);console.log(location.hash);console.log(location.pathname);// historyhistory.backhistory.forward 4.事件4.0 知识点 事件绑定 事件冒泡 事件代理 4.1 事件绑定1234567891011// 事件绑定函数(不全面)const bindEvent = (elem, type, fn)=&gt;&#123; elem.addEventListener(type,fn)&#125;// egconst btn1 = document.getElementById(&#x27;btn1&#x27;)bindEvent(btn1,&#x27;click&#x27;,(e)=&gt;&#123; console.log(e.target); // 获取点击对象 e.preventDefault() // 阻止默认行为 alert(&#x27;点击成功&#x27;)&#125;) 4.2 事件冒泡 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个事件处理程序（同样的激活事件，比如说 click，激活之后要做什么要看具体的回调函数），如果是，则运行它 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达&lt;html&gt;元素。 12345678910&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt; &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt; &lt;/div&gt; 1234567891011121314const body = document.bodyconst p1 = document.getElementById(&#x27;p1&#x27;)// 1.阻止事件冒泡bindEvent(p1,&#x27;click&#x27;,e=&gt;&#123; e.stopPropagation() // 阻止事件冒泡 console.log(e.target); console.log(&#x27;激活&#x27;);&#125;)// 2.利用事件冒泡机制，多个p标签都实现取消功能，那么给它们的共同祖先绑定可以一次性实现对应功能bindEvent(body,&#x27;click&#x27;,e=&gt;&#123; console.log(e.target); console.log(&#x27;取消&#x27;);&#125;) 4.3 事件代理 代码简洁，减少浏览器内存占用 不能滥用，有一定复杂度，一般用在瀑布流上 1234567&lt;div id=&quot;div3&quot;&gt; &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;&lt;br&gt; &lt;button&gt;点击加载更多...&lt;/button&gt; &lt;/div&gt; 123456789// 事件代理const div3 = document.getElementById(&#x27;div3&#x27;)bindEvent(div3,&#x27;click&#x27;,e=&gt;&#123; e.stopPropagation() // 阻止默认事件：点击 a标签 跳转到链接 const target = e.target if(target.nodeName === &#x27;A&#x27;)&#123; // 如果点击了 a标签，进行相应的逻辑，所以需要判断 alert(target.innerHTML); &#125;&#125;) 4.4 相关题目 编写一个通用的事件监听函数 把 target 改成 this 12345678910111213141516171819202122function bindEvent (elem, type, selector,fn)&#123; // 只传入三个参数，说明没有选择器 if(fn == null)&#123; fn = selector selector = null &#125; // 这里用普通函数可以用this，用箭头函数的话，fn.call 会把 this 指向window // 如果用箭头函数，那么使用该函数时就不要用 this ，给谁绑就写谁的名字 elem.addEventListener(type,function(e)&#123; const target = e.target // 代理事件绑定 if(selector )&#123; if(target.matches(selector))&#123; fn.call(target,e) &#125; &#125; // 普通事件绑定 else&#123; fn.call(target,e) &#125; &#125;)&#125; 123456// egconst div3 = document.getElementById(&#x27;div3&#x27;)bindEvent(div3,&#x27;click&#x27;,&#x27;a&#x27;,function(e)&#123; e.stopPropagation() alert(this.innerHTML)&#125;) 使用箭头函数（虽然代码量比较少，但是调用的时候不那么优雅） 1234567891011// 通用的事件绑定函数function bindEvent (elem, type, selector,fn)&#123; // 只传入三个参数，说明没有选择器 if(fn == null)&#123; fn = selector selector = null &#125; elem.addEventListener(type,e=&gt;&#123; fn(e) &#125;)&#125; 123456const div3 = document.getElementById(&#x27;div3&#x27;)bindEvent(div3,&#x27;click&#x27;,&#x27;a&#x27;,e=&gt;&#123; e.stopPropagation() // 用 e.target 表示触发元素 alert(e.target.innerHTML)&#125;) 描述事件冒泡的流程 基于DOM树形结构 事件会顺着触发元素向上冒泡 应用场景：事件代理 无限下拉的图片列表，如何监听每个图片的点击？ 事件代理 用 e.target 获取触发元素 用 matches 来判断是否是触发元素","categories":[],"tags":[{"name":"JS Web API","slug":"JS-Web-API","permalink":"http://example.com/tags/JS-Web-API/"}]},{"title":"JS面试篇-Part6","slug":"JS面试篇-Part6","date":"2021-12-09T06:33:35.000Z","updated":"2021-12-16T09:29:31.133Z","comments":true,"path":"2021/12/09/JS面试篇-Part6/","link":"","permalink":"http://example.com/2021/12/09/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part6/","excerpt":"1.宏任务 macroTask 和 微任务 microTask 宏任务： setTimeout，setInterval，Ajax，DOM事件 微任务：Promise async/await","text":"1.宏任务 macroTask 和 微任务 microTask 宏任务： setTimeout，setInterval，Ajax，DOM事件 微任务：Promise async/await 12345678910console.log(100); // 1setTimeout(()=&gt;&#123; console.log(200);&#125;) // 4Promise.resolve().then(()=&gt;&#123; console.log(300); // 3&#125;)console.log(400); // 2 2. eventloop和DOM渲染 eventloop里面 call Stack 空的时候，DOM 开始渲染 微任务比宏任务执行时间要早，在DOM渲染前触发 宏任务在DOM渲染完成之后触发 代码示例：promise→DOM渲染→setTImeout 12345678910111213141516171819const $p1 = $(&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;)const $p2 = $(&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;)const $p3 = $(&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;)$(&#x27;#container&#x27;) .append($p1) .append($p2) .append($p3)Promise.resolve().then(()=&gt;&#123; console.log(&#x27;length1&#x27;, $(&#x27;#container&#x27;).children().length); alert(&#x27;Promise then&#x27;)&#125;) // DOM渲染前触发setTimeout(()=&gt;&#123; console.log(&#x27;length2&#x27;, $(&#x27;#container&#x27;).children().length); alert(&#x27;setTimeout&#x27;)&#125;) // DOM渲染后触发 3.微任务执行更早的原因 微任务是ES6语法规定的，不会经过Web APIs 宏任务是由浏览器规定的，按照eventloop常规流程（浏览器→call stack→WebAPIs（等待时机）→进入Callback QUeue→触发eventloop） 总的来说：1. Call Stack清空（同步代码都执行完） ​ 2.执行当前的微任务（micro task stack） ​ 3.尝试DOM渲染 ​ 4.触发eventloop（宏任务） 4.问题4.1 描述eventloop流程（可画图）A:回顾eventloop的过程即可，不需要一下子就把DOM渲染还有微任务宏任务这些一起说出来，容易乱 4.2 宏任务和微任务，二者区别A: 二者分类，区别就是执行时机，微任务在DOM渲染前，宏任务在DOM渲染后 4.3 promise的三种状态，变化A: pending resolved rejected；pending可以变成resolve也可以变成rejected，不可逆；resolve可以触发 then，reject可以触发 catch 4.4 promise场景题 part5 里的第 4点4.5 async/await场景题 执行async 返回的promise 不管里面是什么 执行 await 后面的相当于 then 123456789async function fn()&#123; return 100&#125; (async function ()&#123; const a = fn() // async 返回的是一个 promise 对象 const b = await fn() // await 相当于 then，可以拿到 return 的数据 console.log(a); // Promise &#123; 100 &#125; console.log(b); // 100 &#125;)() 1234567891011(async function()&#123; console.log(&#x27;start&#x27;); const a = await 100 // 相当于返回 100 console.log(&#x27;a&#x27;,a); const b = await Promise.resolve(200) console.log(&#x27;b&#x27;,b); const c = await Promise.reject(200) // await 相当于then 只会被resolve状态触发，所以rejected状态以后的所有代码都不会被执行 console.log(&#x27;c&#x27;,c); console.log(&#x27;end&#x27;);&#125;)()// 依次打印 start a 100 b 200 4.6 promise和setTimeout的顺序123456789101112console.log(100); // 1setTimeout(()=&gt;&#123; console.log(200);&#125;) // 4Promise.resolve().then(()=&gt;&#123; console.log(300); // 3&#125;)console.log(400); // 2// 依次打印 100 400 300 200 4.6 外加 async/await 的顺序问题12345678910111213141516171819202122232425262728293031323334// 先执行同步，call stack清空，执行微任务，DOM渲染，再执行宏任务async function async1()&#123; console.log(&#x27;async1 start&#x27;); // 2.立即执行async里的函数体 await async2() // 先执行 async2 再执行 await，await后面的都是异步回调 作为微任务 console.log(&#x27;async1 end&#x27;); // 6 执行微任务 打印async1 end（如果前面没有await 则也一样立即执行）&#125; async function async2()&#123; console.log(&#x27;async2&#x27;); // 3.立即执行 async里面的函数体&#125;console.log(&#x27;script start&#x27;); // 1.打印 script startsetTimeout(()=&gt;&#123; console.log(&#x27;setTimeout&#x27;);&#125;,0) // 8.宏任务 最后执行async1() // 顺序执行 async1 的函数体 执行到3 async1 里面的同步代码就执行完了 继续往下走new Promise(function(resolve)&#123; console.log(&#x27;promise1&#x27;); // 4.promise里面的function立即执行 resolve(); // 返回resolve状态 后面的then就是回调了 作为微任务&#125;).then(function()&#123; console.log(&#x27;promise2&#x27;); //7. 执行微任务 打印 promise2&#125;)console.log(&#x27;script end&#x27;); // 5. 到这里整个函数的同步任务就执行完了 开始执行微任务// script start// async1 start// async2// promise1// script end// async1 end// promise2// setTimeout 5.手写promise5.1要求 初始化，异步调用 1234567// 初始化const p = newMyPromise((resolve,reject)=&gt;&#123; // resolve(data) 同步调用 setTimeout(()=&gt;&#123; resolve(data) // 异步调用 &#125;)&#125;) ​ 2. then catch 链式调用 123456789101112131415161718p.then(data=&gt;&#123; return data + 1&#125;).then(data =&gt;&#123; return data + 2&#125;).catch(err =&gt;&#123; console.error(err)&#125;)// 拆开写，只是为了表述出 then catch 返回出的是一个新的promiseconst p11 = p.then(data =&gt;&#123; return data + 1&#125;)const p12 = p11.then(data =&gt;&#123; return data + 2&#125;)const p13 = p12.catch(err =&gt;&#123; console.error(err)&#125;) 支持常见API： .resolve .reject .all .race 1234const p2 = MyPromise.resolve(200)const p3 = MyPromise.reject(&#x27;错误信息...&#x27;)const p4 = MyPromise.all([p1,p2])const p5 = MyPromise.race([p1,p2]) 5.2 代码实现 （By双越老师）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/**/** * @description MyPromise * @author 双越 */ class MyPromise &#123; state = &#x27;pending&#x27; // 状态，&#x27;pending&#x27; &#x27;fulfilled&#x27; &#x27;rejected&#x27; value = undefined // 成功后的值 reason = undefined // 失败后的原因 resolveCallbacks = [] // pending 状态下，存储成功的回调 rejectCallbacks = [] // pending 状态下，存储失败的回调 constructor(fn) &#123; const resolveHandler = (value) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;fulfilled&#x27; this.value = value this.resolveCallbacks.forEach(fn =&gt; fn(this.value)) &#125; &#125; const rejectHandler = (reason) =&gt; &#123; if (this.state === &#x27;pending&#x27;) &#123; this.state = &#x27;rejected&#x27; this.reason = reason this.rejectCallbacks.forEach(fn =&gt; fn(this.reason)) &#125; &#125; try &#123; fn(resolveHandler, rejectHandler) &#125; catch (err) &#123; rejectHandler(err) &#125; &#125; then(fn1, fn2) &#123; fn1 = typeof fn1 === &#x27;function&#x27; ? fn1 : (v) =&gt; v fn2 = typeof fn2 === &#x27;function&#x27; ? fn2 : (e) =&gt; e if (this.state === &#x27;pending&#x27;) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; this.resolveCallbacks.push(() =&gt; &#123; try &#123; const newValue = fn1(this.value) resolve(newValue) &#125; catch (err) &#123; reject(err) &#125; &#125;) this.rejectCallbacks.push(() =&gt; &#123; try &#123; const newReason = fn2(this.reason) reject(newReason) &#125; catch (err) &#123; reject(err) &#125; &#125;) &#125;) return p1 &#125; if (this.state === &#x27;fulfilled&#x27;) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; try &#123; const newValue = fn1(this.value) resolve(newValue) &#125; catch (err) &#123; reject(err) &#125; &#125;) return p1 &#125; if (this.state === &#x27;rejected&#x27;) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; try &#123; const newReason = fn2(this.reason) reject(newReason) &#125; catch (err) &#123; reject(err) &#125; &#125;) return p1 &#125; &#125; // 就是 then 的一个语法糖，简单模式 catch(fn) &#123; return this.then(null, fn) &#125;&#125;MyPromise.resolve = function (value) &#123; return new MyPromise((resolve, reject) =&gt; resolve(value))&#125;MyPromise.reject = function (reason) &#123; return new MyPromise((resolve, reject) =&gt; reject(reason))&#125;MyPromise.all = function (promiseList = []) &#123; const p1 = new MyPromise((resolve, reject) =&gt; &#123; const result = [] // 存储 promiseList 所有的结果 const length = promiseList.length let resolvedCount = 0 promiseList.forEach(p =&gt; &#123; p.then(data =&gt; &#123; result.push(data) // resolvedCount 必须在 then 里面做 ++ // 不能用 index resolvedCount++ if (resolvedCount === length) &#123; // 已经遍历到了最后一个 promise resolve(result) &#125; &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;) return p1&#125;MyPromise.race = function (promiseList = []) &#123; let resolved = false // 标记 const p1 = new Promise((resolve, reject) =&gt; &#123; promiseList.forEach(p =&gt; &#123; p.then(data =&gt; &#123; if (!resolved) &#123; resolve(data) resolved = true &#125; &#125;).catch((err) =&gt; &#123; reject(err) &#125;) &#125;) &#125;) return p1&#125;","categories":[],"tags":[{"name":"微任务 宏任务 eventloop和dom渲染 手写promise","slug":"微任务-宏任务-eventloop和dom渲染-手写promise","permalink":"http://example.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E5%AE%8F%E4%BB%BB%E5%8A%A1-eventloop%E5%92%8Cdom%E6%B8%B2%E6%9F%93-%E6%89%8B%E5%86%99promise/"}]},{"title":"JS面试篇-Part5","slug":"JS面试篇-Part5","date":"2021-12-04T12:21:45.000Z","updated":"2021-12-16T09:28:39.767Z","comments":true,"path":"2021/12/04/JS面试篇-Part5/","link":"","permalink":"http://example.com/2021/12/04/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part5/","excerpt":"1.event loop(事件循环/事件轮询)","text":"1.event loop(事件循环/事件轮询) JS是单线程运行的 从前到后逐行执行；某一行报错则停止，不执行后面的代码；先执行同步再执行异步 异步要基于回调来实现 event loop 就是异步回调的实现原理 演示代码如下 ```jsconsole.log(‘Hi’);setTimeout(function cb1() { console.log(&#39;callback&#39;); }, 1000);console.log(‘Bye’); 12345678910111213141516171819202122232425262728- 解释如下： 1. 同步代码，一行一行放在 Call Stack 里面执行 2. 遇到异步，先记录下来，等待时机到达（定时，网络请求等） 3. 时机到了，就移动到 Call Queue 里面 4. 如果 Call Stack 为空（即同步代码执行完），Event Loop 开始工作 5. 轮询查找 Callback Queue,如有则移动到 Call Stack 执行 6. 然后继续轮询查找#### 2.DOM事件和Event Loop- JS是单线程的- 异步（setTimeout，ajax）使用回调，基于event loop- DOM事件也使用回调，基于event loop （DOM事件不是异步）```js &lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;script&gt; let btn = document.querySelector(&#x27;button&#x27;) console.log(&#x27;HI&#x27;); btn.addEventListener(&#x27;click&#x27;,function(e)&#123; console.log(&#x27;button clicked&#x27;); &#125;) console.log(&#x27;Bye&#x27;); &lt;/script&gt; 同步代码立即执行，btn.addEventListener也是立即执行，但是里面的回调函数先进去Call Stack 等待，点击以后进入Web APIs 再进入 Callback Queue 给event loop 执行 3.Promise深入 三种状态 pending、resolved、rejected 12345678910111213141516171819202122232425// 三种状态const p1 = new Promise((resolve,reject)=&gt;&#123;&#125;)console.log(&#x27;p1&#x27;,p1); // p1 Promise &#123; &lt;pending&gt; &#125;const p2 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve() &#125;)&#125;)console.log(&#x27;p2&#x27;,p2); // pendingsetTimeout(()=&gt;&#123; console.log(&#x27;p2-setTimeOut&#x27;,p2); // resolved （fulfilled）&#125;)const p3 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject() &#125;)&#125;)console.log(&#x27;p3&#x27;,p3); // pendingsetTimeout(()=&gt;&#123; console.log(&#x27;p3-setTimeout&#x27;,p3); // rejected&#125;) 状态的表现和变化 pending状态，不会触发 then 和 catch resolved 状态，会触发 then 回调函数 rejected 状态，会触发 catch 回调函数 1234567891011121314 // 状态转换 不会触发什么 会触发什么const p1 = Promise.resolve(100) // 单独用的时候，promise 不用 newp1.then((data)=&gt;&#123; console.log(&#x27;data1&#x27;,data);&#125;).catch(err=&gt;&#123; console.error(&#x27;err1&#x27;,err)&#125;) // resolve 只会执行 then 结果 data1 100const p2 = Promise.reject(&#x27;err&#x27;)p2.then(data=&gt;&#123; console.log(&#x27;data2&#x27;,data);&#125;).catch(err=&gt;&#123; console.log(&#x27;err2&#x27;,err);&#125;) // reject 只会执行 catch 结果 err2 err then 和 catch 对状态的影响 then 正常返回 resolved ， 里面有报错则返回 rejected （完整来说eg：then正常返回一个 resolved 状态的 promise） 12345678910111213141516171819202122const p1 = Promise.resolve().then(()=&gt;&#123; return 100 // then 正常执行&#125;)console.log(&#x27;p1&#x27;,p1); // 一开始是pending 执行后是 resolvedconst p2 = Promise.resolve().then(()=&gt;&#123; throw new Error([&#x27;then error&#x27;]) // then 里面有报错 返回 rejected&#125;)console.log(&#x27;p2&#x27;,p2); // 一开始是pending 执行后是 rejected// 执行p1.then(data=&gt;&#123; console.log(data); // 因为 p1 = 返回了一个resolved状态的promise 所以可以执行 then&#125;).catch(err=&gt;&#123; console.error(&#x27;err1&#x27;,err); // catch 不会被执行&#125;)p2.then(data=&gt;&#123; console.log(data);&#125;).catch(err=&gt;&#123; console.error(&#x27;err2&#x27;,err) // p2 = 返回了一个rejected 状态的 promise 执行catch // 打印 err2 Error: then error（p2 throw 出来的错误）&#125;) catch 正常返回 resolved，里面有报错则返回 rejected 123456789101112const p3 = Promise.reject(&#x27;my error&#x27;).catch(err=&gt;&#123; console.error(&#x27;err&#x27;,err)&#125;)console.log(&#x27;p3&#x27;,p3); // reject 是正常执行了的 所以 promise 的状态是 resolved（fulfilled）p3.then(()=&gt;&#123; console.log(&#x27;100&#x27;); // 可以打印出来 100&#125;)const p4 = Promise.reject(&#x27;my error&#x27;).catch(err=&gt;&#123; throw new Error(&#x27;catch error&#x27;)&#125;)console.log(&#x27;p4&#x27;,p4); // reject 的 catch 报错，返回一个 rejected 的 promise 4.Promise 的状态相关问题 第一题 123456789Promise.resolve().then(()=&gt;&#123; console.log(1); // resolve 状态 可以执行then then没有报错，返回 resolve状态的promise&#125;).catch(()=&gt;&#123; console.log(2);&#125;).then(()=&gt;&#123; console.log(3); // 所以上一个then返回的promise执行下一个then的回调，不会执行catch&#125;) // 最后返回一个 resolve 状态的promise// 打印 1 3 第二题 12345678910Promise.resolve().then(()=&gt;&#123; // resolve 执行 then console.log(1); throw new Error(&#x27;erro1&#x27;) // 报错 返回reject&#125;).catch(()=&gt;&#123; console.log(2); // 执行 catch成功 返回 resolve&#125;).then(()=&gt;&#123; console.log(3); // 所以会执行 then&#125;)// 打印 1 2 3 第三题 12345678910Promise.resolve().then(()=&gt;&#123; // resolve 执行 then console.log(1); throw new Error(&#x27;error1&#x27;) // 报错 返回 reject 执行 catch&#125;).catch(()=&gt;&#123; console.log(2); // 成功执行 返回resolve &#125;).catch(()=&gt;&#123; console.log(3); // 在resolve状态下 不能被执行&#125;)// 打印 1 2 5.async/await 异步回调 callback hell Promise then catch 链式调用，但也基于回调函数 async/await 是同步语法，彻底消灭回调函数 12345678910111213141516171819202122232425262728function loadImg(src) &#123; const res = new Promise((resolve,reject) =&gt; &#123; const img = document.createElement(&#x27;img&#x27;) img.onload = () =&gt;&#123; resolve(img) &#125; img.onerror = ()=&gt;&#123; const err = new Error(`图片加载失败$&#123;src&#125;`) reject(err) &#125; img.src = src &#125;) return res&#125; const url1 = &#x27;/image/xiaoxin.jpg&#x27; const url2 = &#x27;/image/scene.jpg&#x27; // 这里加 ！ 是为了避免上面的语句没有打分号 使得函数不能正确识别 // 和之前插入图片的代码作比较 可以发现简洁了很多!(async function () &#123; const img1 = await loadImg(url1) console.log(img1.height,img1.width); const img2 = await loadImg(url2) console.log(img2.height,img2.width); &#125;)() async/await 和 Promise 相关的关系 执行 async 函数，返回的是 Promise 对象 1234567async function fn1()&#123; return 100 // async 返回的是 Promise 函数&#125;console.log(&#x27;fn1:&#x27;,fn1()); // Promise &#123; 100 &#125; fn1().then((data)=&gt;&#123; console.log(data); // 100 &#125;) await 相当于 Promise 的 then 1234567// 1.await 相当于 then!(async function () &#123; // 立即执行匿名函数 const p1 = Promise.resolve(300) const data1 = await p1 // await 相当于 promise then ，直接拿到 return 的数据 console.log(data1); // 300&#125;)() 123456// 2.如果 await 后面跟的不是 promise 的值 相当于封装成 一个 promise!(async function () &#123; const data2 = await 400 // await Promise.resolve(400) console.log(data2); // 400&#125;)() 12345// 3. await 后面接一个返回promise对象的函数!(async function () &#123; const data3 = await fn1() console.log(data3); // 100&#125;)() try…catch 可以捕获异常，代替了 Promise 的 catch 12345678910//1.try...catch举例!(async function()&#123; const p4 = Promise.reject(&#x27;err&#x27;) try&#123; const res = await p4 console.log(&#x27;res&#x27;,res); &#125;catch(ex)&#123; console.error(&#x27;ex&#x27;,ex) // ex err &#125;&#125;)() 123456// 2.await 的一种冲突，用try...catch来解决!(async function()&#123; const p5 = Promise.reject(&#x27;err&#x27;) const res = await p5 // 因为 await 相当于 then 所以 rejected状态的promise走不到这一步 console.log(res);&#125;) 6. 异步的本质是回调 async-await 是语法糖，只是语法层面上像同步，但是很好用 代码示例 1234567891011121314151617181920212223// async 里面的函数体（除了await）都是立即执行的async function async1() &#123; console.log(&#x27;async1 start&#x27;); //2. await async2() // 先执行async函数体内容 然后执行await // 因为 async相当于返回 undefined 所以 await后面没有promise // 但是 await 后面的语句都可以当做是异步 所以要最后执行 // 最后一句类似于setTimeout(()=&gt;&#123; console.log(&#x27;async1 end&#x27;);&#125;) // (当然只是举例，也有可能是promise.then()) console.log(&#x27;async1 end&#x27;); //5.&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);//3. &#125;console.log(&#x27;script start&#x27;); //1.async1()console.log(&#x27;script end&#x27;);//4.// script start//async1 start//async2//script end//async1 end 1234567891011121314151617181920212223242526async function async1() &#123; console.log(&#x27;async1 start&#x27;); await async2() // 下面三句都是异步回调 console.log(&#x27;async1 end&#x27;); await async3() // 下面一行是异步回调 console.log(&#x27;async1 end2&#x27;);&#125;async function async2() &#123; console.log(&#x27;async2&#x27;); &#125;async function async3() &#123; console.log(&#x27;async3&#x27;);&#125;console.log(&#x27;script start&#x27;); async1()console.log(&#x27;script end&#x27;); // async1 start// async2// script end// async1 end// async3// async1 end2 7.for…of for … in (以及 forEach for) 是常规的同步遍历 for … of 常用于 异步的遍历（需要熟练掌握） 1234567891011121314151617181920212223242526function multi(num)&#123; return new Promise( resolve=&gt;&#123; setTimeout(()=&gt;&#123; resolve(num*num) &#125;,1000) &#125; )&#125;const nums = [1,2,3]// 1s 间隔后立即打印出 res 的三个结果 1 4 9nums.forEach( async(i)=&gt;&#123; const res = await multi(i) console.log(res); &#125; ) // 如果要按照 1s 间隔逐个打印出来 for...of 用在异步当中!(async function()&#123; for(let i of nums)&#123; const res = await multi(i) console.log(res); &#125;&#125;)()","categories":[],"tags":[{"name":"EventLoop Promise async await for...of","slug":"EventLoop-Promise-async-await-for-of","permalink":"http://example.com/tags/EventLoop-Promise-async-await-for-of/"}]},{"title":"JS面试篇-Part4","slug":"JS面试篇-Part4","date":"2021-12-04T09:28:51.000Z","updated":"2021-12-16T09:27:30.512Z","comments":true,"path":"2021/12/04/JS面试篇-Part4/","link":"","permalink":"http://example.com/2021/12/04/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part4/","excerpt":"1.单线程和异步","text":"1.单线程和异步 1.1 单线程 JS是单线程语言，同一时间只能做一件事，会阻塞代码执行 因为JS可以修改DOM结构，所以JS和DOM渲染共用一个线程 浏览器和nodejs已经支持JS启动进程，如Web Worker 1.2 为什么要异步 遇到等待（网络请求，定时任务） 不能卡住 基于callback来实现，不会阻塞代码执行 2.应用场景 定时任务 如 setTImeout ```js// setTimeoutconsole.log(100);setTimeout(function() {console.log(200); },1000)console.log(300);12345678- ```js // setInterval 循环执行 每隔 interval 执行一次 console.log(100); setInterval(() =&gt; &#123; console.log(200); &#125;, 1000); console.log(300); 网络请求 如 ajax图片加载 ```js// ajax 图片加载console.log(“start”);let img = document.createElement(‘img’)img.onload = function (){console.log(&#39;loaded&#39;); }img.src = ‘/xxx.png’console.log(“end”);1234567891011121314151617 #### 3.callback hell 和 Promise- callback hell - ```js $.get(url1,(data1)=&gt;&#123; console.log(data1); $.get(url2,(data2)=&gt;&#123; console.log(data2); $.get(url3,(data3)=&gt;&#123; console.log(data3); &#125;) &#125;) &#125;) Promise ```jsfunction getData(url ) {return new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url, success(data)&#123; resolve(data) &#125;, error(err)&#123; reject(err) &#125; &#125;) &#125;)&#125; //使用 const url1 = ‘/data1.json’const url2 = ‘/data2.json’const url3 = ‘/data3.json’getData(url1).then(data1=&gt;{console.log(data1); return getData(url2) }).then(data2=&gt;{console.log(data2); return getData(url3) }).then(data3=&gt;{console.log(data3); }).catch(err =&gt; console.error(err))1234567891011121314151617181920212223242526272829303132333435363738394041424344 #### 问题- 同步和异步的区别是什么​ 如上- 手写promise加载一张图片 ```jsconst url = &#x27;/image/xiaoxin.jpg&#x27; // new Promise格式分析 function loadImg(src) &#123; // 首先 return new Promise 也就是 Promise的一个实例 // 给这个实例传入的参数是函数（用箭头函数的形式&lt;包括两个参数，一个resolve 一个 reject，这两个参数也是函数） const res = new Promise( (resolve,reject) =&gt; &#123; const img = document.createElement(&#x27;img&#x27;) // img 加载完成以后执行 resolve函数 img.onload = () =&gt;&#123; resolve(img) &#125; img.onerror = ()=&gt;&#123; const err = new Error(`图片加载失败$&#123;src&#125;`) reject(err) &#125; img.src = src &#125;) return res &#125;loadImg(url).then(img=&gt;&#123; console.log(img.width); // return 的 数据给下一个 .then 用 return img&#125;).then(img=&gt;&#123; console.log(img.height);&#125;).catch(ex =&gt;&#123; console.error(ex)&#125;) 加载多张图片 12345678910111213141516// 加上面的代码 const url2 = &#x27;/image/scene.jpg&#x27;loadImg(url1).then(img1=&gt;&#123; console.log(img1.width); return img1 // 返回普通对象 &#125;).then(img1=&gt;&#123; console.log(img1.height); return loadImg(url2) // 返回 promise 实例 &#125;).then(img2=&gt;&#123; console.log(img2.width); return img2 &#125;).then( img2=&gt;&#123; console.log(img2.height); &#125;).catch(err=&gt;&#123; console.error(err) &#125;) 前端使用异步的应用场景 ​ 各种等待的场景 setTimeout 笔试题 console.log(1); setTimeout(() =&gt; &#123; console.log(2); &#125;, 1000); setTimeout(() =&gt; &#123; console.log(3); &#125;, 0); console.log(4); // 1 4 3 2","categories":[],"tags":[{"name":"同步 异步","slug":"同步-异步","permalink":"http://example.com/tags/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/"}]},{"title":"java读取文件的六种方式","slug":"java读取文件的六种方式","date":"2021-12-03T07:58:57.000Z","updated":"2021-12-17T15:12:38.771Z","comments":true,"path":"2021/12/03/java读取文件的六种方式/","link":"","permalink":"http://example.com/2021/12/03/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"我们 java 老师很喜欢让我们自学，说程序在课堂上是学不会的，所以他要多布置作业督促我们。 这次作业是分析他之前项目的一个天体测量文件，所以我顺便记录一下在 java 里读取文件的几种方式","text":"我们 java 老师很喜欢让我们自学，说程序在课堂上是学不会的，所以他要多布置作业督促我们。 这次作业是分析他之前项目的一个天体测量文件，所以我顺便记录一下在 java 里读取文件的几种方式 1.Scanner + new File12345678910111213141516171819202122232425262728293031package readFile_learning;import java.io.FileReader;import java.io.IOException;import java.util.Scanner;//Scanner + new File 既可以按行读取 也可以按分隔符获取public class methods_1 &#123; public static void main(String[] args) throws IOException&#123; // TODO Auto-generated method stub// String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; String fileName = &quot;D:\\\\javaTest\\\\test1.txt&quot;;// 按行读取 try(Scanner sc = new Scanner(new FileReader(fileName)))&#123; while(sc.hasNextLine()) &#123; String line = sc.nextLine(); System.out.println(line); &#125; &#125;// 按分隔符读取 try(Scanner sc = new Scanner(new FileReader(fileName)))&#123; sc.useDelimiter(&quot;\\\\!!!&quot;); while(sc.hasNext()) &#123; String str = sc.next(); System.out.println(str); &#125; &#125; catch (Exception e) &#123; System.out.println(&quot;文件读取错误!&quot;); &#125; &#125;&#125; 2.Stream流123456789101112131415161718192021222324252627282930313233343536package readFile_learning;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class methods_2 &#123;//按行读取 推荐 public static void main(String[] args) throws IOException&#123; // TODO Auto-generated method stub String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;;// 读取文件内容到Stream流中，按行读取,不用一次性把文件加载到内存中 每一行都存在Stream流中 @SuppressWarnings(&quot;resource&quot;) Stream&lt;String&gt; lines = Files.lines(Paths.get(fileName));// 随机按行处理 就去掉Ordered// lines.forEachOrdered(ele -&gt;&#123;;// System.out.println(ele);// &#125;);// 按文件顺序处理// lines.forEachOrdered(System.out::println); 不知道为什么跑出不来 代码是对的// 其它要求// 并行流 利用cpu加快行处理速度 lines.parallel().forEachOrdered(ele -&gt;&#123;; System.out.println(ele); &#125;);// 转换为 List对象 不适合文件大的情况 List&lt;String&gt; collect = lines.collect(Collectors.toList()); &#125;&#125; 3.List String1234567891011121314151617181920package readFile_learning; import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.List;public class methods_3 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub//直接转换为List String 一次性把文件加到lines里 适合文件不是很大 需要对文件按行处理时 String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; List&lt;String&gt; lines = Files.readAllLines(Paths.get(fileName)); lines.forEach(System.out::println); &#125;&#125; Files.readString(Paths.get(fileName)) 12345678910111213141516171819package readFile_learning;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;public class methods_4 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub// java 11 支持的方式 读取文件不超过2G 不是按行读取 一次性读取出来 String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; String s = Files.readString(Paths.get(fileName)); System.out.println(s); &#125;&#125; 5.非JDK11 一次性读取文件的办法1234567891011121314151617181920package readFile_learning;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;public class methods_5 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;;// 不是JDK11 但是要一次性读取全部文件 byte[] bytes = Files.readAllBytes(Paths.get(fileName)); String content = new String(bytes,StandardCharsets.UTF_8); System.out.println(content); &#125;&#125; 6.管道流12345678910111213141516171819202122package readFile_learning;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class methods_6 &#123;//管道流 适合读取文件内存比较大的 public static void main(String[] args) throws FileNotFoundException, IOException &#123; // TODO Auto-generated method stub String fileName = &quot;D:\\\\javaTest\\\\N1601335746_1_gaia1.QMPF&quot;; try(BufferedReader br = new BufferedReader(new FileReader(fileName)))&#123; String line; while((line = br.readLine())!=null) &#123; System.out.println(line); &#125; &#125; &#125;&#125; 之前我们还写 JavaMail 来着，一开始我看到都两眼一蒙不知道是什么，后来自己去搜索自学，发现还是挺简单的。感谢互联网","categories":[],"tags":[{"name":"java读取文件","slug":"java读取文件","permalink":"http://example.com/tags/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/"}]},{"title":"JS面试篇-Part3","slug":"JS面试篇-Part3","date":"2021-11-30T12:32:38.000Z","updated":"2021-12-16T09:26:58.958Z","comments":true,"path":"2021/11/30/JS面试篇-Part3/","link":"","permalink":"http://example.com/2021/11/30/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part3/","excerpt":"1.作用域","text":"1.作用域 全局作用域 函数作用域 块级作用域 ```js// 在 if for while 这些语句的作用域叫块级作用域if(true){let x = 100 }console.log(x) // 报错1234567891011121314151617181920- 代码演示```jsfunction fn1()&#123; let a = 100 fn2() function fn2()&#123; let a1 = 200 function fn3()&#123; let a2 = 300 return a + a1 + a2 &#125; return fn3() &#125; return fn2()&#125;console.log(fn1()) 2.自由变量 在本级作用域使用但是没有定义的变量 一级一级向上找，直到找到为止 如果找不到则报错 xx is not defined 3.闭包 闭包：（所有的）自由变量查找，是在函数定义的地方向上查找，不是在函数执行的地方！！！ 作用域应用的特殊情况有以下两种 函数作为返回值 123456789101112131415// 函数作为返回值function create()&#123; const a = 100 return function ()&#123; console.log(a) &#125;&#125;// 因为返回的是一个函数 如果要执行这个返回的函数 需要拿一个函数接着const createExecu = create()createExecu() // 100const a = 200createExecu() // 100let b = 200createExecu(b) // 100 函数作为参数 123456789function print(fn)&#123; const a = 200 fn()&#125;const a = 100function fn()&#123; console.log(a);&#125;print(fn) // 100 4.thisthis 在函数执行的时候才确定值，不是在函数定义的时候确认的 4.1调用场景 作为普通函数 返回window 使用 call apply bind ```jsfunction fn1(){console.log(this); }fn1() // window// call 和 bind 可以改变函数 this 的指向 但是用法有所不同fn1.call( {x:100} ) // { x: 100 }// bind 返回一个新的函数执行const fn2 = fn1.bind( {x:200} )fn2() // { x: 200 }1234567891011121314151617- 作为对象方法被调用 setTImeout里面用普通函数，this 指向 window - ```js const zhangsan = &#123; name: &quot;张三&quot;, sayHi()&#123; console.log(this); &#125;, wait()&#123; setTimeout(function()&#123; console.log(this); &#125;) &#125; &#125; zhangsan.sayHi() // 当前对象 也就是 zhangsan 这个对象 zhangsan.wait() // setTimeout 里面的普通函数 this 指向 window 箭头函数 setTimeout里是箭头函数 指向上一级this ```jsconst zhangsan = { waitAgain()&#123; setTimeout(()=&gt;&#123; console.log(this); &#125;) &#125; } zhangsan.waitAgain() // 当前对象 也就是 zhangsan 这个对象123456789101112131415- class方法中调用```jsclass People&#123; constructor(name,number)&#123; this.name = name this.number = number &#125; sayHi()&#123; console.log(this) &#125;&#125;const zhangsan = new People(&#x27;张三&#x27;,40)zhangsan.sayHi() // this 指向 zhangsan 5.题目5.1.this的不同应用场景4.1就是答案 情况很多，需要重复记忆 5.2.手写bind函数bind 传入一个this 返回一个函数 注释分析版 123456789101112131415161718192021222324252627282930313233function fn1(a,b,c)&#123; console.log(&quot;this&quot;,this); // 单纯的this 就是window console.log( a,b,c) return &quot;this is fn1&quot;&#125; // const fn2 = fn1.bind(&#123;x:100&#125;,1,2,3) //bind改变函数this的指向// fn2() //this &#123; x: 100 &#125;// 原型链分析// let flag = fn1.hasOwnProperty(&quot;bind&quot;)// console.log(flag) // false// flag = fn1.__proto__===Function.prototype?true:false // true// console.log(flag); Function.prototype.bind1 = function() &#123; // 先把传进来的参数列表变成数组 arguments 可以获得所用的参数 const args = Array.prototype.slice.call(arguments) // 用shift 获取 args 的第一项也就是传进来的this（shift会改变原数组） const t = args.shift() // 原本的this 也就是 fn1 拿出来 const self = this // 返回一个函数（实现bind的功能） return function () &#123; // apply 第一个参数是 this 第二个参数是 参数数组 return self.apply(t,args) &#125; &#125;const fn3 = fn1.bind1(&#123;x:100&#125;,1,2,3) //bind1改变函数this的指向fn3() //this &#123; x: 100 &#125; 答案版 12345678Function.prototype.bind1 = function() &#123; const args = Array.prototype.slice.call(arguments) const t = args.shift() const self = this return function () &#123; return self.apply(t,args) &#125; &#125; 还有手写 call apply 等 5.3.实际开发中闭包的应用场景，举例说明 隐藏数据 不让外部改变 做一个简单的 cache 工具 1234567891011121314151617function createCache() &#123; let data = &#123;&#125; return &#123; // set: function(key,value)&#123;&#125; 格式也是对的 set(key,value)&#123; data[key] = value &#125;, get(key)&#123; return data[key] &#125; &#125; &#125;const fn1 = createCache()fn1.set(&quot;age&quot;,18)console.log(fn1.get(&quot;age&quot;)); 5.4 创建10个 a 标签点击的时候弹出相应的序号12345678910111213// 创建10个 a 标签，点击弹出相应索引 // 考点在于 如果 i 在 外部声明而不是for循环里面声明 那么最后i的值就一直是 10 // 因为遍历创建 a 标签的速度很快 i又是全局变量 所以一下就加完了，但是事件不是同步任务，需要点击才能触发，所以当我们点击 a 标签的时候，i 已经变成 10 了 只有把 i 放到块级作用域里，才能和alert事件同步。因为每遍历一次，i会开辟一个新的作用域，在alert的时候，就在对应作用域里找 i 是多少 let a for(let i = 0;i&lt;10;i++)&#123; a = document.createElement(&#x27;a&#x27;) a.innerHTML = i + &#x27;&lt;br&gt;&#x27; a.addEventListener(&#x27;click&#x27;,function(e)&#123; e.preventDefault() alert(i) &#125;) document.body.appendChild(a) &#125;","categories":[],"tags":[{"name":"作用域 闭包 this 手写bind","slug":"作用域-闭包-this-手写bind","permalink":"http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-this-%E6%89%8B%E5%86%99bind/"}]},{"title":"JS面试篇-Part2","slug":"JS面试篇-Part2","date":"2021-11-29T12:40:28.000Z","updated":"2021-12-16T09:26:09.026Z","comments":true,"path":"2021/11/29/JS面试篇-Part2/","link":"","permalink":"http://example.com/2021/11/29/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part2/","excerpt":"JS 本身是基于原型链的语言","text":"JS 本身是基于原型链的语言 1.class constructor 属性 方法 1234567891011121314151617181920212223242526class Student &#123; // constructor constructor(name, number)&#123; // this 当前的类 this.name = name this.number = number // 属性也可以自定义，不需要传 this.school = &#x27;阳光小学&#x27; &#125; // 定义方法 sayHi()&#123; console.log( `姓名： $&#123;this.name&#125; 学号: $&#123;this.number&#125; 学校: $&#123;this.school&#125; ` ); &#125;&#125;// 通过类 new 对象/实例 也就是说用 new 关键字把这个模板赋给我们需要的变量let stu1 = new Student(&#x27;moon&#x27;,&#x27;1234&#x27;)let stu2 = new Student(&#x27;sun&#x27;, &#x27;67890&#x27;)console.log(stu1.number);console.log(stu2.name);stu1.sayHi(); 2.继承 某些类有相同的属性和方法时，可以抽象出来归为一个父类共同继承 extends super 扩展或重写方法 123456789101112131415161718192021222324252627282930313233343536373839404142// 父类class People&#123; constructor(name,favorite)&#123; this.name = name this.favorite = favorite &#125; eat()&#123; console.log(`$&#123;this.name&#125; likes to eat $&#123;this.favorite&#125;`); &#125;&#125;// 子类1// extends 关键字 表示继承于class Student extends People&#123; constructor(name,favorite,number)&#123; // super 关键字 把这些属性给父类处理 super(name, favorite) this.number = number this.school = &quot;School_A&quot; &#125; sayHi()&#123; console.log( `姓名 $&#123;this.name&#125; 学号 $&#123;this.number&#125;`) &#125;&#125;// 子类2class Teacher extends People&#123; constructor(name,favorite,major)&#123; super(name,favorite) this.major = major &#125; teach()&#123; console.log( ` $&#123;this.name&#125; 教授 $&#123;this.major&#125;`) &#125;&#125;// 实例let stu = new Student(&#x27;sam&#x27;,&#x27;banana&#x27;,&#x27;123456&#x27;)let teacher = new Teacher(&#x27;Miss Wang&#x27;,&#x27;grape&#x27;,&#x27;JavaScript&#x27;) stu.sayHi()stu.eat()teacher.teach()teacher.eat() 3.类型判断 instanceof1234567891011function log(x)&#123; console.log(x)&#125;// 判断这个变量是不是这个类构建出来的 log(stu instanceof People ) //true log(stu instanceof Student) //true log(stu instanceof Object) //true log(stu instanceof Teacher) //false log([] instanceof Array) //true log([] instanceof Object) //true log(&#123;&#125; instanceof Object) //true 4.原型以及原型链12345log(stu.__proto__) //People &#123;&#125;log(Student.prototype) //People &#123;&#125;log(stu.__proto__ === Student.prototype) // truelog (stu.__proto__.sayHi()) // undefinedlog (stu.__proto__.name) //undefined 因为相当于 stu.__proto__ 作为this了，这个this上没有name没有number 4.1原型关系 每个class都有显式原型（prototype） 每个实例都有隐式原型 （proto) 实例的proto指向class的prototype 图解 自己本身声明的，叫prototype 自己从别人那继承来的属性和方法，叫__proto__ 自己所可以使用的全部方法和属性就是自己的 .prototype 属性 4.2 原型执行规则 获取实例的属性或者执行方法时，现在自身属性和方法中查找 找不到就去隐式原型中找 4.3 原型链12345log(Student.prototype.__proto__) //&#123;&#125;log(People.prototype) //&#123;&#125;log(Student.prototype.__proto__ === People.prototype) //true 图解 5.问题5.1 如何准确判断一个变量是不是数组？a instanceof Array 5.2 class的原型本质，如何理解？ 原型链的图 原型的执行规则 5.3 手写简易jquery，考虑插件和扩展性1234567891011121314151617181920212223242526class jQuery&#123; constructor(selector)&#123; const result = document.querySelectorAll(selector) const length = result.length for(let i = 0;i&lt;length;i++)&#123; this[i] = result[i] &#125; this.length = length this.selector = selector &#125; get(index)&#123; return this[index] &#125; // 方法遍历元素 each(fn)&#123; for(let i = 0;i&lt;this.length;i++)&#123; const elem = this[i] fn(elem) &#125; &#125; on(type,fn)&#123; return this.each(elem=&gt;&#123; elem.addEventListener(type,fn,false) &#125;) &#125;&#125;","categories":[],"tags":[{"name":"原型 原型链 class继承 instanceof","slug":"原型-原型链-class继承-instanceof","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-class%E7%BB%A7%E6%89%BF-instanceof/"}]},{"title":"JS面试篇-Part1","slug":"JS面试篇-Part1","date":"2021-11-28T08:35:03.000Z","updated":"2021-12-17T12:40:06.739Z","comments":true,"path":"2021/11/28/JS面试篇-Part1/","link":"","permalink":"http://example.com/2021/11/28/JS%E9%9D%A2%E8%AF%95%E7%AF%87-Part1/","excerpt":"1.值类型和引用类型以及区别","text":"1.值类型和引用类型以及区别 1.1 定义 值类型，value直接存储在栈中，值的地址互不干扰 12345let a = 100;let b = a;a = 200;console.log(a); //200console.log(b); //100 引用类型，元素指向地址，值存放在元素指向的地址中 1234let a = &#123; age: 20 &#125;;let b = a;b.age = 21;console.log(a.age); //21 a 和 b 指向的地址都是一样的，所以改了 b 后 a 也会改 引用类型比值类型占用的内存要大得多，如果直接复制值，资源浪费大，并且复制时间长。 1.2 常见值类型123456let a //undefinedconst a // 会报错,const 必须赋值const s = &#x27;abc&#x27;const n = 100const b = trueconst sym = Symbol(&#x27;s&#x27;) 1.3常见引用类型1234const obj = &#123; x: 100 &#125;const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const n = null //特殊引用类型，指针指向空地址function fn() &#123;&#125; //特殊引用类型，不用于存储数据，所以不存在“深拷贝”，“浅拷贝”，也可以看做第三个类型 1.4 值类型和引用类型例题123456789const obj1 =&#123; x:100, y:200&#125; const obj2 = obj1let x1 = obj1.xx1 = 102 // 干扰项，x1 是值类型，直接赋值，它的改变不会影响其它的量obj2.x = 101console.log(obj1.x); // 101 1.5 typeof 可以判断的类型 识别所有值类型 识别函数 判断是否为引用类型（不再细分） 12345678let a //typeof(a) undefined const s = &#x27;abc&#x27; //typeof(s) stringconst n = 100 //typeof(n) numberconst b = true //typeof(b) booleanconst sym = Symbol(&#x27;s&#x27;) //typeof(sym) symboltypeof(console.log) //function// 其余引用类型 typeof 只能判断为 object 2.变量计算-类型转换2.1 字符串拼接12345const a = 100 + 10 //110const b = 100 + &#x27;10&#x27; //&#x27;10010&#x27;const c = true + &#x27;10&#x27; //true10// 强制类型转换const d = 100 + parseInt(&#x27;100&#x27;); //200 2.2 何时使用 == 何时使用 === == 尽量转换 让二者相等 123456// 用 == 基本都是true，=== 才会返回false100 == &#x27;100&#x27; //true0 == &#x27;&#x27; //true0 == false //truefalse == &#x27;&#x27; //truenull == undefined //true 除了 == null 以外，其他一律都用 === 2.3 if语句和逻辑运算 truly 和 falsely 变量 123456789101112// truly 变量!!a === true// falsely 变量!!b === false// 以下是 falsely 变量，其余都是 truly 变量!!0 === false!!NaN === false!!&#x27;&#x27; === false!!null === false!!undefined === false!!false === false 在 if 语句中的应用（if判断 !! 之后是 truly 变量还是 falsely 变量） 123456789// truly 变量 const a = true if (a)&#123; ... &#125; const b = 100 if(b)&#123; ... &#125; 1234567891011121314151617// falsely 变量 const c = &#x27;&#x27; if(c)&#123; ... &#125; const d = null if(d)&#123; ... &#125; let e if(e)&#123; ... &#125; else&#123; //会走到这一步 &#125; 逻辑判断 123console.log(10 &amp;&amp; 0) // 0console.log(&#x27;&#x27; || &#x27;abc&#x27;) // &#x27;abc&#x27;console.log(window.abc) //true 2.4 手写深拷贝 注意判断值类型和引用类型 注意判断数组和对象 递归 123456789101112131415161718192021222324252627// 深拷贝部分 function deepClone(obj)&#123; let res = obj instanceof Array?[]:&#123;&#125;; if(typeof(obj)!==&#x27;object&#x27; || typeof(obj) == null)&#123; return obj; &#125; for(let key in obj)&#123; // 确保key不是原型链上的 if(obj.hasOwnProperty(key))&#123; // 递归（重点） key要一层一层遍历，比如说 obj&#123; address:&#123;city: &#x27;Beijing&#x27;&#125;&#125; res[key] = deepClone(obj[key]) &#125; &#125; return res;&#125;// test 部分let obj1 = &#123; address:&#123; city:&quot;Beijing&quot; &#125;&#125;let obj2 = deepClone(obj1);obj2.address.city = &quot;Shanghai&quot;;console.log(obj1.address.city);console.log(obj2.address.city); Q：深拷贝的堆栈模型图？","categories":[],"tags":[{"name":"值类型 引用类型 深拷贝 ==和=== truly和falsely变量","slug":"值类型-引用类型-深拷贝-和-truly和falsely变量","permalink":"http://example.com/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E5%92%8C-truly%E5%92%8Cfalsely%E5%8F%98%E9%87%8F/"}]},{"title":"前端面试CSS 响应式","slug":"前端面试CSS-响应式","date":"2021-10-22T11:33:37.000Z","updated":"2021-12-16T09:23:28.383Z","comments":true,"path":"2021/10/22/前端面试CSS-响应式/","link":"","permalink":"http://example.com/2021/10/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"1.rem是什么","text":"1.rem是什么 1.1 常见单位 px 绝对长度单位，最常用 em，相对长度单位，但是相对于父元素，所以不常用 rem，相对长度单位，相对于根元素，常用 1.2 代码展示123456789101112131415161718192021222324252627&lt;style&gt; html&#123; //作为基准的尺寸 font-size: 100px; &#125; div&#123; background-color: #ccc; height: 0.3rem; font-size: 0.1rem; margin-top: 0.1rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;width: 0.4rem;&quot;&gt; div1 &lt;/div&gt; &lt;div style=&quot;width: 0.5rem;&quot;&gt; div2 &lt;/div&gt; &lt;div style=&quot;width: 0.6rem;&quot;&gt; div3 &lt;/div&gt; &lt;/body&gt; 2.如何实现响应式 media-query 根据不同的屏幕宽度设置根元素的font-size rem，基于根元素的相关单位 2.1代码示例123456789101112131415161718@media screen and (max-width: 414px) &#123; html &#123; font-size: 18px &#125;&#125;@media screen and (max-width: 375px) &#123; html &#123; font-size: 16px &#125;&#125;@media screen and (max-width: 320px) &#123; html &#123; font-size: 12px &#125;&#125; 3.vw/vh3.1 rem的弊端rem具有“阶梯型”，标准卡得很死，范围不够动态。 3.2 网页视口尺寸（以height为例） window.screen.height 整个屏幕高度 window.innerHeight 网页视口高度，浏览器可以显示内容部分的高度 document.body.clientHeight 动态的，看内容有多高 3.3 vh和vm vh 网页视口高度的1/100 vm 网页视口宽度的 1/100 vmax 取两者的最大值；vmin取两者的最小值（一般来说，vh比较大，但是屏幕横过来，vm会比较大）","categories":[],"tags":[{"name":"rem vw vh响应式","slug":"rem-vw-vh响应式","permalink":"http://example.com/tags/rem-vw-vh%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"前端面试CSS 图文样式","slug":"前端面试CSS-图文样式","date":"2021-10-21T11:33:00.000Z","updated":"2021-12-16T09:23:17.387Z","comments":true,"path":"2021/10/21/前端面试CSS-图文样式/","link":"","permalink":"http://example.com/2021/10/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%9B%BE%E6%96%87%E6%A0%B7%E5%BC%8F/","excerpt":"1.line-height的继承问题","text":"1.line-height的继承问题 12345678910body&#123; font-size: 20px; line-height: 200%;&#125;p&#123; font-size:16px;&#125;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt;&lt;/body&gt; Q: p 标签的行高是多少？ A：40px 分析： 具体数值，则直接继承 写比例，直接继承 本身*比例 写百分比，先算完再继承（考点）","categories":[],"tags":[{"name":"line-height的继承问题","slug":"line-height的继承问题","permalink":"http://example.com/tags/line-height%E7%9A%84%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/"}]},{"title":"前端面试CSS 定位","slug":"前端面试CSS-定位","date":"2021-10-21T11:31:37.000Z","updated":"2021-12-16T09:23:10.477Z","comments":true,"path":"2021/10/21/前端面试CSS-定位/","link":"","permalink":"http://example.com/2021/10/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%AE%9A%E4%BD%8D/","excerpt":"1.absolute和relative分别依据什么定位","text":"1.absolute和relative分别依据什么定位 子绝父相 relative 根据自身定位 对外界元素不会有任何影响 absolute 根据最近一层父元素定位 2.居中对齐有什么方式 水平居中 inline元素 text-align：center 给父元素给自身都可以 它没有宽高 只是看文字 block元素 margin：auto 给自身 absolute元素 left：50% + margin-left 负值 （子元素的宽度的一半）给自身 注意父元素要relative 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;title&gt;水平居中&lt;/title&gt; &lt;style&gt; .container&#123; background-color: #9dd3a8; margin: 10px; padding: 10px; width: 500px; height: 50px; &#125; .item&#123; background-color: #fdc4b6; text-align: center; &#125; .container-1&#123; text-align: center; &#125; .container-2 .item&#123; width: 100px; margin: auto; &#125; .container-3&#123; position: relative; &#125; .container-3 .item&#123; position: absolute; width: 300px; left: 50%; margin-left: -150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container container-1&quot;&gt; &lt;span class=&quot;item&quot;&gt; inline元素 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container container-2 &quot;&gt; &lt;div class=&quot;item&quot;&gt; block元素 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container container-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; absolute元素 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 垂直居中（和水平居中情况类似） inline元素：line-height 等于height absolute元素： top：50% + margin-top负值 （知道子元素的高度） left: 50% + top: 50% + transform: translate(-50%，-50%) top left right bottom = 0 + margin：auto","categories":[],"tags":[{"name":"absolute relative 居中对齐","slug":"absolute-relative-居中对齐","permalink":"http://example.com/tags/absolute-relative-%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/"}]},{"title":"前端面试CSS 布局","slug":"前端面试CSS-布局","date":"2021-10-20T06:51:13.000Z","updated":"2021-12-16T09:22:32.733Z","comments":true,"path":"2021/10/20/前端面试CSS-布局/","link":"","permalink":"http://example.com/2021/10/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95CSS-%E5%B8%83%E5%B1%80/","excerpt":"1.盒子模型的宽度如何计算","text":"1.盒子模型的宽度如何计算 Q:div1 的offsetWidth 为多大？offsetWidth=（内容宽度 + 内边距 + 边框），无外边距（也就是没有margin） 12345678910111213&lt;style&gt; #div1&#123; width: 100px; padding: 10px; border: 1px solid #ccc; margin: 10px; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;/body&gt; A1：122px Q2：如果要让offsetWidth等于100 该怎么做？ A2： 加 box-sizing: border-box; 也就是说让width不再是单纯的内容宽度，而是border-box的宽度（包括到边框的宽度，也就是offsetWidth），这样内容宽度会缩小，但是padding和border和margin不会 2.margin纵向重叠的问题Q：AAA和BBB之间的距离是多少？ 12345678910111213141516&lt;style&gt; /* margin纵向重叠 */ p &#123; font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;BBB&lt;/p&gt;&lt;/body&gt; A：15px 相邻元素的margin-top 和 margin-bottom 会发生重叠，空白内容的 p 标签页会被重叠（我的理解是没有高度也没有内容的情况下，设置margin也没用，忽略即可）。 3.margin负值的问题Q：margin的bottom top left right设置成负值分别的作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;style&gt; body&#123; margin: 20px; &#125; .float-left&#123; float: left; &#125; .clearfix::after&#123; content: &#x27;&#x27;; display: table; clear: both; &#125; .container&#123; border: 1px solid #ccc; padding: 10px; &#125; .container .item&#123; width: 100px; height: 100px; &#125; .container .border-blue&#123; border: 1px solid blue; &#125; .container .border-red&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;marigin top bottom 为负值的情况&lt;/p&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 设置top 负值 item1自己往上移动 设置bottom负值 item2往上移动--&gt; &lt;div class=&quot;item border-blue&quot; style=&quot;margin-top: -20px;&quot;&gt; this is item1 &lt;/div&gt; &lt;div class=&quot;item border-red&quot;&gt; this is item2 &lt;/div&gt; &lt;/div&gt; &lt;p&gt;marigin left right 为负值的情况&lt;/p&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;!-- 设置left 负值 item1自己往左移动 设置right负值 item2往左移动--&gt; &lt;div class=&quot;item border-blue float-left&quot; style=&quot;margin-left: -20px;&quot;&gt; this is item3 &lt;/div&gt; &lt;div class=&quot;item border-red float-left&quot;&gt; this is item4 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; A： margin-top 和 margin-left 负值，元素向上、向左移动； margin-right负值，右侧元素左移，自身不受影响； margin-bottom负值，下方元素上移，自身元素不受影响 总的来说，都是让元素向左移/右移，只不过一个让自己移动，一个让别人移动 4.BFC理解和应用一般来说直接问，因为没有很适合的场景 Q: 什么是BFC以及如何应用 A： Block format context：块级格式化上下文；一块独立渲染区域，内部元素的渲染不会影响边界以外的元素 形成BFC的常见条件 float 不是 none position 是 absolute 或 fixed overflow 不是 visible display 是 flex inline-block等 前三者比较常用 BFC的常见应用 清除浮动（可以用clearfix也可以用BFC） 123456789101112131415&lt;style&gt; .container&#123; background-color: #ccc; &#125; .left&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;img/test2.jpg&quot; class=&quot;left&quot;&gt; &lt;p&gt;test.....&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 因为图片设置了浮动，所以会脱离文本流，飘在上面，但是没有bfc时，不会撑开自己本身的div，从而影响到其它块外的元素 用 overflow: hidden; 触发块级元素的bfc，也就是container的bfc，使得它里面的元素独立渲染 123456//style增加加.bfc&#123; overflow: hidden; &#125;//container增加&lt;div class=&quot;container bfc&quot;&gt;&lt;/div&gt; 5.float布局的问题以及 clearfixQ1:float布局：圣杯布局A1: 目的： 三栏布局，中间一栏最先加载和渲染（内容最重要） 两侧内容固定，中间内容随着宽度自适应 一般用于PC网页 技术总结（按照这三点来写代码，回答问题） 使用float布局 两侧使用margin负值，以便和中间内容横向重叠 防止中间内容被两侧覆盖，padding+margin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;style&gt; body&#123; min-width: 550px; &#125; .header&#123; text-align: center; background-color: #f1f1f1; &#125; .container&#123; /* padding 给左右两个盒子留出宽度 */ padding-left: 200px ; padding-right: 150px &#125; .center&#123; background-color: #ccc; width: 100%; &#125; .left&#123; /* left position设置relative margin-left设置本身宽度的负值 */ position: relative; background-color: yellow; width: 200px; margin-left: -200px; &#125; .right&#123; /* margin-right设置本身宽度的负值 */ background-color: pink; width: 150px; margin-right: -150px; &#125; .footer&#123; /* 给container里的元素设置了浮动会导致footer浮上来 所以需要设置clear：both清除浮动 */ clear: both; text-align: center; background-color: #f1f1f1; &#125; .column&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;center column&quot;&gt;center&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; Q2:双飞翼布局A2：用margin留白 用margin-left移动 比较简单1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; body&#123; min-width: 550px; &#125; #main&#123; width: 100%; height: 200px; background-color: pink; &#125; #main-wrap&#123; margin: 0 190px 0 190px; &#125; #left&#123; width: 190px; height: 200px; background-color: yellow; margin-left: -100%; &#125; #right&#123; width: 190px; height: 200px; background-color: orange; margin-left: -190px ; &#125; .column&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;main&quot; class=&quot;column&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt; main &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt; left &lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt; right &lt;/div&gt;&lt;/body&gt; Q3:手写clearfixA3：123456/* 比如说圣杯布局 不给foot单独加去浮动的话，可以给container加这个清除浮动 不影响后面的元素 */ .clearfix::after&#123; content: &#x27;&#x27;; display: table; clear: both; &#125; 6.flex布局 常用语法 flex-direction justify-content align-items flex-wrap align-self Q：实现一个三点的色子A： 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .box&#123; width: 200px; height: 200px; border: 2px solid #ccc; border-radius: 10px; padding: 20px; /* 关键 */ display: flex; justify-content: space-between; //两端对齐 &#125; .item&#123; display: block; width: 40px; height: 40px; border-radius: 50%; background-color: pink; &#125; /* 关键 */ .item:nth-child(2)&#123; align-self: center; //第二项居中对齐 &#125; .item:nth-child(3)&#123; align-self: flex-end; //第三项尾对齐 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"盒模型 margin BFC 圣杯/双飞翼布局 flex布局","slug":"盒模型-margin-BFC-圣杯-双飞翼布局-flex布局","permalink":"http://example.com/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B-margin-BFC-%E5%9C%A3%E6%9D%AF-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80-flex%E5%B8%83%E5%B1%80/"}]},{"title":"前端面试HTML篇","slug":"前端面试HTML篇","date":"2021-10-19T11:24:06.000Z","updated":"2021-12-16T09:23:44.539Z","comments":true,"path":"2021/10/19/前端面试HTML篇/","link":"","permalink":"http://example.com/2021/10/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95HTML%E7%AF%87/","excerpt":"1.如何理解语义化1）给人看：具有可读性，易懂 2）给搜索引擎看：让搜索引擎读得懂（机器可以识别标签），SEO优化","text":"1.如何理解语义化1）给人看：具有可读性，易懂 2）给搜索引擎看：让搜索引擎读得懂（机器可以识别标签），SEO优化 12345678&lt;div&gt;标题&lt;/div&gt;&lt;div&gt; &lt;div&gt;文字内容&lt;/div&gt; &lt;div&gt; &lt;div&gt;列表1&lt;/div&gt; &lt;div&gt;列表2&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678&lt;h1&gt;标题&lt;/h1&gt;&lt;div&gt; &lt;p&gt;文字&lt;/p&gt; &lt;ul&gt; &lt;li&gt;列表1&lt;/li&gt; &lt;li&gt;列表2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.HTML标签：块级元素和内联元素1）块级元素： 12display：block/tablediv h1 h2 table ul ol p 2）内联元素 12display：inline/inline-blockbutton img span input","categories":[],"tags":[{"name":"语义化 块级元素 内联元素","slug":"语义化-块级元素-内联元素","permalink":"http://example.com/tags/%E8%AF%AD%E4%B9%89%E5%8C%96-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0/"}]},{"title":"Flex布局总结","slug":"Flex布局总结","date":"2021-10-19T02:21:14.000Z","updated":"2021-11-25T08:57:29.894Z","comments":true,"path":"2021/10/19/Flex布局总结/","link":"","permalink":"http://example.com/2021/10/19/Flex%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93/","excerpt":"1.布局原理","text":"1.布局原理 flexible Box 意思是弹性布局 通过给父元素添加flex属性，从而控制子盒子的位置和排列方式。任何元素（块级和行内块元素）都可以采用flex布局。采用flex布局以后，float，clear和vertical-align都会失效 1.1container和item 采用Flex布局的元素叫做container（容器），它的所有子元素自动称为容器成员，称为flex item （项目） item可以纵向排列也可以横行排列 2.父元素常见属性 属性 作用 flex-direction 设置主轴方向 justify-content 设置主轴上子元素排列方式 flex-wrap 设置子元素是否换行 align-content 设置侧轴子元素的排列方式（多行） align-items 设置侧轴子元素的排列方式（单行） flex-flow 复合属性，相当于 flex-direction + flex-wrap 2.1 flex-direction 元素是跟着主轴排列的，设置 x 为主轴，那么 y 就是侧轴，反之亦然； 属性 属性值 作用 row 默认主轴为x轴，从左到右 row-reverse 从右到左，元素顺序也会跟着翻转 column 设置主轴为y轴，从上到下 column-reverse 从下到上，元素顺序也会跟着翻转 2.2 justify-content 设置主轴上子元素的排列方式，使用之前要确定好主轴方向 属性 属性 作用 flex-start 默认值，从左到右/从上到下排列 flex-end 从尾部开始排列 center 在主轴居中对齐 space-around 平分剩余空间（eg：主轴是x轴，子元素margin-left和margin-right相同） space-between 两边贴边，中间元素平分空间（重要） 2.3 flex-wrap 设置子元素是否换行 当子元素在父元素中空间不够时，flex布局默认不换行，等比例缩小子元素宽度之后排成一行 no-wrap 不换行 / wrap 不够另起一行 2.4 align-items 设置侧轴元素排列方式（单行） 设置侧轴元素排列方式 和主轴搭配使用可以实现居正中效果 属性 （默认侧轴是 y 轴） 属性 作用 flex-start 从上到下 flex-end 从下到上 center 垂直居中 stretch 拉伸（默认值） 2.5 align-content 设置侧轴元素排列方式（多行） 多行：子元素出现要换行的情况 （flex-wrap: wrap;） 属性 属性 作用 flex-start 默认从侧轴头部开始排列 flex-end 从侧轴尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 两边贴边，中间元素平分空间 stretch 设置子项元素平分父元素高度 2.6 flex-flow eg：flex-wrap: column wrap 3.子元素常用属性 flex items占的份数 align-self 控制子项自己在侧轴排列的方式 order 属性定义子项的排列顺序（前后顺序） 3.1 flex 属性 分配剩余空间 flex: number 默认是 0 3.2 align-self 允许单个item与其它 item 有不一样的对齐方式，覆盖align-items属性 3.3 order 定义item的排列顺序 数值越小顺序越前","categories":[],"tags":[{"name":"flex","slug":"flex","permalink":"http://example.com/tags/flex/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2021-10-18T06:51:13.000Z","updated":"2021-12-16T09:31:43.935Z","comments":true,"path":"2021/10/18/KMP算法/","link":"","permalink":"http://example.com/2021/10/18/KMP%E7%AE%97%E6%B3%95/","excerpt":"1.概述：KMP算法主要用在字符串匹配上，需要一个前缀表和一个next数组","text":"1.概述：KMP算法主要用在字符串匹配上，需要一个前缀表和一个next数组 2.过程：以模板字符串 aabaaf 和目标字符串 aabaabaafa 为例： 1）如果暴力匹配，那么在 f 匹配不上时，就需要从头开始匹配，效率很低 2）如果是KMP算法，模板字符串匹配到 f 时， 不从头开始，而是从 b 开始匹配。思想非常简单，我们可以发现，对于 aabaabaafa 在第二个 b 我们匹配不上了，但是这个b前面的aa和模板字符串的开头aa是一样的，所以从aa后面一个值开始匹配是效率最高的。 动图如下： 3.前缀表现在有一个问题是，在字符不匹配时，我们怎么知道下一步该从哪里开始呢？这里就需要用到前缀表了。 1）先说一下什么是前缀和后缀：前缀：不包括最后一个字符，包括第一个字符的所有连续子字符串。 eg：aabaaf的所有前缀：a, aa, aab, aaba, aabaa 不包括aabaaf 后缀：与前缀刚好相反 eg：aabaaf的所有后缀：f, af, aaf, baaf, abaaf 不包括aabaaf 2）前缀表：记录当前索引 i 之前（包括 i ）的字符串中，有多大长度的相同前后缀。aabaaf的前缀表 0 1 2 3 4 a aa aab aaba aabaa 0 1 0 1 2 单纯得到这个表还是很简单的，要么把字符串的前后缀都写出来，看交集最长为多少，要么就直接看字符串前后重合的字符有多少个。关键是要理解这个表的意思。 3)前缀表的含义前面已经说过，碰到不匹配的字符串时，我们不能浪费掉之前已经匹配过的字符串，我们跳过索引 i 之前已经匹配好了的字符串，从这个字符串的后面一个开始匹配。 目标字符串从索引5的 b 开始不匹配，也就是说b以前的都是匹配的，而我们又知道在模板字符串里，同样索引位置的前两个字符在开头有重复，所以，我们就可以跳到第三个（索引2）开始下一次匹配。这也是KMP算法对暴力算法的优化所在于，它不再从头开始。 4.得到next数组123456789101112131415const getNext = (s)=&gt;&#123; let next = []; let j = 0; next.push(j); for(let i = 1;i&lt;s.length;++i)&#123; //注意这里是while 不是 if 因为j是连续回跳，直到到了索引0或者跳到了指定位置 while(j&gt;0&amp;&amp;s[i]!==s[j])&#123; j = next[j-1] &#125; if(s[i]===s[j]) j++; next.push(j); &#125; return next; &#125; 5.例题leetcode459 重复的字符子串 https://leetcode-cn.com/problems/repeated-substring-pattern/给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 1234567示例：输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。输入: &quot;aba&quot;输出: False 1234567891011121314151617181920212223// KMPvar repeatedSubstringPattern = function(s) &#123; if(s.length === 0) return false; const getNext = (s)=&gt;&#123; let next = []; let j = 0; next.push(j); for(let i = 1;i&lt;s.length;++i)&#123; while(j&gt;0&amp;&amp;s[i]!==s[j])&#123; j = next[j-1] &#125; if(s[i]===s[j]) j++; next.push(j); &#125; return next; &#125; let next = getNext(s); if(next[next.length-1]!==0 &amp;&amp; s.length%(s.length - next[next.length - 1])===0) return true; return false;&#125;; leetcode28 实现 strStr() 函数 https://leetcode-cn.com/problems/implement-strstr给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 12345678910111213141516171819202122232425262728var strStr = function(haystack, needle) &#123; if(needle.length === 0) return 0; const getNext = (needle)=&gt;&#123; let next = []; let j = 0; next.push(j); for(let i = 1;i&lt;needle.length;++i)&#123; while(j&gt;0&amp;&amp;needle[i]!==needle[j])&#123; j = next[j-1] &#125; if(needle[i]===needle[j]) j++; next.push(j); &#125; return next; &#125; let next = getNext(needle); let j = 0; for(let i = 0;i&lt;haystack.length;++i)&#123; while(j&gt;0&amp;&amp;haystack[i]!==needle[j]) j = next[j-1]; if(haystack[i]===needle[j]) j++; if(j === needle.length) return (i-needle.length+1) &#125; return -1;&#125;;","categories":[],"tags":[{"name":"KMP算法","slug":"KMP算法","permalink":"http://example.com/tags/KMP%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"深拷贝 简单深比较","slug":"深拷贝-简单深比较","permalink":"http://example.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E7%AE%80%E5%8D%95%E6%B7%B1%E6%AF%94%E8%BE%83/"},{"name":"前端面试","slug":"前端面试","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"},{"name":"手写防抖 手写节流","slug":"手写防抖-手写节流","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96-%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81/"},{"name":"网页加载","slug":"网页加载","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD/"},{"name":"Linux命令","slug":"Linux命令","permalink":"http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"手写Promise","slug":"手写Promise","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99Promise/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"},{"name":"ajax 跨域 同源策略","slug":"ajax-跨域-同源策略","permalink":"http://example.com/tags/ajax-%E8%B7%A8%E5%9F%9F-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"JS Web API","slug":"JS-Web-API","permalink":"http://example.com/tags/JS-Web-API/"},{"name":"微任务 宏任务 eventloop和dom渲染 手写promise","slug":"微任务-宏任务-eventloop和dom渲染-手写promise","permalink":"http://example.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E5%AE%8F%E4%BB%BB%E5%8A%A1-eventloop%E5%92%8Cdom%E6%B8%B2%E6%9F%93-%E6%89%8B%E5%86%99promise/"},{"name":"EventLoop Promise async await for...of","slug":"EventLoop-Promise-async-await-for-of","permalink":"http://example.com/tags/EventLoop-Promise-async-await-for-of/"},{"name":"同步 异步","slug":"同步-异步","permalink":"http://example.com/tags/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/"},{"name":"java读取文件","slug":"java读取文件","permalink":"http://example.com/tags/java%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/"},{"name":"作用域 闭包 this 手写bind","slug":"作用域-闭包-this-手写bind","permalink":"http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-this-%E6%89%8B%E5%86%99bind/"},{"name":"原型 原型链 class继承 instanceof","slug":"原型-原型链-class继承-instanceof","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-class%E7%BB%A7%E6%89%BF-instanceof/"},{"name":"值类型 引用类型 深拷贝 ==和=== truly和falsely变量","slug":"值类型-引用类型-深拷贝-和-truly和falsely变量","permalink":"http://example.com/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E5%92%8C-truly%E5%92%8Cfalsely%E5%8F%98%E9%87%8F/"},{"name":"rem vw vh响应式","slug":"rem-vw-vh响应式","permalink":"http://example.com/tags/rem-vw-vh%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"line-height的继承问题","slug":"line-height的继承问题","permalink":"http://example.com/tags/line-height%E7%9A%84%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/"},{"name":"absolute relative 居中对齐","slug":"absolute-relative-居中对齐","permalink":"http://example.com/tags/absolute-relative-%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/"},{"name":"盒模型 margin BFC 圣杯/双飞翼布局 flex布局","slug":"盒模型-margin-BFC-圣杯-双飞翼布局-flex布局","permalink":"http://example.com/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B-margin-BFC-%E5%9C%A3%E6%9D%AF-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80-flex%E5%B8%83%E5%B1%80/"},{"name":"语义化 块级元素 内联元素","slug":"语义化-块级元素-内联元素","permalink":"http://example.com/tags/%E8%AF%AD%E4%B9%89%E5%8C%96-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0/"},{"name":"flex","slug":"flex","permalink":"http://example.com/tags/flex/"},{"name":"KMP算法","slug":"KMP算法","permalink":"http://example.com/tags/KMP%E7%AE%97%E6%B3%95/"}]}